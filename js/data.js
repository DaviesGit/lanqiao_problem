const problem = [{"name":"入门训练","prefix":"BEGIN-","problems":[{"checkpoint":"入门 数列 取模","updatetime":"2013-10-09","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n\t<p>Fibonacci数列的递推公式为：F<sub>n</sub>=F<sub>n-1</sub>+F<sub>n-2</sub>，其中F<sub>1</sub>=F<sub>2</sub>=1。</p>\n\t<p>当n比较大时，F<sub>n</sub>也非常大，现在我们想知道，F<sub>n</sub>除以10007的余数是多少。</p>\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\t输入包含一个整数n。</div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\t输出一行，包含一个整数，表示F<sub>n</sub>除以10007的余数。\n\t<div class=\"sec_note\">\n\t<p>说明：在本题中，答案是要求F<sub>n</sub>除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出F<sub>n</sub>的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。</p>\n\t</div>\n</div>\n<div class=\"sec_header\">\n样例输入</div>\n<div class=\"sec_text\">\n\t10</div>\n<div class=\"sec_header\">\n样例输出</div>\n<div class=\"sec_text\">\n\t55</div>\n<div class=\"sec_header\">\n样例输入</div>\n<div class=\"sec_text\">\n\t22</div>\n<div class=\"sec_header\">\n样例输出</div>\n<div class=\"sec_text\">\n\t7704</div>\n<div class=\"sec_header\">\n数据规模与约定</div>\n<div class=\"sec_cont\">\n\t1 &lt;= n &lt;= 1,000,000。</div>\n","gpid":"T4","lanqiaotitle":"Fibonacci数列","memorylimit":"256.0MB","tid":"BEGIN-4","timelimit":"1.0s","title":"入门训练 Fibonacci数列","src":""},{"checkpoint":"入门 实数输出","updatetime":"2013-10-09","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n\t给定圆的半径r，求圆的面积。\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\t输入包含一个整数r，表示圆的半径。\n</div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\t输出一行，包含一个实数，四舍五入保留小数点后7位，表示圆的面积。\n\t<div class=\"sec_note\">\n\t<p>说明：在本题中，输入是一个整数，但是输出是一个实数。</p>\n\t<p>对于实数输出的问题，请一定看清楚实数输出的要求，比如本题中要求保留小数点后7位，则你的程序必须<b>严格的</b>输出7位小数，输出过多或者过少的小数位数都是不行的，都会被认为错误。</p>\n\t<p>实数输出的问题如果没有特别说明，舍入都是按四舍五入进行。</p>\n\t</div>\n</div>\n<div class=\"sec_header\">\n样例输入</div>\n<div class=\"sec_text\">\n\t4\n</div>\n<div class=\"sec_header\">\n样例输出</div>\n<div class=\"sec_text\">\n\t50.2654825\n</div>\n<div class=\"sec_header\">\n数据规模与约定</div>\n<div class=\"sec_cont\">\n\t1 &lt;= r &lt;= 10000。\n</div>\n<div class=\"sec_header\">\n提示</div>\n<div class=\"sec_cont\">\n\t本题对精度要求较高，请注意&pi;的值应该取较精确的值。你可以使用常量来表示&pi;，比如PI=3.14159265358979323，也可以使用数学公式来求&pi;，比如PI=atan(1.0)*4。\n</div>\n","gpid":"T3","lanqiaotitle":"圆的面积","memorylimit":"256.0MB","tid":"BEGIN-3","timelimit":"1.0s","title":"入门训练 圆的面积","src":""},{"checkpoint":"入门 求和公式","updatetime":"2013-10-09","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n\t求1+2+3+...+n的值。\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\t输入包括一个整数n。\n</div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\t输出一行，包括一个整数，表示1+2+3+...+n的值。\n</div>\n<div class=\"sec_header\">\n样例输入</div>\n<div class=\"sec_text\">\n\t4\n</div>\n<div class=\"sec_header\">\n样例输出</div>\n<div class=\"sec_text\">\n\t10\n</div>\n<div class=\"sec_header\">\n样例输入</div>\n<div class=\"sec_text\">\n\t100\n\t<div class=\"sec_note\">\n\t<p>说明：有一些试题会给出多组样例输入输出以帮助你更好的做题。</p>\n\t<p>一般在提交之前所有这些样例都需要测试通过才行，但这不代表这几组样例数据都正确了你的程序就是完全正确的，潜在的错误可能仍然导致你的得分较低。</p>\n\t</div>\n</div>\n<div class=\"sec_header\">\n样例输出</div>\n<div class=\"sec_text\">\n\t5050\n</div>\n<div class=\"sec_header\">\n数据规模与约定</div>\n<div class=\"sec_cont\">\n\t1 &lt;= n &lt;= 1,000,000,000。\n\t<div class=\"sec_note\">\n\t<p>说明：请注意这里的数据规模。</p>\n\t<p>本题直接的想法是直接使用一个循环来累加，然而，当数据规模很大时，这种“暴力”的方法往往会导致超时。此时你需要想想其他方法。你可以试一试，如果使用1000000000作为你的程序的输入，你的程序是不是能在规定的上面规定的时限内运行出来。</p>\n\t<p>本题另一个要值得注意的地方是答案的大小不在你的语言默认的整型(int)范围内，如果使用整型来保存结果，会导致结果错误。</p>\n\t<p>如果你使用C++或C语言而且准备使用printf输出结果，则你的格式字符串应该写成%I64d以输出long long类型的整数。</p>\n\t</div>\n</div>\n","gpid":"T2","lanqiaotitle":"序列求和","memorylimit":"256.0MB","tid":"BEGIN-2","timelimit":"1.0s","title":"入门训练 序列求和","src":""},{"checkpoint":"入门","updatetime":"2013-10-09","content":"<div class=\"sec_header\">问题描述</div>\n<div class=\"sec_cont\">输入A、B，输出A+B。\n<div class=\"sec_note\">说明：在&ldquo;问题描述&rdquo;这部分，会给出试题的意思，以及所要求的目标。</div>\n</div>\n<div class=\"sec_header\">输入格式</div>\n<div class=\"sec_cont\">输入的第一行包括两个整数，由空格分隔，分别表示A、B。\n<div class=\"sec_note\">\n<p>说明：&ldquo;输入格式&rdquo;是描述在测试你的程序时，所给的输入一定满足的格式。</p>\n<p>做题时你应该假设所给的输入是一定满足输入格式的要求的，所以你不需要对输入的格式进行检查。多余的格式检查可能会适得其反，使用你的程序错误。</p>\n<p>在测试的时候，系统会自动将输入数据输入到你的程序中，你不能给任何提示。比如，你在输入的时候提示&ldquo;请输入A、B&rdquo;之类的话是不需要的，这些多余的输出会使得你的程序被判定为错误。</p>\n</div>\n</div>\n<div class=\"sec_header\">输出格式</div>\n<div class=\"sec_cont\">输出一行，包括一个整数，表示A+B的值。\n<div class=\"sec_note\">\n<p>说明：&ldquo;输出格式&rdquo;是要求你的程序在输出结果的时候必须满足的格式。</p>\n<p>在输出时，你的程序必须满足这个格式的要求，不能少任何内容，也不能多任何内容。如果你的内容和输出格式要求的不一样，你的程序会被判断为错误，包括你输出了提示信息、中间调试信息、计时或者统计的信息等。</p>\n</div>\n</div>\n<div class=\"sec_header\">样例输入</div>\n<div class=\"sec_text\">12 45\n<div class=\"sec_note\">\n<p>说明：&ldquo;样例输入&rdquo;给出了一组满足&ldquo;输入格式&rdquo;要求的输入的例子。</p>\n<p>这里给出的输入只是可能用来测试你的程序的一个输入，在测试的时候，还会有更多的输入用来测试你的程序。</p>\n</div>\n</div>\n<div class=\"sec_header\">样例输出</div>\n<div class=\"sec_text\">57\n<div class=\"sec_note\">\n<p>说明：&ldquo;样例输出&rdquo;给出了一组满足&ldquo;输出格式&rdquo;要求的输出的例子。</p>\n<p>样例输出中的结果是和样例输入中的是对应的，因此，你可以使用样例的输入输出简单的检查你的程序。</p>\n<p>要特别指出的是，能够通过样例输入输出的程序并不一定是正确的程序，在测试的时候，会用很多组数据进行测试，而不局限于样例数据。有可能一个程序通过了样例数据，但测试的时候仍只能得0分，可能因为这个程序只在一些类似样例的特例中正确，而不具有通用性，再测试更多数据时会出现错误。</p>\n<p>比如，对于本题，如果你写一个程序不管输入是什么都输入57，则样例数据是对的，但是测试其他数据，哪怕输入是1和2，这个程序也输出57，则对于其他数据这个程序都不正确。</p>\n</div>\n</div>\n<div class=\"sec_header\">数据规模与约定</div>\n<div class=\"sec_cont\">-10000 &lt;= A, B &lt;= 10000。\n<div class=\"sec_note\">\n<p>说明：&ldquo;数据规模与约定&rdquo;中给出了试题中主要参数的范围。</p>\n<p>这个范围对于解题非常重要，不同的数据范围会导致试题需要使用不同的解法来解决。比如本题中给的A、B范围不大，可以使用整型(int)来保存，如果范围更大，超过int的范围，则要考虑其他方法来保存大数。</p>\n<p>有一些范围在方便的时候是在&ldquo;问题描述&rdquo;中直接给的，所以在做题时不仅要看这个范围，还要注意问题描述。</p>\n</div>\n</div>\n<div class=\"sec_header\">提示</div>\n<div class=\"sec_cont\">\n<p>本题的C++源代码如下：</p>\n<div class=\"code codec\">\n<ol>\n    <li><span class=\"de\">#include &lt;iostream&gt;</span></li>\n    <li>&nbsp;</li>\n    <li><span class=\"k\">using namespace</span> std<span class=\"s\">;</span></li>\n    <li>&nbsp;</li>\n    <li><span class=\"k\">int</span> main<span class=\"s\">()</span></li>\n    <li><span class=\"s\">{</span></li>\n    <li>&nbsp; &nbsp; <span class=\"k\">int</span> a<span class=\"s\">,</span> b<span class=\"s\">;</span></li>\n    <li>&nbsp; &nbsp; cin <span class=\"s\">&gt;&gt;</span> a <span class=\"s\">&gt;&gt;</span> b<span class=\"s\">;</span></li>\n    <li>&nbsp; &nbsp; cout <span class=\"s\">&lt;&lt;</span> a <span class=\"s\">+</span> b<span class=\"s\">;</span></li>\n    <li>&nbsp; &nbsp; <span class=\"k\">return</span> <span class=\"n\">0</span><span class=\"s\">;</span></li>\n    <li><span class=\"s\">}</span></li>\n</ol>\n</div>\n<p>本题的C源代码如下：</p>\n<div class=\"code codec\">\n<ol>\n    <li><span class=\"de\">#include &lt;stdio.h&gt;</span></li>\n    <li>&nbsp;</li>\n    <li><span class=\"k\">int</span> main<span class=\"s\">()</span></li>\n    <li><span class=\"s\">{</span></li>\n    <li>&nbsp; &nbsp; <span class=\"k\">int</span> a<span class=\"s\">,</span> b<span class=\"s\">;</span></li>\n    <li>&nbsp; &nbsp; scanf<span class=\"s\">(</span><span class=\"st\">&quot;%d%d&quot;</span>, <span class=\"s\">&amp;</span>a<span class=\"s\">,</span> <span class=\"s\">&amp;</span>b<span class=\"s\">);</span></li>\n    <li>&nbsp; &nbsp; printf<span class=\"s\">(</span><span class=\"st\">&quot;%d&quot;</span><span class=\"s\">,</span> a<span class=\"s\">+</span>b<span class=\"s\">);</span></li>\n    <li>&nbsp; &nbsp; <span class=\"k\">return</span> <span class=\"n\">0</span><span class=\"s\">;</span></li>\n    <li><span class=\"s\">}</span></li>\n</ol>\n</div>\n<p>本题的Java源代码如下：</p>\n<div class=\"code codejava\">\n<ol>\n    <li><span class=\"k\">import</span> java.util.*;</li>\n    <li>&nbsp;</li>\n    <li><span class=\"k\">public</span> <span class=\"k\">class</span> Main</li>\n    <li><span class=\"s\">{</span></li>\n    <li>&nbsp; &nbsp; <span class=\"k\">public</span> <span class=\"k\">static</span> <span class=\"k\">void</span> main<span class=\"s\">(</span>String args<span class=\"s\">[])</span></li>\n    <li>&nbsp; &nbsp; <span class=\"s\">{</span></li>\n    <li>&nbsp; &nbsp; &nbsp; &nbsp; Scanner sc <span class=\"s\">=</span> <span class=\"k\">new</span> Scanner<span class=\"s\">(</span>System.in<span class=\"s\">);</span></li>\n    <li>&nbsp; &nbsp; &nbsp; &nbsp; Integer a <span class=\"s\">=</span> sc.nextInt<span class=\"s\">();</span></li>\n    <li>&nbsp; &nbsp; &nbsp; &nbsp; Integer b <span class=\"s\">=</span> sc.nextInt<span class=\"s\">();</span></li>\n    <li>&nbsp; &nbsp; &nbsp; &nbsp; System<span class=\"s\">.</span>out<span class=\"s\">.</span>println<span class=\"s\">(</span>a <span class=\"s\">+</span> b<span class=\"s\">)</span><span class=\"s\">;</span></li>\n    <li>&nbsp; &nbsp; <span class=\"s\">}</span></li>\n    <li><span class=\"s\">}</span></li>\n</ol>\n</div>\n<div class=\"sec_note\">\n<p>说明：要答题，请点击页面上方的&ldquo;提交此题&rdquo;按钮，页面将跳转到提交代码的页面，选择好你的编译语言，将你的编写好的代码粘贴到代码框中，再点击&ldquo;提交答案&rdquo;即可。</p>\n<p>你的答案提交给系统后系统会自动对你的代码进行判分，并跳转到结果的列表里面，你可以直接从列表中看到你提交的代码的状态，一般几秒钟后就可以看到判分的结果。</p>\n<p>本题作为第一题，在提示中已经分别给了C++和Java的代码，你可以直接把这个代码拷贝过去作为自己的代码提交。</p>\n<p>请特别注意，Java的主类名必须是Main。</p>\n</div>\n</div>","gpid":"T1","lanqiaotitle":"A+B问题","memorylimit":"256.0MB","tid":"BEGIN-1","timelimit":"1.0s","title":"入门训练 A+B问题","src":""}]},{"name":"基础练习","prefix":"BASIC-","problems":[{"checkpoint":"数组 排序","updatetime":"2013-11-01","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个长度为n的数列，将这个数列按从小到大的顺序排列。1&lt;=n&lt;=200</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行为一个整数n。<br />\n　　第二行包含n个整数，为待排序的数，每个整数的绝对值小于10000。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行，按从小到大的顺序输出排序后的数列。</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n8 3 6 4 9</div><div class='pdsec'>样例输出</div><div class='pddata'>3 4 6 8 9</div>\n","gpid":"T52","lanqiaotitle":"数列排序","memorylimit":"512.0MB","tid":"BASIC-13","timelimit":"1.0s","title":"基础练习 数列排序","src":""},{"checkpoint":"进制转换 字符 循环","updatetime":"2013-11-01","content":"<div class='pdcont'><b>问题描述</b><b></b><br />\n　　给定n个十六进制正整数，输出它们对应的八进制数。<br />\n<br />\n<b>输入格式</b><b></b><br />\n　　输入的第一行为一个正整数n （1&lt;=n&lt;=10）。<br />\n　　接下来n行，每行一个由0~9、大写字母A~F组成的字符串，表示要转换的十六进制正整数，每个十六进制数长度不超过100000。<br />\n<br />\n<b>输出格式</b><b></b><br />\n　　输出n行，每行为输入对应的八进制正整数。<br />\n<br />\n　　<b>【注意</b><b></b>】<br />\n　　输入的十六进制数不会有前导0，比如012A。<br />\n　　输出的八进制数也不能有前导0。<br />\n<br />\n<b>样例输入</b><b></b><br />\n　　2<br />\n　　39<br />\n　　123ABC<br />\n<br />\n<b>样例输出</b><b></b><br />\n　　71<br />\n　　4435274<br />\n<br />\n　　<b><b>【</b>提示</b><b></b>】<br />\n　　先将十六进制数转换成某进制数，再由某进制数转换成八进制。</div>\n","gpid":"T51","lanqiaotitle":"十六进制转八进制","memorylimit":"512.0MB","tid":"BASIC-12","timelimit":"1.0s","title":"基础练习 十六进制转八进制","src":""},{"checkpoint":"进制转换 字符处理 判断","updatetime":"2013-11-01","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　从键盘输入一个不超过8位的正的十六进制数字符串，将它转换为正的十进制数后输出。<br />\n　　注：十六进制数中的10~15分别用大写的英文字母A、B、C、D、E、F表示。</div><div class='pdsec'>样例输入</div><div class='pddata'>FFFF</div><div class='pdsec'>样例输出</div><div class='pddata'>65535</div>\n","gpid":"T50","lanqiaotitle":"十六进制转十进制","memorylimit":"512.0MB","tid":"BASIC-11","timelimit":"1.0s","title":"基础练习 十六进制转十进制","src":""},{"checkpoint":"循环 整除 求余 判断","updatetime":"2013-11-01","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　十六进制数是在程序设计时经常要使用到的一种整数的表示方式。它有0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F共16个符号，分别表示十进制数的0至15。十六进制的计数方法是满16进1，所以十进制数16在十六进制中是10，而十进制的17在十六进制中是11，以此类推，十进制的30在十六进制中是1E。<br />\n　　给出一个非负整数，将它表示成十六进制的形式。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含一个非负整数a，表示要转换的数。0&lt;=a&lt;=2147483647</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出这个整数的16进制表示</div><div class='pdsec'>样例输入</div><div class='pddata'>30</div><div class='pdsec'>样例输出</div><div class='pddata'>1E</div>\n","gpid":"T49","lanqiaotitle":"十进制转十六进制","memorylimit":"512.0MB","tid":"BASIC-10","timelimit":"1.0s","title":"基础练习 十进制转十六进制","src":""},{"checkpoint":"回文数 循环 条件语句","updatetime":"2013-11-01","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　123321是一个非常特殊的数，它从左边读和从右边读是一样的。<br />\n　　输入一个正整数n， 编程求所有这样的五位和六位十进制数，满足各位数字之和等于n 。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入一行，包含一个正整数n。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　按从小到大的顺序输出满足条件的整数，每个整数占一行。</div><div class='pdsec'>样例输入</div><div class='pddata'>52</div><div class='pdsec'>样例输出</div><div class='pddata'>899998<br />\n989989<br />\n998899</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=n&lt;=54。</div>\n","gpid":"T48","lanqiaotitle":"特殊回文数","memorylimit":"512.0MB","tid":"BASIC-9","timelimit":"1.0s","title":"基础练习 特殊回文数","src":""},{"checkpoint":"循环 判断 回文数","updatetime":"2013-11-01","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　1221是一个非常特殊的数，它从左边读和从右边读是一样的，编程求所有这样的四位十进制数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　按从小到大的顺序输出满足条件的四位十进制数。</div>\n","gpid":"T47","lanqiaotitle":"回文数","memorylimit":"512.0MB","tid":"BASIC-8","timelimit":"1.0s","title":"基础练习 回文数","src":""},{"checkpoint":"循环 判断 数位","updatetime":"2013-11-01","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　153是一个非常特殊的数，它等于它的每位数字的立方和，即153=1*1*1+5*5*5+3*3*3。编程求所有满足这种条件的三位十进制数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　按从小到大的顺序输出满足条件的三位十进制数，每个数占一行。</div>\n","gpid":"T46","lanqiaotitle":"特殊的数字","memorylimit":"512.0MB","tid":"BASIC-7","timelimit":"1.0s","title":"基础练习 特殊的数字","src":""},{"checkpoint":"基础练习 二维数组","updatetime":"2013-10-09","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n\t<p>杨辉三角形又称Pascal三角形，它的第i+1行是(a+b)<sup>i</sup>的展开式的系数。</p>\n　　<p>它的一个重要性质是：三角形中的每个数字等于它两肩上的数字相加。</p>\n　　<p>下面给出了杨辉三角形的前4行：</p>\n　　<p>&nbsp;&nbsp;&nbsp;1</p>\n　　<p>&nbsp;&nbsp;1 1</p>\n　　<p>&nbsp;1 2 1</p>\n　　<p>1 3 3 1</p>\n　　<p>给出n，输出它的前n行。</p>\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\t<p>输入包含一个数n。</p></div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\t输出杨辉三角形的前n行。每一行从这一行的第一个数开始依次输出，中间使用一个空格分隔。请不要在前面输出多余的空格。\n</div>\n<div class=\"sec_header\">\n样例输入</div>\n<div class=\"sec_text\">\n\t4\n</div>\n<div class=\"sec_header\">\n样例输出</div>\n<div class=\"sec_text\">\n\t1<br />\n1 1<br />\n1 2 1<br />\n1 3 3 1\n\t</div>\n<div class=\"sec_header\">\n数据规模与约定</div>\n<div class=\"sec_cont\">\n\t1 &lt;= n &lt;= 34。\n</div>","gpid":"T10","lanqiaotitle":"杨辉三角形","memorylimit":"256.0MB","tid":"BASIC-6","timelimit":"1.0s","title":"基础练习 杨辉三角形","src":""},{"checkpoint":"循环 判断","updatetime":"2013-10-09","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n\t<p>给出一个包含n个整数的数列，问整数a在数列中的第一次出现是第几个。</p>\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\t<p>第一行包含一个整数n。</p>\n\t<p>第二行包含n个非负整数，为给定的数列，数列中的每个数都不大于10000。</p>\n\t<p>第三行包含一个整数a，为待查找的数。</p></div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\t如果a在数列中出现了，输出它第一次出现的位置(位置从1开始编号)，否则输出-1。\n</div>\n<div class=\"sec_header\">\n样例输入</div>\n<div class=\"sec_text\">\n\t6<br />\n\t1 9 4 8 3 9<br />\n\t9\n</div>\n<div class=\"sec_header\">\n样例输出</div>\n<div class=\"sec_text\">\n\t2\n\t</div>\n<div class=\"sec_header\">\n数据规模与约定</div>\n<div class=\"sec_cont\">\n\t1 &lt;= n &lt;= 1000。\n</div>","gpid":"T9","lanqiaotitle":"查找整数","memorylimit":"256.0MB","tid":"BASIC-5","timelimit":"1.0s","title":"基础练习 查找整数","src":""},{"checkpoint":"循环 最大值 最小值 累加","updatetime":"2013-10-09","content":"<div class=\"sec_header\">问题描述</div>\n<div class=\"sec_cont\">\n<p>给出n个数，找出这n个数的最大值，最小值，和。</p>\n</div>\n<div class=\"sec_header\">输入格式</div>\n<div class=\"sec_cont\">\n<p>第一行为整数n，表示数的个数。</p>\n<p>第二行有n个数，为给定的n个数，每个数的绝对值都小于10000。</p>\n</div>\n<div class=\"sec_header\">输出格式</div>\n<div class=\"sec_cont\">输出三行，每行一个整数。第一行表示这些数中的最大值，第二行表示这些数中的最小值，第三行表示这些数的和。</div>\n<div class=\"sec_header\">样例输入</div>\n<div class=\"sec_text\">5<br />\n1 3 -2 4 5</div>\n<div class=\"sec_header\">样例输出</div>\n<div class=\"sec_text\">5<br />\n-2<br />\n11</div>\n<div class=\"sec_header\">数据规模与约定</div>\n<div class=\"sec_cont\">1 &lt;= n &lt;= 10000。</div>","gpid":"T8","lanqiaotitle":"数列特征","memorylimit":"256.0MB","tid":"BASIC-4","timelimit":"1.0s","title":"基础练习 数列特征","src":""},{"checkpoint":"循环 字符串","updatetime":"2013-10-09","content":"<div class=\"sec_header\">问题描述</div>\n<div class=\"sec_cont\">\n<p>利用字母可以组成一些美丽的图形，下面给出了一个例子：</p>\n<p>ABCDEFG</p>\n<p>BABCDEF</p>\n<p>CBABCDE</p>\n<p>DCBABCD</p>\n<p>EDCBABC</p>\n<p>这是一个5行7列的图形，请找出这个图形的规律，并输出一个n行m列的图形。</p>\n</div>\n<div class=\"sec_header\">输入格式</div>\n<div class=\"sec_cont\">输入一行，包含两个整数n和m，分别表示你要输出的图形的行数的列数。</div>\n<div class=\"sec_header\">输出格式</div>\n<div class=\"sec_cont\">输出n行，每个m个字符，为你的图形。</div>\n<div class=\"sec_header\">样例输入</div>\n<div class=\"sec_text\">5 7</div>\n<div class=\"sec_header\">样例输出</div>\n<div class=\"sec_text\">ABCDEFG<br />\nBABCDEF<br />\nCBABCDE<br />\nDCBABCD<br />\nEDCBABC</div>\n<div class=\"sec_header\">数据规模与约定</div>\n<div class=\"sec_cont\">1 &lt;= n, m &lt;= 26。</div>","gpid":"T7","lanqiaotitle":"字母图形","memorylimit":"256.0MB","tid":"BASIC-3","timelimit":"1.0s","title":"基础练习 字母图形","src":""},{"checkpoint":"循环","updatetime":"2013-10-09","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n\t<p>对于长度为5位的一个01串，每一位都可能是0或1，一共有32种可能。它们的前几个是：</p>\n\t<p>00000</p>\n\t<p>00001</p>\n\t<p>00010</p>\n\t<p>00011</p>\n\t<p>00100</p>\n\t<p>请按从小到大的顺序输出这32种01串。</p>\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\t本试题没有输入。</div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\t输出32行，按从小到大的顺序每行一个长度为5的01串。\n</div>\n<div class=\"sec_header\">\n样例输出</div>\n<div class=\"sec_text\">\n\t00000<br />\n\t00001<br />\n\t00010<br />\n\t00011<br />\n\t&lt;以下部分省略&gt;\n\t</div>","gpid":"T6","lanqiaotitle":"01字串","memorylimit":"256.0MB","tid":"BASIC-2","timelimit":"1.0s","title":"基础练习 01字串","src":""},{"checkpoint":"条件判断","updatetime":"2013-10-09","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n\t<p>给定一个年份，判断这一年是不是闰年。</p>\n\t<p>当以下情况之一满足时，这一年是闰年：</p>\n\t<p>1. 年份是4的倍数而不是100的倍数；</p>\n\t<p>2. 年份是400的倍数。</p>\n\t<p>其他的年份都不是闰年。</p>\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\t输入包含一个整数y，表示当前的年份。</div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\t输出一行，如果给定的年份是闰年，则输出yes，否则输出no。\n\t<div class=\"sec_note\">\n\t<p>说明：当试题指定你输出一个字符串作为结果（比如本题的yes或者no，你需要严格按照试题中给定的大小写，写错大小写将不得分。\n\t</div>\n</div>\n<div class=\"sec_header\">\n样例输入</div>\n<div class=\"sec_text\">\n\t2013</div>\n<div class=\"sec_header\">\n样例输出</div>\n<div class=\"sec_text\">\n\tno</div>\n<div class=\"sec_header\">\n样例输入</div>\n<div class=\"sec_text\">\n\t2016</div>\n<div class=\"sec_header\">\n样例输出</div>\n<div class=\"sec_text\">\n\tyes</div>\n<div class=\"sec_header\">\n数据规模与约定</div>\n<div class=\"sec_cont\">\n\t1990 &lt;= y &lt;= 2050。</div>","gpid":"T5","lanqiaotitle":"闰年判断","memorylimit":"256.0MB","tid":"BASIC-1","timelimit":"1.0s","title":"基础练习 闰年判断","src":""},{"checkpoint":"高精度","updatetime":"2013-11-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输入一个正整数<i>n</i>，输出<i>n</i>!的值。<br />\n　　其中<i>n</i>!=1*2*3*…*<i>n</i>。</div><div class='pdsec'>算法描述</div><div class='pdcont'>　　<i>n</i>!可能很大，而计算机能表示的整数范围有限，需要使用高精度计算的方法。使用一个数组<i>A</i>来表示一个大整数<i>a</i>，<i>A</i>[0]表示<i>a</i>的个位，<i>A</i>[1]表示<i>a</i>的十位，依次类推。<br />\n　　将<i>a</i>乘以一个整数<i>k</i>变为将数组<i>A</i>的每一个元素都乘以<i>k</i>，请注意处理相应的进位。<br />\n　　首先将<i>a</i>设为1，然后乘2，乘3，当乘到<i>n</i>时，即得到了<i>n</i>!的值。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含一个正整数<i>n</i>，<i>n</i>&lt;=1000。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出<i>n</i>!的准确值。</div><div class='pdsec'>样例输入</div><div class='pddata'>10</div><div class='pdsec'>样例输出</div><div class='pddata'>3628800</div>\n","gpid":"T71","lanqiaotitle":"阶乘计算","memorylimit":"512.0MB","tid":"BASIC-30","timelimit":"1.0s","title":"基础练习 阶乘计算","src":""},{"checkpoint":"数组 高精度","updatetime":"2013-11-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输入两个整数<i>a</i>和<i>b</i>，输出这两个整数的和。<i>a</i>和<i>b</i>都不超过100位。</div><div class='pdsec'>算法描述</div><div class='pdcont'>　　由于<i>a</i>和<i>b</i>都比较大，所以不能直接使用语言中的标准数据类型来存储。对于这种问题，一般使用数组来处理。<br />\n　　定义一个数组<i>A</i>，<i>A</i>[0]用于存储<i>a</i>的个位，<i>A</i>[1]用于存储<i>a</i>的十位，依此类推。同样可以用一个数组<i>B</i>来存储<i>b</i>。<br />\n　　计算<i>c</i> = <i>a</i> + <i>b</i>的时候，首先将<i>A</i>[0]与<i>B</i>[0]相加，如果有进位产生，则把进位（即和的十位数）存入<i>r</i>，把和的个位数存入<i>C</i>[0]，即<i>C</i>[0]等于(<i>A</i>[0]+<i>B</i>[0])%10。然后计算<i>A</i>[1]与<i>B</i>[1]相加，这时还应将低位进上来的值<i>r</i>也加起来，即<i>C</i>[1]应该是<i>A</i>[1]、<i>B</i>[1]和<i>r</i>三个数的和．如果又有进位产生，则仍可将新的进位存入到<i>r</i>中，和的个位存到<i>C</i>[1]中。依此类推，即可求出<i>C</i>的所有位。<br />\n　　最后将<i>C</i>输出即可。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包括两行，第一行为一个非负整数<i>a</i>，第二行为一个非负整数<i>b</i>。两个整数都不超过100位，两数的最高位都不是0。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行，表示<i>a </i>+ <i>b</i>的值。</div><div class='pdsec'>样例输入</div><div class='pddata'>20100122201001221234567890<br />\n2010012220100122</div><div class='pdsec'>样例输出</div><div class='pddata'>20100122203011233454668012</div>\n","gpid":"T70","lanqiaotitle":"高精度加法","memorylimit":"512.0MB","tid":"BASIC-29","timelimit":"1.0s","title":"基础练习 高精度加法","src":""},{"checkpoint":"贪心 Huffuman","updatetime":"2013-11-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Huffman树在编码中有着广泛的应用。在这里，我们只关心Huffman树的构造过程。<br />\n　　给出一列数{<i>p<sub>i</sub></i>}={<i>p</i><sub>0</sub>, <i>p</i><sub>1</sub>, …, <i>p<sub>n</sub></i><sub>-1</sub>}，用这列数构造Huffman树的过程如下：<br />\n　　1.      找到{<i>p<sub>i</sub></i>}中最小的两个数，设为<i>p<sub>a</sub></i>和<i>p<sub>b</sub></i>，将<i>p<sub>a</sub></i>和<i>p<sub>b</sub></i>从{<i>p<sub>i</sub></i>}中删除掉，然后将它们的和加入到{<i>p<sub>i</sub></i>}中。这个过程的费用记为<i>p<sub>a</sub></i> + <i>p<sub>b</sub></i>。<br />\n　　2.      重复步骤1，直到{<i>p<sub>i</sub></i>}中只剩下一个数。<br />\n　　在上面的操作过程中，把所有的费用相加，就得到了构造Huffman树的总费用。<br />\n　　本题任务：对于给定的一个数列，现在请你求出用该数列构造Huffman树的总费用。<br />\n<br />\n　　例如，对于数列{<i>p<sub>i</sub></i>}={5, 3, 8, 2, 9}，Huffman树的构造过程如下：<br />\n　　1.      找到{5, 3, 8, 2, 9}中最小的两个数，分别是2和3，从{<i>p<sub>i</sub></i>}中删除它们并将和5加入，得到{5, 8, 9, 5}，费用为5。<br />\n　　2.      找到{5, 8, 9, 5}中最小的两个数，分别是5和5，从{<i>p<sub>i</sub></i>}中删除它们并将和10加入，得到{8, 9, 10}，费用为10。<br />\n　　3.      找到{8, 9, 10}中最小的两个数，分别是8和9，从{<i>p<sub>i</sub></i>}中删除它们并将和17加入，得到{10, 17}，费用为17。<br />\n　　4.      找到{10, 17}中最小的两个数，分别是10和17，从{<i>p<sub>i</sub></i>}中删除它们并将和27加入，得到{27}，费用为27。<br />\n　　5.      现在，数列中只剩下一个数27，构造过程结束，总费用为5+10+17+27=59。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含一个正整数<i>n</i>（<i>n</i>&lt;=100）。<br />\n　　接下来是<i>n</i>个正整数，表示<i>p</i><sub>0</sub>, <i>p</i><sub>1</sub>, …, <i>p<sub>n</sub></i><sub>-1</sub>，每个数不超过1000。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出用这些数构造Huffman树的总费用。</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n5 3 8 2 9</div><div class='pdsec'>样例输出</div><div class='pddata'>59</div>\n","gpid":"T69","lanqiaotitle":"Huffuman树","memorylimit":"512.0MB","tid":"BASIC-28","timelimit":"1.0s","title":"基础练习 Huffuman树","src":""},{"checkpoint":"八皇后问题 搜索","updatetime":"2013-11-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个n*n的棋盘，棋盘中有一些位置不能放皇后。现在要向棋盘中放入n个黑皇后和n个白皇后，使任意的两个黑皇后都不在同一行、同一列或同一条对角线上，任意的两个白皇后都不在同一行、同一列或同一条对角线上。问总共有多少种放法？n小于等于8。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行为一个整数n，表示棋盘的大小。<br />\n　　接下来n行，每行n个0或1的整数，如果一个整数为1，表示对应的位置可以放皇后，如果一个整数为0，表示对应的位置不可以放皇后。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个整数，表示总共有多少种放法。</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\n1 1 1 1<br />\n1 1 1 1<br />\n1 1 1 1<br />\n1 1 1 1</div><div class='pdsec'>样例输出</div><div class='pddata'>2</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\n1 0 1 1<br />\n1 1 1 1<br />\n1 1 1 1<br />\n1 1 1 1</div><div class='pdsec'>样例输出</div><div class='pddata'>0</div>\n","gpid":"T68","lanqiaotitle":"2n皇后问题","memorylimit":"512.0MB","tid":"BASIC-27","timelimit":"1.0s","title":"基础练习 2n皇后问题","src":""},{"checkpoint":"字符串 条件判断","updatetime":"2013-11-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定当前的时间，请用英文的读法将它读出来。<br />\n　　时间用时h和分m表示，在英文的读法中，读一个时间的方法是：<br />\n　　如果m为0，则将时读出来，然后加上“o'clock”，如3:00读作“three o'clock”。<br />\n　　如果m不为0，则将时读出来，然后将分读出来，如5:30读作“five thirty”。<br />\n　　时和分的读法使用的是英文数字的读法，其中0~20读作：<br />\n　　0:zero, 1: one, 2:two, 3:three, 4:four, 5:five, 6:six, 7:seven, 8:eight, 9:nine, 10:ten, 11:eleven, 12:twelve, 13:thirteen, 14:fourteen, 15:fifteen, 16:sixteen, 17:seventeen, 18:eighteen, 19:nineteen, 20:twenty。<br />\n　　30读作thirty，40读作forty，50读作fifty。<br />\n　　对于大于20小于60的数字，首先读整十的数，然后再加上个位数。如31首先读30再加1的读法，读作“thirty one”。<br />\n　　按上面的规则21:54读作“twenty one fifty four”，9:07读作“nine seven”，0:15读作“zero fifteen”。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含两个非负整数h和m，表示时间的时和分。非零的数字前没有前导0。h小于24，m小于60。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出时间时刻的英文。</div><div class='pdsec'>样例输入</div><div class='pddata'>0 15</div><div class='pdsec'>样例输出</div><div class='pddata'>zero fifteen</div>\n","gpid":"T67","lanqiaotitle":"报时助手","memorylimit":"512.0MB","tid":"BASIC-26","timelimit":"1.0s","title":"基础练习 报时助手","src":""},{"checkpoint":"二维数组 循环","updatetime":"2013-11-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　回形取数就是沿矩阵的边取数，若当前方向上无数可取或已经取过，则左转90度。一开始位于矩阵左上角，方向向下。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入第一行是两个不超过200的正整数m, n，表示矩阵的行和列。接下来m行每行n个整数，表示这个矩阵。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出只有一行，共mn个数，为输入矩阵回形取数得到的结果。数之间用一个空格分隔，行末不要有多余的空格。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 3<br />\n1 2 3<br />\n4 5 6<br />\n7 8 9</div><div class='pdsec'>样例输出</div><div class='pddata'>1 4 7 8 9 6 3 2 5</div><div class='pdsec'>样例输入</div><div class='pddata'>3 2<br />\n1 2<br />\n3 4<br />\n5 6</div><div class='pdsec'>样例输出</div><div class='pddata'>1 3 5 6 4 2</div>\n","gpid":"T66","lanqiaotitle":"回形取数","memorylimit":"512.0MB","tid":"BASIC-25","timelimit":"1.0s","title":"基础练习 回形取数","src":""},{"checkpoint":"数组 模拟","updatetime":"2013-11-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　话说这个世界上有各种各样的兔子和乌龟，但是研究发现，所有的兔子和乌龟都有一个共同的特点——喜欢赛跑。于是世界上各个角落都不断在发生着乌龟和兔子的比赛，小华对此很感兴趣，于是决定研究不同兔子和乌龟的赛跑。他发现，兔子虽然跑比乌龟快，但它们有众所周知的毛病——骄傲且懒惰，于是在与乌龟的比赛中，一旦任一秒结束后兔子发现自己领先t米或以上，它们就会停下来休息s秒。对于不同的兔子，t，s的数值是不同的，但是所有的乌龟却是一致——它们不到终点决不停止。<br />\n　　然而有些比赛相当漫长，全程观看会耗费大量时间，而小华发现只要在每场比赛开始后记录下兔子和乌龟的数据——兔子的速度v1（表示每秒兔子能跑v1米），乌龟的速度v2，以及兔子对应的t，s值，以及赛道的长度l——就能预测出比赛的结果。但是小华很懒，不想通过手工计算推测出比赛的结果，于是他找到了你——清华大学计算机系的高才生——请求帮助，请你写一个程序，对于输入的一场比赛的数据v1，v2，t，s，l，预测该场比赛的结果。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入只有一行，包含用空格隔开的五个正整数v1，v2，t，s，l，其中(v1,v2&lt;=100;t&lt;=300;s&lt;=10;l&lt;=10000且为v1,v2的公倍数)</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出包含两行，第一行输出比赛结果——一个大写字母“T”或“R”或“D”，分别表示乌龟获胜，兔子获胜，或者两者同时到达终点。<br />\n　　第二行输出一个正整数，表示获胜者（或者双方同时）到达终点所耗费的时间（秒数）。</div><div class='pdsec'>样例输入</div><div class='pddata'>10 5 5 2 20</div><div class='pdsec'>样例输出</div><div class='pddata'>D<br />\n4</div><div class='pdsec'>样例输入</div><div class='pddata'>10 5 5 1 20</div><div class='pdsec'>样例输出</div><div class='pddata'>R<br />\n3</div><div class='pdsec'>样例输入</div><div class='pddata'>10 5 5 3 20</div><div class='pdsec'>样例输出</div><div class='pddata'>T<br />\n4</div>\n","gpid":"T65","lanqiaotitle":"龟兔赛跑预测","memorylimit":"512.0MB","tid":"BASIC-24","timelimit":"1.0s","title":"基础练习 龟兔赛跑预测","src":""},{"checkpoint":"算法基础 统计 二维数组","updatetime":"2013-11-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有n（2≤n≤20）块芯片，有好有坏，已知好芯片比坏芯片多。<br />\n　　每个芯片都能用来测试其他芯片。用好芯片测试其他芯片时，能正确给出被测试芯片是好还是坏。而用坏芯片测试其他芯片时，会随机给出好或是坏的测试结果（即此结果与被测试芯片实际的好坏无关）。<br />\n　　给出所有芯片的测试结果，问哪些芯片是好芯片。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入数据第一行为一个整数n，表示芯片个数。<br />\n　　第二行到第n+1行为n*n的一张表，每行n个数据。表中的每个数据为0或1，在这n行中的第i行第j列（1≤i, j≤n）的数据表示用第i块芯片测试第j块芯片时得到的测试结果，1表示好，0表示坏，i=j时一律为1（并不表示该芯片对本身的测试结果。芯片不能对本身进行测试）。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　按从小到大的顺序输出所有好芯片的编号</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n1 0 1<br />\n0 1 0<br />\n1 0 1</div><div class='pdsec'>样例输出</div><div class='pddata'>1 3</div>\n","gpid":"T64","lanqiaotitle":"芯片测试","memorylimit":"512.0MB","tid":"BASIC-23","timelimit":"1.0s","title":"基础练习 芯片测试","src":""},{"checkpoint":"字符串 递归","updatetime":"2013-11-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　FJ在沙盘上写了这样一些字符串：<br />\n　　A1 = “A”<br />\n　　A2 = “ABA”<br />\n　　A3 = “ABACABA”<br />\n　　A4 = “ABACABADABACABA”<br />\n　　… …<br />\n　　你能找出其中的规律并写所有的数列AN吗？</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　仅有一个数：N ≤ 26。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　请输出相应的字符串AN，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。</div><div class='pdsec'>样例输入</div><div class='pddata'>3</div><div class='pdsec'>样例输出</div><div class='pddata'>ABACABA</div>\n","gpid":"T63","lanqiaotitle":"FJ的字符串","memorylimit":"512.0MB","tid":"BASIC-22","timelimit":"1.0s","title":"基础练习 FJ的字符串","src":""},{"checkpoint":"字符串 递归 递推","updatetime":"2013-11-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　最近FJ为他的奶牛们开设了数学分析课，FJ知道若要学好这门课，必须有一个好的三角函数基本功。所以他准备和奶牛们做一个“Sine之舞”的游戏，寓教于乐，提高奶牛们的计算能力。<br />\n　　不妨设<br />\n　　An=sin(1–sin(2+sin(3–sin(4+...sin(n))...)<br />\n　　Sn=(...(A1+n)A2+n-1)A3+...+2)An+1<br />\n　　FJ想让奶牛们计算Sn的值，请你帮助FJ打印出Sn的完整表达式，以方便奶牛们做题。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　仅有一个数：N&lt;201。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　请输出相应的表达式Sn，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。</div><div class='pdsec'>样例输入</div><div class='pddata'>3</div><div class='pdsec'>样例输出</div><div class='pddata'>((sin(1)+3)sin(1–sin(2))+2)sin(1–sin(2+sin(3)))+1</div>\n","gpid":"T62","lanqiaotitle":"Sine之舞","memorylimit":"512.0MB","tid":"BASIC-21","timelimit":"1.0s","title":"基础练习 Sine之舞","src":""},{"checkpoint":"判断 函数","updatetime":"2013-11-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Tom教授正在给研究生讲授一门关于基因的课程，有一件事情让他颇为头疼：一条染色体上有成千上万个碱基对，它们从0开始编号，到几百万，几千万，甚至上亿。<br />\n　　比如说，在对学生讲解第1234567009号位置上的碱基时，光看着数字是很难准确的念出来的。<br />\n　　所以，他迫切地需要一个系统，然后当他输入12 3456 7009时，会给出相应的念法：<br />\n　　十二亿三千四百五十六万七千零九<br />\n　　用汉语拼音表示为<br />\n　　shi er yi san qian si bai wu shi liu wan qi qian ling jiu<br />\n　　这样他只需要照着念就可以了。<br />\n　　你的任务是帮他设计这样一个系统：给定一个阿拉伯数字串，你帮他按照中文读写的规范转为汉语拼音字串，相邻的两个音节用一个空格符格开。<br />\n　　注意必须严格按照规范，比如说“10010”读作“yi wan ling yi shi”而不是“yi wan ling shi”，“100000”读作“shi wan”而不是“yi shi wan”，“2000”读作“er qian”而不是“liang qian”。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　有一个数字串，数值大小不超过2,000,000,000。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　是一个由小写英文字母，逗号和空格组成的字符串，表示该数的英文读法。</div><div class='pdsec'>样例输入</div><div class='pddata'>1234567009</div><div class='pdsec'>样例输出</div><div class='pddata'>shi er yi san qian si bai wu shi liu wan qi qian ling jiu</div>\n","gpid":"T61","lanqiaotitle":"数的读法","memorylimit":"512.0MB","tid":"BASIC-20","timelimit":"1.0s","title":"基础练习 数的读法","src":""},{"checkpoint":"贪心算法","updatetime":"2013-11-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。<br />\n　　交换的定义是：交换两个相邻的字符<br />\n　　例如mamad<br />\n　　第一次交换 ad : mamda<br />\n　　第二次交换 md : madma<br />\n　　第三次交换 ma : madam (回文！完美！)</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行是一个整数N，表示接下来的字符串的长度(N &lt;= 8000)<br />\n　　第二行是一个字符串，长度为N.只包含小写字母</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　如果可能，输出最少的交换次数。<br />\n　　否则输出Impossible</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\nmamad</div><div class='pdsec'>样例输出</div><div class='pddata'>3</div>\n","gpid":"T60","lanqiaotitle":"完美的代价","memorylimit":"512.0MB","tid":"BASIC-19","timelimit":"1.0s","title":"基础练习 完美的代价","src":""},{"checkpoint":"判断 线段交","updatetime":"2013-11-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　平面上有两个矩形，它们的边平行于直角坐标系的X轴或Y轴。对于每个矩形，我们给出它的一对相对顶点的坐标，请你编程算出两个矩形的交的面积。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入仅包含两行，每行描述一个矩形。<br />\n　　在每行中，给出矩形的一对相对顶点的坐标，每个点的坐标都用两个绝对值不超过10^7的实数表示。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出仅包含一个实数，为交的面积，保留到小数后两位。</div><div class='pdsec'>样例输入</div><div class='pddata'>1 1 3 3<br />\n2 2 4 4</div><div class='pdsec'>样例输出</div><div class='pddata'>1.00</div>\n","gpid":"T59","lanqiaotitle":"矩形面积交","memorylimit":"512.0MB","tid":"BASIC-18","timelimit":"1.0s","title":"基础练习 矩形面积交","src":""},{"checkpoint":"二维数组 循环 矩阵","updatetime":"2013-11-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个N阶矩阵A，输出A的M次幂（M是非负整数）<br />\n　　例如：<br />\n　　A =<br />\n　　1 2<br />\n　　3 4<br />\n　　A的2次幂<br />\n　　7 10<br />\n　　15 22</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行是一个正整数N、M（1&lt;=N&lt;=30, 0&lt;=M&lt;=5），表示矩阵A的阶数和要求的幂数<br />\n　　接下来N行，每行N个绝对值不超过10的非负整数，描述矩阵A的值</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出共N行，每行N个整数，表示A的M次幂所对应的矩阵。相邻的数之间用一个空格隔开</div><div class='pdsec'>样例输入</div><div class='pddata'>2 2<br />\n1 2<br />\n3 4</div><div class='pdsec'>样例输出</div><div class='pddata'>7 10<br />\n15 22</div>\n","gpid":"T58","lanqiaotitle":"矩阵乘法","memorylimit":"512.0MB","tid":"BASIC-17","timelimit":"1.0s","title":"基础练习 矩阵乘法","src":""},{"checkpoint":"质数分解 循环","updatetime":"2013-11-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　求出区间[a,b]中所有整数的质因数分解。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入两个整数a，b。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　每行输出一个数的分解，形如k=a1*a2*a3...(a1&lt;=a2&lt;=a3...，k也是从小到大的)(具体可看样例)</div><div class='pdsec'>样例输入</div><div class='pddata'>3 10</div><div class='pdsec'>样例输出</div><div class='pddata'>3=3<br />\n4=2*2<br />\n5=5<br />\n6=2*3<br />\n7=7<br />\n8=2*2*2<br />\n9=3*3<br />\n10=2*5</div><div class='pdsec'>提示</div><div class='pdcont'>　　先筛出所有素数，然后再分解。</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　2&lt;=a&lt;=b&lt;=10000</div>\n","gpid":"T57","lanqiaotitle":"分解质因数","memorylimit":"512.0MB","tid":"BASIC-16","timelimit":"1.0s","title":"基础练习 分解质因数","src":""},{"checkpoint":"字符串 大小写","updatetime":"2013-11-01","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定两个仅由大写字母或小写字母组成的字符串(长度介于1到10之间)，它们之间的关系是以下4中情况之一：<br />\n　　1：两个字符串长度不等。比如 Beijing 和 Hebei<br />\n　　2：两个字符串不仅长度相等，而且相应位置上的字符完全一致(区分大小写)，比如 Beijing 和 Beijing<br />\n　　3：两个字符串长度相等，相应位置上的字符仅在不区分大小写的前提下才能达到完全一致（也就是说，它并不满足情况2）。比如 beijing 和        BEIjing<br />\n　　4：两个字符串长度相等，但是即使是不区分大小写也不能使这两个字符串一致。比如 Beijing 和 Nanjing<br />\n　　编程判断输入的两个字符串之间的关系属于这四类中的哪一类，给出所属的类的编号。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　包括两行，每行都是一个字符串</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　仅有一个数字，表明这两个字符串的关系编号</div><div class='pdsec'>样例输入</div><div class='pddata'>BEIjing<pre class='pddata'>\n<font face=\"Times New Roman\" size=\"3\">beiJing </font>\n</pre>\n</div><div class='pdsec'>样例输出</div><div class='pddata'>3</div>\n","gpid":"T56","lanqiaotitle":"字符串对比","memorylimit":"512.0MB","tid":"BASIC-15","timelimit":"1.0s","title":"基础练习 字符串对比","src":""},{"checkpoint":"取余 数字字符混合输出","updatetime":"2013-11-01","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个以秒为单位的时间t，要求用“&lt;H&gt;:&lt;M&gt;:&lt;S&gt;”的格式来表示这个时间。&lt;H&gt;表示时间，&lt;M&gt;表示分钟，而&lt;S&gt;表示秒，它们都是整数且没有前导的“0”。例如，若t=0，则应输出是“0:0:0”；若t=3661，则输出“1:1:1”。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入只有一行，是一个整数t（0&lt;=t&lt;=86399）。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出只有一行，是以“&lt;H&gt;:&lt;M&gt;:&lt;S&gt;”的格式所表示的时间，不包括引号。</div><div class='pdsec'>样例输入</div><div class='pddata'>0</div><div class='pdsec'>样例输出</div><div class='pddata'>0:0:0</div><div class='pdsec'>样例输入</div><div class='pddata'>5436</div><div class='pdsec'>样例输出</div><div class='pddata'>1:30:36</div>\n","gpid":"T54","lanqiaotitle":"时间转换","memorylimit":"512.0MB","tid":"BASIC-14","timelimit":"1.0s","title":"基础练习 时间转换","src":""}]},{"name":"算法训练","prefix":"ALGO-","problems":[{"checkpoint":"","updatetime":"2020-03-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　一个有向图，求1到N的最大流</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行N M，表示点数与边数<br />\n　　接下来M行每行s t c表示一条从s到t的容量为c的边</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个数最大流量</div><div class='pdsec'>样例输入</div><div class='pddata'>6 10<br />\n1 2 4<br />\n1 3 8<br />\n2 3 4<br />\n2 4 4<br />\n2 5 1<br />\n3 4 2<br />\n3 5 2<br />\n4 6 7<br />\n5 4 6<br />\n5 6 3</div><div class='pdsec'>样例输出</div><div class='pddata'>8<br />\n<br />\n数据约定：<br />\nn&lt;=1000 m&lt;=10000</div>\n","gpid":"T633","lanqiaotitle":"网络流裸题","memorylimit":"256.0MB","tid":"ALGO-247","timelimit":"1.0s","title":"算法训练 网络流裸题","src":""},{"checkpoint":"猴子","updatetime":"2020-03-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　从前，有一只吃包子很厉害的猴子，它可以吃无数个包子，但是，它吃不同的包子速度也不同；肉包每秒钟吃x个；韭菜包每秒钟吃y个；没有馅的包子每秒钟吃z个；现在有x1个肉包，y1个韭菜包，z1个没有馅的包子；问：猴子吃完这些包子要多久？结果保留p位小数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入1行，包含7个整数，分别表示吃不同包子的速度和不同包子的个数和保留的位数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行，包含1个实数，表示吃完所有包子的时间。</div><div class='pdsec'>样例输入</div><div class='pddata'>4 3 2 20 30 15 2</div><div class='pdsec'>样例输出</div><div class='pddata'>22.50</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　0&lt;x&lt;100;0&lt;y&lt;100;0&lt;z&lt;100;0&lt;x1&lt;=1000000;0&lt;y1&lt;=10000000;0&lt;z1&lt;=10000000;0&lt;p&lt;=1000</div>\n","gpid":"T632","lanqiaotitle":"猴子吃包子","memorylimit":"256.0MB","tid":"ALGO-246","timelimit":"1.0s","title":"算法训练 猴子吃包子","src":""},{"checkpoint":"构造","updatetime":"2020-03-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　（这道题的数据和SPJ已完工，尽情来虐吧！）<br />\n<br />\n　　Yaroslav喜欢算法。我们将描述一个他最喜欢的算法。<br />\n<br />\n　　1.这个算法接受一个字符串作为输入。我们设这个输入字符串为a。<br />\n　　2.这个算法由一些命令组成。i号命令的形式为\"s[i]&gt;&gt;w[i]\"或\"s[i]&lt;&gt;w[i]\"，其中s[i]和w[i]是长度不超过7的字符串（可以为空），由数字或字符\"?\"组成。<br />\n　　3.这个算法每次寻找一个编号最小的命令i，使得s[i]是a的子串。如果没有找到这样的命令，那么整个算法终止。<br />\n　　4.设找到的命令编号为k。在字符串a中，s[k]第一次出现的位置会被w[k]替换。如果这个命令形如\"s[k]&gt;&gt;w[k]\"，那么这个算法继续执行（译注：回到第3步）。否则，算法终止。<br />\n　　5.算法的输出就是算法终止时字符串a的值。<br />\n<br />\n　　Yaroslav有一个n个正整数的集合，他需要一个这样的算法，且能够使每一个数加1。更正式地，如果我们把每个数看成一个十进制表示的字符串，那么对于每个字符串独立地运行这个算法，这个算法需要输出一个输入串对应的数+1的字符串。<br />\n　　帮帮他吧！</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含一个整数n（集合中数的个数），接下来n行，每行包含一个正整数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个符合题意的算法（能够分别将每个数增加1）。第i行输出这个算法的第i个命令，不包含空格。<br />\n　　你的算法将会对于每个输入运行一遍。你的输出会被认为是正确的，当且仅当：<br />\n　　·每行都是一个合法的命令（格式见题目描述）<br />\n　　·命令的条数不能超过50。<br />\n　　·算法需要对每个给出的数+1。<br />\n　　·为了得到结果，算法必须对于每个输入都执行不超过200步。</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n10<br />\n79</div><div class='pdsec'>样例输出</div><div class='pddata'>10&lt;&gt;11<br />\n79&lt;&gt;80</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1≤每个数≤10^25。共有20个测试点，对于第i个测试点，n=5i。</div>\n","gpid":"T631","lanqiaotitle":"Yaroslav and Algorithm","memorylimit":"128.0MB","tid":"ALGO-245","timelimit":"100ms","title":"算法训练 Yaroslav and Algorithm","src":"CODEFORCES 301C"},{"checkpoint":"动态规划","updatetime":"2020-03-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Sereja在平面上画了n个点，点i在坐标(i,0)。然后，Sereja给每个点标上了一个小写或大写英文字母。Sereja不喜欢字母\"x\"，所以他不用它标记点。Sereja认为这些点是漂亮的，当且仅当：<br />\n　　·所有的点可以被分成若干对，使得每个点恰好属于一一对之中。<br />\n　　·在每对点中，横坐标较小的会被标上小写字母，较大的会被标上对应的大写字母。<br />\n　　·如果我们在每对点上画一个正方形，其中已知的一对点会作为正方形的相对的顶点，它们间的线段会成为正方形的对角线，那么在所有画出的正方形中不会有相交或触碰的情况。<br />\n　　小Petya擦掉了一些小写字母和所有大写字母，现在Sereja想知道有多少种方法来还原每个点上的字母，使得还原后这些点是漂亮的。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行是一个整数n，表示点的个数。<br />\n　　第二行是一个长度为n的字符串，包含小写字母和问号\"?\"，是按照横坐标递增的顺序的每个点的描述。问号表示这个点的字母被Petya擦掉了。保证输入串不含字母\"x\"。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出答案对4294967296取模的值。如果没有可行的方案，输出0。</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\na???</div><div class='pdsec'>样例输出</div><div class='pddata'>50</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\nabc?</div><div class='pdsec'>样例输出</div><div class='pddata'>0</div><div class='pdsec'>样例输入</div><div class='pddata'>6<br />\nabc???</div><div class='pdsec'>样例输出</div><div class='pddata'>1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　20个测试点的n分别为：<br />\n　　5,10,20,50,100,<br />\n　　200,500,1000,2000,5000,<br />\n　　10000,20000,30000,40000,50000,<br />\n　　60000,70000,80000,90000,100000.</div>\n","gpid":"T630","lanqiaotitle":"Sereja and Squares","memorylimit":"256.0MB","tid":"ALGO-244","timelimit":"4.0s","title":"算法训练 Sereja and Squares","src":"CODEFORCES 314E"},{"checkpoint":"数学","updatetime":"2020-03-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Bike是个十分喜欢数学的聪明孩子。他发明了“可旋转数”，其灵感来自于142857。<br />\n　　正如你所见，142857是一个十分神奇的数，因为所有从它通过旋转得到的数都是它自己乘以1,2,3...,6（从1到数的长度）。旋转一个数就是将它的最后一位数字放到最前面。比如说，通过旋转12345你能够得到这些数：12345,51234,45123,34512,23451。值得一提的是这里允许有前导0。因而4500123和0123450都能够通过旋转0012345得到。你可以看看142857满足条件的原因了。下面的6个方程都在十进制下成立：<br />\n　　142857 * 1 = 142857;<br />\n　　142857 * 2 = 285714;<br />\n　　142857 * 3 = 428571;<br />\n　　142857 * 4 = 571428;<br />\n　　142857 * 5 = 714285;<br />\n　　142857 * 6 = 857142<br />\n　　现在，Bike提出了一个问题。他将“可旋转数”推广到了任意进制b。如上所示，142857是十进制下的一个“可旋转数”。另外一个例子是二进制下的0011。下面的4个方程都在二进制下成立：<br />\n　　0011 * 1 = 0011;<br />\n　　0011 * 10 = 0110;<br />\n　　0011 * 11 = 1001;<br />\n　　0011 * 100 = 1100<br />\n　　他想要找到最大的b(1 &lt; b &lt; x)，满足在b进制下存在一个长度为n的正“可旋转数”（允许有前导零）。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　仅一行包含两个用空格分隔的整数n,x。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行一个整数，表示你找到的最大的b。如果不存在满足条件的b，输出-1。</div><div class='pdsec'>样例输入I</div><div class='pdcont'>　　6 11</div><div class='pdsec'>样例输出I</div><div class='pdcont'>　　10</div><div class='pdsec'>样例输入II</div><div class='pdcont'>　　5 8</div><div class='pdsec'>样例输出II</div><div class='pdcont'>　　-1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于20%的数据，n &lt;= 10, x &lt;= 15<br />\n　　对于50%的数据，x &lt;= 10<br />\n　　对于100%的数据，1 &lt;= n &lt;= 5 * 10^6，2 &lt;= x &lt;= 10^9</div>\n","gpid":"T629","lanqiaotitle":"Rotatable Number","memorylimit":"256.0MB","tid":"ALGO-243","timelimit":"1.0s","title":"算法训练 Rotatable Number","src":"Codeforces303D"},{"checkpoint":"","updatetime":"2020-03-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　两个小哥正在玩一个游戏。<br />\n　　两个小哥轮流行动，不能操作的人输。<br />\n　　游戏开始前裁判买老师会在方格纸上写下一个字符串，每个格子包含一个字母。<br />\n　　比如字符串\"abacaba\"长这样：<br />\n<img src=\"/RequireFile.do?fid=fy7ayh4D\" width=\"279\" height=\"31\" /><br />\n　　一个小哥的操作分这么几步：<br />\n　　1.这个小哥选择一张纸，我们称上面写着的字符串为t。注意一开始时只有一张可选纸。<br />\n　　2.这个小哥选择一个i(1&lt;=i&lt;=|t|)使得存在一个正整数k(0&lt;i-k,i+k&lt;=|t|)满足t[i-1]=t[i+1] and t[i-2]=t[i+2] ... t[i-k]=t[i+k]<br />\n　　3.这个小哥以把这张纸的第i个字母的两侧撕开使得这张纸分成3份:t[1~i-1],t[i~i],t[i+1,|t|]如下图：<br />\n<br />\n<img src=\"/RequireFile.do?fid=nB4RBmMh\" width=\"317\" height=\"150\" /><br />\n　　假如两个小哥都身经百战，使用最优策略，你需要确定胜者是谁。假如先行动的人胜，那么你还需要输出可以帮助这个小哥获胜的第一步行动选择的位置。如果有多个输出最小的那个。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　仅一行包含买老师选择的字符串s。只包含小写字母。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　假如后手获胜输出\"Second\"，否则第一行输出\"First\"，第二行输出最小的可行策略。</div><div class='pdsec'>样例输入</div><div class='pddata'>abacaba</div><div class='pdsec'>样例输出</div><div class='pddata'>First<br />\n2</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于25%的数据1&lt;=|s|&lt;=10<br />\n　　对于50%的数据1&lt;=|s|&lt;=100<br />\n　　对于75%的数据1&lt;=|s|&lt;=1000<br />\n　　对于100%的数据1&lt;=|s|&lt;=5000</div>\n","gpid":"T628","lanqiaotitle":"Playing with String","memorylimit":"256.0MB","tid":"ALGO-242","timelimit":"1.0s","title":"算法训练 Playing with String","src":"Codeforces #305 E"},{"checkpoint":"数论 dp","updatetime":"2020-03-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　定义d(n)为n的约数个数。现在，你有三个数a,b,c。你的任务是计算下面式子modulo 1073741824 (2^30)的值。<img src=\"/RequireFile.do?fid=D7fdgLL8\" width=\"218\" height=\"27\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　三个正整数a,b,c。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个数，即上面式子modulo 1073741824 (2^30)的值。</div><div class='pdsec'>样例输入</div><div class='pddata'>2 2 2</div><div class='pdsec'>样例输出</div><div class='pddata'>20</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　<i>a</i>, <i>b</i> , <i>c</i> (1&thinsp;≤&thinsp;<i>a</i>,&thinsp;<i>b</i>,&thinsp;<i>c</i>&thinsp;≤&thinsp;2000)</div>\n","gpid":"T626","lanqiaotitle":"Number Challenge","memorylimit":"512.0MB","tid":"ALGO-241","timelimit":"3.0s","title":"算法训练 Number Challenge","src":"Codeforcces #235 E "},{"checkpoint":"字符串函数","updatetime":"2020-02-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输入两个字符串，将其合并为一个字符串后输出。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入两个字符串</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出合并后的字符串</div><div class='pdsec'>样例输入</div><div class='pddata'>一个满足题目要求的输入范例。<br />\nHello<br />\n<br />\nWorld</div><div class='pdsec'>样例输出</div><div class='pddata'>HelloWorld</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入的字符串长度0&lt;n&lt;100</div>\n","gpid":"T590","lanqiaotitle":"字符串合并","memorylimit":"256.0MB","tid":"ALGO-233","timelimit":"1.0s","title":"算法训练 字符串合并","src":""},{"checkpoint":"RP","updatetime":"2020-02-14","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　请尽情使用各种各样的函数来测试你的RP吧~~~</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一个数N表示测点编号。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个0~9的数。</div><div class='pdsec'>样例输入</div><div class='pddata'>0</div><div class='pdsec'>样例输出</div><div class='pddata'>X<br />\n{当且仅当输出仅有一个数X且X为0~9的数时你的得分不为零，此时你的得分为系统根据你的输出而计算出的你本次的RP。}</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　测点编号为1~10，且stdans随机。<br />\n　　究竟使用怎样的函数才能获得较高的RP呢？指数函数？幂函数？斐波那契数？圆周曲线的导数函数？好想尝试一下哦~</div>\n","gpid":"T584","lanqiaotitle":"RP大冒险","memorylimit":"64.0MB","tid":"ALGO-230","timelimit":"200ms","title":"算法训练 RP大冒险","src":"原创"},{"checkpoint":"","updatetime":"2020-02-14","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　本题为Queries on Young Machine的样例测试题。除数据外所有说明同原题。</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'><img src=\"/RequireFile.do?fid=Fr7Je3FR\" width=\"855\" height=\"222\" /></div>\n","gpid":"T583","lanqiaotitle":"Queries on Young Machine - Sample","memorylimit":"256.0MB","tid":"ALGO-229","timelimit":"1.0s","title":"算法训练 Queries on Young Machine - Sample","src":""},{"checkpoint":"搜索","updatetime":"2020-01-15","content":"<div class='pdcont'>　　Sticks<br />\n<table cellspacing=0 cellpadding=2px style='border-collapse:collapse;' class='table table-striped table-horver'><tbody><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'><b>Time Limit:</b> 1000MS</td><td style='border:solid 1.0pt'> </td><td style='border:solid 1.0pt'><b>Memory Limit:</b> 10000K</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'><b>Total Submissions:</b> 113547</td><td style='border:solid 1.0pt'> </td><td style='border:solid 1.0pt'><b>Accepted:</b> 26078</td></tr></tbody></table></div><div class='pdsec'>问题描述</div><div class='pdcont'>　　George took sticks of the same length and cut them randomly until all parts became at most 50 units long. Now he wants to return sticks to the original state, but he forgot how many sticks he had originally and how long they were originally. Please help him and design a program which computes the smallest possible original length of those sticks. All lengths expressed in units are integers greater than zero.</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　The input contains blocks of 2 lines. The first line contains the number of sticks parts after cutting, there are at most 64 sticks. The second line contains the lengths of those parts separated by the space. The last line of the file contains zero.</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　The output should contains the smallest possible length of original sticks, one per line.</div><div class='pdsec'>样例输入</div><div class='pddata'>9<br />\n5 2 1 5 2 1 5 2 1<br />\n4<br />\n1 2 3 4<br />\n0</div><div class='pdsec'>样例输出</div><div class='pddata'>5<br />\n6</div>\n","gpid":"T572","lanqiaotitle":"Sticks","memorylimit":"999.4MB","tid":"ALGO-224","timelimit":"1.0s","title":"算法训练 Sticks","src":""},{"checkpoint":"swap","updatetime":"2020-01-08","content":"<div class='pdcont'><b>问题描述</b><br />\n　　编写一个程序，输入两个整数，分别存放在变量x和y当中，然后使用自己定义的函数swap来交换这两个变量的值。<br />\n　　输入格式：输入只有一行，包括两个整数。<br />\n　　输出格式：输出只有一行，也是两个整数，即交换以后的结果。<br />\n　　要求：主函数负责数据的输入与输出，但不能直接交换这两个变量的值，必须通过调用单独定义的函数swap来完成，而swap函数只负责交换变量的值，不能输出交换后的结果。<br />\n<b>输入输出样例</b></div><div class='pdsec'>样例输入</div><div class='pddata'>4  7</div><div class='pdsec'>样例输出</div><div class='pddata'>7  4</div>\n","gpid":"T566","lanqiaotitle":"数据交换","memorylimit":"256.0MB","tid":"ALGO-221","timelimit":"1.0s","title":"算法训练 数据交换","src":"谌卫军程序设计基础课程"},{"checkpoint":"指针","updatetime":"2020-01-08","content":"<div class='pdcont'><b>问题描述</b><br />\n　　你的表妹正在学习整数的加法，请编写一个程序来帮助她学习。该程序调用了一个函数GetTwoInts，由它来返回两个从键盘读入的100以内的整数，然后计算这两个整数之和，并把答案显示出来。要求：在主函数中不能使用scanf等函数直接输入这两个整数，而必须通过调用GetTwoInts函数来完成，在GetTwoInts函数中可以使用scanf函数。另外，由于该函数必须同时返回两个整数，因此不能采用函数返回值的方式，而必须采用指针的方法来实现。<br />\n　　输入格式：输入只有一行，即两个100以内的整数。<br />\n　　输出格式：输出只有一行，即这两个整数之和。<br />\n<b>输入输出样例</b></div><div class='pdsec'>样例输入</div><div class='pddata'>4  7</div><div class='pdsec'>样例输出</div><div class='pddata'>11</div>\n","gpid":"T565","lanqiaotitle":"加法运算","memorylimit":"256.0MB","tid":"ALGO-220","timelimit":"1.0s","title":"算法训练 加法运算","src":"谌卫军程序设计基础课程"},{"checkpoint":"排序","updatetime":"2019-12-31","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　小明来到一个景区游玩，但是他的时间有限，没办法逛遍所有的景点，所以他从网上下载了每个景点的评分，他希望能够使游览的景点的评分总和最高，于是他希望你帮他对于N个景点排下序。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含一个正整数N，表示N个景点。<br />\n　　第二行有N个正整数，表示每个景点的评分值。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行，包含N个正整数，表示N个景点的评分从大到小的排列</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\n3 2 4 1</div><div class='pdsec'>样例输出</div><div class='pddata'>4 3 2 1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　N&lt;=1000,每个景点的评分&lt;=10000。</div>\n","gpid":"T560","lanqiaotitle":"景点游览","memorylimit":"256.0MB","tid":"ALGO-217","timelimit":"1.0s","title":"算法训练 景点游览","src":""},{"checkpoint":"枚举","updatetime":"2019-12-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　一个逻辑电路将其输入通过不同的门映射到输出，在电路中没有回路。输入和输出是一个逻辑值的有序集合，逻辑值被表示为1和0。我们所考虑的电路由与门（and gate，只有在两个输入都是1的时候，输出才为1）、或门（or gate，只要两个输入中有一个是1，输出就是1）、异或门（exclusive or（xor）gate，在两个输入中仅有一个是1，输出才是1）和非门（not gate，单值输入，输出是输入的补）组成。下图给出两个电路。<br />\n<img src=\"/RequireFile.do?fid=LmrJA5Yt\" width=\"560\" height=\"181\" /><br />\n　　不幸的是，在实际中，门有时会出故障。虽然故障会以多种不同的方式发生，但本题将门会出现的故障限于如下三种形式之一：<br />\n　　1）总是与正确的输出相反；<br />\n　　2）总是产生0；<br />\n　　3）总是产生1；<br />\n　　在本题给出的电路中，最多只有一个门出故障。<br />\n　　请编写一个程序，对一个电路进行分析，对多组输入和输出进行实验，看电路运行是正确的还是不正确的。如果至少有一组输入产生了错误的输出，程序要确定唯一的出故障的门，以及这个门出故障的方式。但这也可能是无法判断的。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入由多组测试数据组成，每组测试用例描述了一个电路及其输入和输出。每个测试数据按序给出下述部分。<br />\n　　1.  一行给出3个正整数：在电路中输入的数量（N ≤ 8），门的数量（G ≤ 19）和输出的数量（U ≤ 19）。<br />\n　　2.  每行一个门，第一行描述g<sub>1</sub>门，如果有若干个门，则下一行描述g<sub>2</sub>门，以此类推。每行给出门类型（a = and，n = not，o = or，x = exclusive or）和对这个门的所有输入的标识符，对这个门的输入来自电路输入（i<sub>1</sub>, i<sub>2</sub>, …）或来自另一个门的输出（g<sub>1</sub>, g<sub>2</sub>, …）。<br />\n　　3.  一行给出与U个输出u<sub>1</sub>, u<sub>2</sub>, ….所关联的门的编号。例如，如果有三个输出，u<sub>1</sub>来自g<sub>5</sub>，u<sub>2</sub>来自g<sub>1</sub>，u<sub>3</sub>来自g<sub>4</sub>，那么这一行为：5 1 4。<br />\n　　4.  一行给出一个整数，表示对电路的进行实验的次数（B）。<br />\n　　5.  最后给出B行，每行(N+U)个值（1和0），给出实验的输入值和相应的输出值。不存在有两个相同输入的情况。<br />\n　　输入中的标识符或数字以空格分开，输入以包含3个0的一行结束。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于输入数据中的每个电路，输出测试数据的编号（从1开始），然后输出一个冒号和一个空格，再输出电路分析，内容为如下之一（用#代替相应的门的编号）：<br />\n<br />\n　　No faults detected<br />\n　　Gate # is failing; output inverted<br />\n　　Gate # is failing; output stuck at 0<br />\n　　Gate # is failing; output stuck at 1<br />\n　　Unable to totally classify the failure<br />\n　　在图1和图2 中给出的电路图是第一个和最后一个测试数据。</div><div class='pdsec'>样例输入</div><div class='pddata'>2 2 1<br />\no i1 i2<br />\nn g1<br />\n2<br />\n2<br />\n1 0 0<br />\n0 0 1<br />\n2 1 1<br />\na i1 i2<br />\n1<br />\n1<br />\n1 0 1<br />\n2 1 1<br />\na i1 i2<br />\n1<br />\n2<br />\n1 0 1<br />\n1 1 1<br />\n1 1 1<br />\nn i1<br />\n1<br />\n2<br />\n1 1<br />\n0 0<br />\n3 4 4<br />\nn g4<br />\na i1 i2<br />\no i2 i3<br />\nx i3 i1<br />\n2 3 4 1<br />\n4<br />\n0 1 0 0 1 0 1<br />\n0 1 1 0 1 1 0<br />\n1 1 1 0 1 0 1<br />\n0 0 0 0 0 0 1<br />\n0 0 0</div><div class='pdsec'>样例输出</div><div class='pddata'>Case 1: No faults detected<br />\nCase 2: Unable to totally classify the failure<br />\nCase 3: Gate 1 is failing; output stuck at 1<br />\nCase 4: Gate 1 is failing; output inverted<br />\nCase 5: Gate 2 is failing; output stuck at 0</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　N&lt;=8;G,U&lt;=19</div>\n","gpid":"T554","lanqiaotitle":"My Bad","memorylimit":"256.0MB","tid":"ALGO-214","timelimit":"1.0s","title":"算法训练 My Bad","src":"ACM/ICPC World Finals 2009 B"},{"checkpoint":"DP ","updatetime":"2019-12-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　数据压缩的目的是为了减少存储和交换数据时出现的冗余。这增加了有效数据的比重并提高了传输速率。有一种压缩二进制串的方法是这样的：<br />\n　　将连续的n个1替换为n的二进制表示（注：替换发生当且仅当这种替换减少了二进制串的总长度）<br />\n　　（译者注：连续的n个1的左右必须是0或者是串的开头、结尾）<br />\n　　比如：11111111001001111111111111110011会被压缩成10000010011110011。原串长为32,被压缩后串长为17.<br />\n　　这种方法的弊端在于，有时候解压缩算法会得到不止一个可能的原串，使得我们无法确定原串究竟是什么。请你写一个程序来判定我们能否利用压缩后的信息来确定原串。给出原串长L，原串中1的个数N，以及压缩后的串。<br />\n　　L&lt;=16 Kbytes，压缩后的串长度&lt;=40 bits。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行两个整数L,N，含义同问题描述<br />\n　　第二行一个二进制串，表示压缩后的串</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出\"YES\"或\"NO\"或\"NOT UNIQUE\"（不包含引号）<br />\n　　分别表示：<br />\n　　YES：原串唯一<br />\n　　NO：原串不存在<br />\n　　NOT UNIQUE：原串存在但不唯一</div><div class='pdsec'>样例输入</div><div class='pddata'>样例1：<br />\n32 26<br />\n10000010011110011<br />\n样例2：<br />\n9 7<br />\n1010101<br />\n样例3：<br />\n14 14<br />\n111111</div><div class='pdsec'>样例输出</div><div class='pddata'>样例1：YES<br />\n样例2：NOT UNIQUE<br />\n样例3：NO</div>\n","gpid":"T553","lanqiaotitle":"Bit Compressor","memorylimit":"256.0MB","tid":"ALGO-213","timelimit":"1.0s","title":"算法训练 Bit Compressor","src":"ACM/ICPC World Finals 2006 E"},{"checkpoint":"费用流","updatetime":"2019-12-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Hugh Samston经营着一个为今年的ICPC世界总决赛的参与者提供甜点的餐饮服务。他将会提供上面有冰激凌的饼片。为了满足不同的需求，他准备了许多不同的饼片和冰激凌。<br />\n　　Hugh希望以一份饼片上一份冰激凌的方式来提供甜点。然而，作为一个商人，他希望能赚到尽可能多的钱。他知道不同种类的饼片和冰激凌组合的价格，也知道那些冰激凌和那些饼片不能组合在一起。<br />\n　　Hugh想根据每种饼片和冰激凌的数量，以及之前提到的不同组合的情况，确定他能获得的利润的范围。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　测试数据的输入一定会满足的格式。<br />\n　　输入的第一行包含两个整数P, I，分别表示饼片和冰激凌的种类数。<br />\n　　接下来一行包含P个整数，表示每种类型饼片的数量。<br />\n　　接下来一行包含I个整数，表示每种类型冰激凌的数量。<br />\n　　接下来P行，每行包含I个实数，表示每种类型饼片和冰激凌组合的结果。<br />\n　　如果这种饼片和这种冰激凌可以组合，则为一个(0,10)的实数，表示这种组合的收益。<br />\n　　否则，则为-1,表示这两种之间不能组合。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行，以\"(最小收益) to (最大收益)\"的方式输出利润的范围。<br />\n<br />\n　　请注意：所有的饼片和冰激凌都必须用完。</div><div class='pdsec'>样例输入</div><div class='pddata'>2 3<br />\n40 50<br />\n27 30 33<br />\n1.11 1.27 0.70<br />\n-1 2 0.34</div><div class='pdsec'>样例输出</div><div class='pddata'>91.70 to 105.87</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　0 &lt; P,I &lt;= 50，每种类型饼片或冰激凌数量不超过100。</div>\n","gpid":"T548","lanqiaotitle":"Remember the A La Mode","memorylimit":"256.0MB","tid":"ALGO-210","timelimit":"1.0s","title":"算法训练 Remember the A La Mode","src":"ACM/ICPC World Finals 2006 B"},{"checkpoint":"搜索剪枝","updatetime":"2019-12-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Preston Digitation是一个对纸牌魔术很专业的魔术师。完美洗牌这件事情Preston不能做得恰到好处。<br />\n　　完美洗牌是将52张牌分成两半然后完美的交叉起来，所以牌的下半部分最上面的牌将被放在洗牌后的牌顶。<br />\n　　如果我们把这些牌标为0(牌顶)-51(牌底)，那么一次完美洗牌后的结果会像这样：<br />\n　　26 0 27 1 28 2 29 3 30 4 31 5 32 6...51 25<br />\n　　Preston发现每次洗牌他最多犯一次错误。例如，2号牌跟28号牌会互换，结果像这样：<br />\n　　26 0 27 1 2 28 29 3 30 4 31 5 32 6...51 25<br />\n　　这些对两个相邻卡牌的交换是Preston犯的唯一一个错误。一次洗牌后，他会很容易发现他在哪里和为什么犯这个错误，但是在几次洗牌后这会变得越来越困难。<br />\n　　他希望你写一个程序来确定他的错误。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含多组数据。<br />\n　　第一行一个整数表示数据组数。<br />\n　　对于每组数据将有一行52个整数表示经过1到10次洗牌后的牌组。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组数据，输出这组数据序号。<br />\n　　接着是洗牌的次数。<br />\n　　如果没有错误<br />\n　　输出\"No error in any shuffle\"<br />\n　　否则，对于每次错误<br />\n　　输出\"Error in shuffle N at location M\"<br />\n　　N表示犯错误的洗牌次数，M表示交换的两张牌的位置。洗牌次数从1开始计算，而位置值取第一张牌所在位置(牌顶为0)，在上面的例子中，卡牌位置为4和5(编号为2和28)是错误的，所以在这例中我们用4。错误按洗牌次数N递增输出，如果某次洗牌没有错误则不输出它。如果有多种方案，选择错误数最小的方案输出(数据保证有一个最小错误方案)。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n26 0 27 1 2 28 29 3 30 4 31 5 32 6 33 7 34<br />\n8 35 9 36 10 37 11 38 12 39 13 40 14 41 15<br />\n42 16 43 17 44 18 45 19 46 20 47 21 48 22<br />\n49 23 50 24 51 25<br />\n26 0 27 1 28 2 29 3 30 4 31 5 32 6 33 7 34<br />\n8 35 9 36 10 37 11 38 12 39 13 40 14 41 15<br />\n42 16 43 17 44 18 45 19 46 20 47 21 48 22<br />\n49 23 50 24 51 25<br />\n49 26 43 40 37 34 31 28 25 22 19 16 13 10<br />\n7 4 1 51 48 45 42 39 36 33 24 27 30 21 18<br />\n15 12 9 6 3 0 50 47 44 41 38 35 32 29 46<br />\n23 20 17 2 11 8 5 14</div><div class='pdsec'>样例输出</div><div class='pddata'>Case 1<br />\nNumber of shuffles = 1<br />\nError in shuffle 1 at location 4<br />\nCase 2<br />\nNumber of shuffles = 1<br />\nNo error in any shuffle<br />\nCase 3<br />\nNumber of shuffles = 9<br />\nError in shuffle 3 at location 3<br />\nError in shuffle 7 at location 11<br />\nError in shuffle 8 at location 38</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　见题目描述</div>\n","gpid":"T547","lanqiaotitle":"cNteSahruPfefrlefe","memorylimit":"256.0MB","tid":"ALGO-209","timelimit":"1.0s","title":"算法训练 cNteSahruPfefrlefe","src":"ACM/ICPC World Finals 2005 D"},{"checkpoint":"费用流","updatetime":"2019-12-10","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　一位著名的微处理器公司邀请您帮忙在他们的电脑芯片上安排一些组件，每个芯片被设计成拥有N × N个插槽的正方形。一个插槽可以存放一个组件，你要尽可能多地在芯片上安装组件。<br />\n　　现代的处理器设计是相当复杂的。不幸地，你需要满足以下的限制。<br />\n　　* 一些插槽是不可用的<br />\n　　* 一些插槽已经被其他的组件所占据，无法用于固定额外的组件。<br />\n　　* 芯片水平和垂直边界上连接着着一些内存总线,他们的带宽负载需要匹配。也就是说，第一行和第一列的组件数目必须一样多，第二行和第二列的组件数目必须一样多，依此类推。这里的组件数要包括之前已经存在于芯片之上和后来加上去的。<br />\n　　* 类似地，每行每列都有能量供应系统。为了避免局部过热，对于给定的一组A，B，任何一行/一列的组件数都不能超过总组件数的A / B。<br />\n　　你希望计算出最多可以在芯片上再安装多少个组件。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入数据第一行包括三个正整数N，A，B。<br />\n　　接下来包含 N 行,每行包含 N 个字符，表示了描述芯片的矩阵。其中 '.' 表示可用插槽，'/' 表示不可用插槽，'C' 表示插槽已被一个部件占据。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　如果有解，输出一行包括一个正整数，表示最多能再安装多少个组件。<br />\n　　否则，输出\"impossible\"（不包含引号）。</div><div class='pdsec'>样例输入</div><div class='pddata'>5 3 10<br />\nCC/..<br />\n././/<br />\n..C.C<br />\n/.C..<br />\n/./C/</div><div class='pdsec'>样例输出</div><div class='pddata'>7</div><div class='pdsec'>样例说明</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1 ≤ N ≤ 40，1 ≤ B ≤ 1000， 0 ≤ A ≤ B。</div>\n","gpid":"T542","lanqiaotitle":"Chips Challenge","memorylimit":"256.0MB","tid":"ALGO-206","timelimit":"2.0s","title":"算法训练 Chips Challenge","src":"ACM/ICPC World Finals 2011 D"},{"checkpoint":"计算几何","updatetime":"2019-12-10","content":"<div class='pdsec'>问题描述</div><div class='pdcont'><img width=\"260\" height=\"144\" src=\"/RequireFile.do?fid=rfjMjN7B\" /><br />\n　　一个立方体悬浮于空间中。以一个立方体底面一顶点为原点建立一个笛卡尔坐标系，如图所示。立方体棱长为d，所以它的对角线的坐标为（0，0，0）和（d，d，d，）。坐标系的z轴正方向为“向上”与重力反向。<br />\n　　立方体的内部在各个维度上有相同间隔的分割面，所以立方体被分为n^3相同尺寸的小立方体。分割面很薄且不透水，每个小立方体都充满水。小立方体内水的总量为d^3。<br />\n　　一把枪发射一发子弹可能射中立方体。这把枪枪口的位置在点（x1,y1,z1）。点(x2,y2,z2)是弹道上一点用来定义子弹的方向。子弹没有打碎立方体，但是子弹经过的地方都会留下弹孔。弹孔可以在小立方体的面，棱或顶点上。水受重力影响可能从弹孔中泄漏。所有流出的水都会被收集并测量。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入数据包含多组实验。每组实验由八个整数描述。第一个整数为n(n&lt;=50)，如上所述。第二个整数为d(d&lt;=100)。剩下六个整数——x1,y1,z1,x2,y2,z2——表示枪口以及弹道上一点的坐标(-100&lt;=x1,y1,z1,x2,y2,z2&lt;=100)。这两点不同。最后一个实验后以0结尾表示数据结束。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　你的程序必须计算出从大立方体中流出水的总量。对于每个实验，输出实验编号，一个记号Volume = 和流出水的总量，流出水的总量精确到小数点后两位。<br />\n　　每两组实验以空行隔开。<br />\n　　注意：<br />\n　　在这个问题中两个实数如果相差小于10^-6就被认为是相等的。</div><div class='pdsec'>样例输入</div><div class='pddata'>5   25     5  15   0     5  15 100<br />\n3 30 0 -35 0 3 -25 3<br />\n10   16     8  17  11    12  19   6<br />\n0</div><div class='pdsec'>样例输出</div><div class='pddata'>Trial 1, Volume = 2500.00<br />\nTrial 2, Volume = 1950.00<br />\nTrial 3, Volume = 0.00</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=50<br />\n　　d&lt;=100<br />\n　　-100&lt;=x1,y1,z1,x2,y2,z2&lt;=100</div>\n","gpid":"T541","lanqiaotitle":"Bullet Hole","memorylimit":"256.0MB","tid":"ALGO-205","timelimit":"1.0s","title":"算法训练 Bullet Hole","src":"ACM/ICPC World Finals 1999 B"},{"checkpoint":"循环 函数","updatetime":"2019-12-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定L,R。统计[L,R]区间内的所有数在二进制下包含的“1”的个数之和。<br />\n　　如5的二进制为101，包含2个“1”。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含2个数L,R</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个数S，表示[L,R]区间内的所有数在二进制下包含的“1”的个数之和。</div><div class='pdsec'>样例输入</div><div class='pddata'>2 3</div><div class='pdsec'>样例输出</div><div class='pddata'>3</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　L&lt;=R&lt;=100000;</div>\n","gpid":"T536","lanqiaotitle":"二进制数数","memorylimit":"256.0MB","tid":"ALGO-202","timelimit":"1.0s","title":"算法训练 二进制数数","src":""},{"checkpoint":"","updatetime":"2019-12-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输出大等于n的最小的完全平方数。<br />\n　　若一个数能表示成某个自然数的平方的形式，则称这个数为完全平方数<br />\n　　Tips：注意数据范围</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一个整数n</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　大等于n的最小的完全平方数</div><div class='pdsec'>样例输入</div><div class='pddata'>71711</div><div class='pdsec'>样例输出</div><div class='pddata'>71824</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n是32位有符号整数</div>\n","gpid":"T535","lanqiaotitle":"大等于n的最小完全平方数","memorylimit":"256.0MB","tid":"ALGO-201","timelimit":"1.0s","title":"算法训练 大等于n的最小完全平方数","src":""},{"checkpoint":"枚举、二维凸包","updatetime":"2019-11-21","content":"<div class='pdcont'><b> The Fortified Forest</b><b></b><br />\n<b>【问题描述】</b><br />\n　　从前，在一个遥远的地方，住着一个国王。这个国王拥有为数不多的罕见而珍贵的树木，这些都是他的祖先在四处旅游时收集来的。为了保护这些树木不被小偷偷走，国王下令绕它们建造高栅栏。他的男巫将负责执行。<br />\n　　唉，男巫很快发现唯一适合用来建造栅栏的材料正是这些树木本身。换句话说，需要砍掉一些树木做成木材，才能在剩下的树周围建起栅栏。当然，为了防止被砍头，男巫想要最小化被砍的树木的总价值。男巫登上了他的魔塔，呆在那里直到找到了最佳的解决方案。最终栅栏被建成了，人们永远幸福地生活着。<br />\n　　你需要写一个程序来解决男巫遇到的问题。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含多组测试数据，每组测试数据描述一个假设的森林。每组测试数据，第一行一个整数n，2&lt;=n&lt;=15，表示森林中树木的数量。这些树木依次编号为1到n。接下来n行，每一行包含4个整数xi，yi，vi，li，分别描述了一棵树的位置（xi，yi），价值vi，砍倒后可以做成的栅栏的长度。vi，li在0到10000之间。<br />\n　　输入最后一行一个0表示结束。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组测试数据，计算这样一个树的子集，使得用这些树做成的木材可以将剩下的树封闭在一个栅栏中。找到满足条件的价值和最小的子集。如果存在多个最小价值和的子集，选择一个树木的数量最少的。为了简单起见，认为树的直径为0。<br />\n　　输出格式如下所示，测试数据的组数（1,2，...），要被砍倒的数的编号和剩下的栅栏的长度（精确到两位小数）。<br />\n　　每两组测试数据之间输出一个空行。<br />\n　　【样例输入】<b></b><br />\n　　6<br />\n　　0  0  8  3<br />\n　　1  4  3  2<br />\n　　2  1  7  1<br />\n　　4  1  2  3<br />\n　　3  5  4  6<br />\n　　2  3  9  8<br />\n　　3<br />\n　　3  0 10  2<br />\n　　5  5 20 25<br />\n　　7 -3 30 32<br />\n　　0<br />\n　　【样例输出】<b></b><br />\n　　Forest 1<br />\n　　Cut these trees: 2 4 5<br />\n　　Extra wood: 3.16<br />\n<br />\n　　Forest 2<br />\n　　Cut these trees: 2<br />\n　　Extra wood: 15.00</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　测试数据组数&lt;=10。数据保证解唯一。</div>\n","gpid":"T523","lanqiaotitle":"The Fortified Forest","memorylimit":"256.0MB","tid":"ALGO-198","timelimit":"500ms","title":"算法训练 The Fortified Forest","src":"ACM/ICPC World Finals 1999 D"},{"checkpoint":"模拟","updatetime":"2019-11-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　日式的折纸手工——一种折纸的艺术——常常需要用到“口袋”的概念，特别是在那些复杂的、各个折纸模型需要通过口袋来实现嵌套的作品中。在这题中，我们需要数一数，一个正方形纸片折叠后形成了多少个口袋。一个口袋定义为：在折好的纸片中，从边界上可以看到的一个开口（两层纸之间的开口）。注意：一个开口可能被记作多个口袋，因为它可能可以从多个方向看到。图1展示了这样一个例子。注意到，“中间”的那个开口（第二和第三层之间的开口）被算了三次。<br />\n<br />\n　　图1：<br />\n<br />\n<img src=\"/RequireFile.do?fid=2egMbRRA\" width=\"585\" height=\"177\" /><br />\n　　我们假设这个纸片一开始平放在桌面上，并且任意时刻都不会被完全从桌面上拿起。每次折叠要么是水平的、要么是垂直的，并且折叠只能沿着预先标好的N条水平线和N条垂直线。没有折叠的时候，水平线从上到下1~N标号，垂直线从左到右1~N标号。每次折叠，我们沿着一条线，和一个方向，把当前的矩形折成一个更小的矩形。例如，'2 U'表示沿着第二条水平线向上折；'1 L'表示沿着第一条垂直线向左折。折叠后，一条线可能有多个表示方法。（例如，图2中，第一次折叠后，'1 D'和'3 D'是等价的指令了）。最后，整个纸片被折成1*1的正方形，这时我们来统计它的口袋数量。保证每次操作都是合法的，并且这里我们忽略纸片的厚度。<br />\n<br />\n　　图2：<br />\n<br />\n<img src=\"/RequireFile.do?fid=febGLLJh\" width=\"633\" height=\"220\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入第一行两个正整数N、K，N表示横向（也是纵向）的折痕数，K表示折叠操作数。水平线从上到下1~N标号，垂直线从左到右1~N标号。<br />\n　　接下来K行，每行由一个正整数和一个字符组成。正整数表示沿着哪条线折叠，字符表示折叠方向。（U为向上、D为向下；L为向左，R为向右）。折痕是水平的还是垂直的由折叠方向决定。<br />\n　　保证最终折成了1*1的正方形。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行一个正整数，口袋数。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 5<br />\n2 U<br />\n1 L<br />\n3 D<br />\n3 R<br />\n2 L<pre class='pddata'>\n<br />\n</pre>\n</div><div class='pdsec'>样例输出</div><div class='pddata'>17</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于25%的数据，N&lt;=3.<br />\n　　对于50%的数据，N&lt;=5.<br />\n　　对于100%的数据，N&lt;=64，K&lt;=64</div>\n","gpid":"T522","lanqiaotitle":"Pocket","memorylimit":"256.0MB","tid":"ALGO-197","timelimit":"1.0s","title":"算法训练 Pocket","src":"ACM/ICPC World Finals 2006 H"},{"checkpoint":"FloodFill","updatetime":"2019-11-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　为了了解早期文明，考古学家们经常会研究古代语言的书籍。有这样一种语言，它在3000多年前古老的埃及曾经被使用，是一种基于象形符号的语言。图1表示了六种象形符号以及它们的名字。在这个问题中，你需要写一个程序去辨识这6个字符。<br />\n<br />\n<img src=\"/RequireFile.do?fid=a8AgqBbj\" width=\"819\" height=\"282\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包括多组测试用例，每一组都描述了一个图像，这个图像包含一或多个从图1中选出的象形符号。这些图像以这样的方式给出：一系列黑色像素(用1表示)和白色像素(用0表示)组成的扫描线。在输入数据中，每个扫描线都是用十六进制的方法进行编码的。例如，八个像素的序列10011100(一个黑色像素，后面跟着两个白色像素，等等)可以表示为十六进制数字9c。在十六进制中，只会出现数字和小写字母a至f。每个测试用例的第一行包含两个整数，H和W：H(0&lt;H≤200)是图像中扫描线的个数，W(0&lt;W≤50)是每一行十六进制的字符数。接下来的H行从上到下给出了十六进制编码扫描线。输入的图像遵循以下规则：<br />\n　　1. 图像仅包含图1所示的象形文字。<br />\n　　2. 每个图像至少有一个有效的象形文字。<br />\n　　3. 每个黑色像素都是一个有效象形文字的一部分。<br />\n　　4. 每个象形文字由一个联通的黑色像素块组成，对于每个黑色像素，至少在其上下左右至少有一块黑色像素块。<br />\n　　5.  象形文字互不接触，而且不存在一个象形文字在另一个的内部。<br />\n　　6. 如果有两块黑色像素对角线相接处，则必然存在一块公共接触的黑色像素。<br />\n　　7. 象形文字可能会扭曲，但是它的拓扑结构必然会和图1中所示的一个等价。(如果一个图像可以通过拉伸但不被毁坏的方式转化成另一个，则它们是拓扑等价的)<br />\n　　最后一组测试用例后紧跟一行，包含两个0，表示输入结束。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组测试用例，先输出它的编号，后面跟着一个字符串，表示每一个出现在图像中的象形文字，使用下面的编码：<br />\n　　Ankh: A<br />\n　　Wedjat: J<br />\n　　Djed: D<br />\n　　Scarab: S<br />\n　　Was: W<br />\n　　Akhet: K<br />\n　　对于每个输出的字符串，字符要按照字典序输出。请参照输出样例的格式。<br />\n　　输入样例包含图2和图3所示的测试点。由于空间的限制，样例数据并没有显示完全。<br />\n<br />\n<img src=\"/RequireFile.do?fid=bG84eR99\" width=\"135\" height=\"178\" /><img src=\"/RequireFile.do?fid=QeLBmQBq\" width=\"165\" height=\"201\" /></div><div class='pdsec'>样例输入</div><div class='pddata'>100 25<br />\n0000000000000000000000000<br />\n0000000000000000000000000<br />\n...(省略50行)...<br />\n00001fe0000000000007c0000<br />\n00003fe0000000000007c0000<br />\n...(省略44行)...<br />\n0000000000000000000000000<br />\n0000000000000000000000000<br />\n150 38<br />\n00000000000000000000000000000000000000<br />\n00000000000000000000000000000000000000<br />\n...(省略75行)...<br />\n0000000003fffffffffffffffff00000000000<br />\n0000000003fffffffffffffffff00000000000<br />\n...(省略69行)...<br />\n00000000000000000000000000000000000000<br />\n00000000000000000000000000000000000000<br />\n0 0</div><div class='pdsec'>样例输出</div><div class='pddata'>Case 1: AKW<br />\nCase 2: AAAAA</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于30%的数据  图像中只会有一个象形字符<br />\n　　对于100%的数据 0＜H≤200  0＜W≤50</div>\n","gpid":"T521","lanqiaotitle":"Ancient Messages","memorylimit":"256.0MB","tid":"ALGO-196","timelimit":"1.0s","title":"算法训练 Ancient Messages","src":"ACM/ICPC World Finals 2011 C"},{"checkpoint":"","updatetime":"2019-11-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输入正整数n，判断从1到n之中，数字1一共要出现几次。例如1123这个数，则出现了两次1。例如15，那么从1到15之中，一共出现了8个1。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一个正整数n</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个整数，表示1出现的资料</div><div class='pdsec'>样例输入</div><div class='pddata'>15</div><div class='pdsec'>样例输出</div><div class='pddata'>8</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n不超过30000</div>\n","gpid":"T520","lanqiaotitle":"1的个数","memorylimit":"256.0MB","tid":"ALGO-195","timelimit":"1.0s","title":"算法训练 1的个数","src":""},{"checkpoint":"逻辑","updatetime":"2019-02-13","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　《审美的历程》课上有n位学生，帅老师展示了m幅画，其中有些是梵高的作品，另外的都出自五岁小朋友之手。老师请同学们分辨哪些画的作者是梵高，但是老师自己并没有答案，因为这些画看上去都像是小朋友画的……老师只想知道，有多少对同学给出的答案完全相反，这样他就可以用这个数据去揭穿披着皇帝新衣的抽象艺术了（支持帅老师^_^）。<br />\n　　答案完全相反是指对每一幅画的判断都相反。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行两个数n和m，表示学生数和图画数；<br />\n　　接下来是一个n*m的01矩阵A：<br />\n　　如果aij=0，表示学生i觉得第j幅画是小朋友画的；<br />\n　　如果aij=1，表示学生i觉得第j幅画是梵高画的。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个数ans：表示有多少对同学的答案完全相反。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 2<br />\n1 0<br />\n0 1<br />\n1 0</div><div class='pdsec'>样例输出</div><div class='pddata'>2</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　同学1和同学2的答案完全相反；<br />\n　　同学2和同学3的答案完全相反；<br />\n　　所以答案是2。</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于50%的数据：n&lt;=1000；<br />\n　　对于80%的数据：n&lt;=10000；<br />\n　　对于100%的数据：n&lt;=50000，m&lt;=20。</div>\n","gpid":"T519","lanqiaotitle":"审美课","memorylimit":"256.0MB","tid":"ALGO-194","timelimit":"1.0s","title":"算法训练 审美课","src":""},{"checkpoint":"AC自动机 DP","updatetime":"2019-02-13","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　你是一个秘密犯罪组织the Sneaky Underground Smug Perpetrators of Evil Crimes and Thefts(SUSPECT)里的电脑高手。SUSPECT最新的邪恶犯罪目标是他们最大的对手the Indescribably Clever Policemen’s Club（ICPC），一切都已经准备就绪，除了一件小事：ICPC的主机密码。<br />\n　　密码仅有小写字母’a’-‘z’构成。此外，通过各种偷窥，你已经确定了密码的长度，和一些（可能重叠）密码中的子串，尽管你不清楚他们出现在密码的哪个位置。<br />\n　　例如，你知道密码的长度是10个字符且你观察到了子串“hello”和“world”。那么密码一定是“helloworld”或者“worldhello”。<br />\n　　问题在于这些信息是否能将密码的可能数缩减到一个合理的范围内。要回答这个问题，你的任务是写一个程序判断可能的密码的总数目，如果可能的密码数目不超过42，打印出所有可能密码。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含两个整数N和M，分别表示密码的长度和已知的密码中子串的数量。接下来M行，每行一个密码中的已知子串。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第一行输出Y，Y表示可能的密码的数目。如果Y不超过42，接下来按照字典序，每行一个密码，依次输出所有可能的密码。</div><div class='pdsec'>样例输入</div><div class='pddata'>10 2<br />\nhello<br />\nworld</div><div class='pdsec'>样例输出</div><div class='pddata'>2<br />\nhelloworld<br />\nworldhello</div><div class='pdsec'>样例输入</div><div class='pddata'>10 0</div><div class='pdsec'>样例输出</div><div class='pddata'>141167095653376</div><div class='pdsec'>样例输入</div><div class='pddata'>4 1<br />\nicpc</div><div class='pdsec'>样例输出</div><div class='pddata'>1<br />\nicpc</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=N&lt;=25，0&lt;=M&lt;=10，子串长度&lt;=10，所有字符均为小写字母’a’-‘z’，输入数据保证答案不超过10^15。</div>\n","gpid":"T518","lanqiaotitle":"Password Suspects","memorylimit":"128.0MB","tid":"ALGO-193","timelimit":"1.0s","title":"算法训练 Password Suspects","src":"ACM/ICPC World Finals 2008 I"},{"checkpoint":"循环，分支","updatetime":"2019-01-29","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个正整数n，求一个正整数p，满足p仅包含n的所有素因子，且每个素因子的次数不大于1</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一个整数，表示n</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行，包含一个整数p。</div><div class='pdsec'>样例输入</div><div class='pddata'>1000</div><div class='pdsec'>样例输出</div><div class='pddata'>10</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=10^12<br />\n　　样例解释：n=1000=2^3*5*3，p=2*5=10</div>\n","gpid":"T513","lanqiaotitle":"素因子去重","memorylimit":"256.0MB","tid":"ALGO-190","timelimit":"1.0s","title":"算法训练 素因子去重","src":"无"},{"checkpoint":"阶乘问题","updatetime":"2019-01-29","content":"<div class='pdcont'>　　一个整数n的阶乘可以写成n!，它表示从1到n这n个整数的乘积。阶乘的增长速度非常快，例如，13！就已经比较大了，已经无法存放在一个整型变量中；而35！就更大了，它已经无法存放在一个浮点型变量中。因此，当n比较大时，去计算n!是非常困难的。幸运的是，在本题中，我们的任务不是去计算n!，而是去计算n!最右边的那个非0的数字是多少。例如，5！=1*2*3*4*5=120，因此5!最右边的那个非0的数字是2。再如，7！=5040，因此7！最右边的那个非0的数字是4。再如，15！= 1307674368000，因此15！最右边的那个非0的数字是8。请编写一个程序，输入一个整数n(0&lt;n&lt;=100)，然后输出n!最右边的那个非0的数字是多少。<br />\n<b>输入：</b><br />\n　　7<br />\n<b>输出：</b><br />\n　　4</div>\n","gpid":"T512","lanqiaotitle":"P0505","memorylimit":"256.0MB","tid":"ALGO-189","timelimit":"1.0s","title":"算法训练 P0505","src":""},{"checkpoint":"最短路，计算几何","updatetime":"2018-03-09","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　航班结束后，提取行李的过程并不琐碎。手提箱和行李箱出现在一条传送带上，数百名乘客争夺有利的位置从中找到并取回自己的所有物。近日，成田机场管理局已决定使这一过程更加高效。在重新设计行李认领区前，他们需要一个模拟程序，使得乘客认领行李时的耗时更平均。这个模拟假定乘客们走一条由直线段组成的路径并使用最少的时间走到他们的行李处。<br />\n　　对于这个问题，传送带被描述为一个简单多边形。在传送带的某些点上出现一件行李，然后以恒定的速度沿着传送带移动。乘客一开始在一个传送带组成的多边形外的点。在行李出现的同时，乘客以恒定的速度（大于行李移动的速度）移动去提取行李。乘客的路径可以接触但不能穿过传送带，且能让乘客在最短的时间内和行李位于同一个点。<br />\n　　在接下来这幅图中，传送带被描述成多边形ABCDEF。行李开始在左上角（A点）并按时针方向沿多边形边缘移动，如小箭头所示。乘客一开始在P点，并开始按最短的时间能和行李到达同一点（图中M点）的路径移动。乘客的移动路径如红色箭头所示。该图对应第一个输入样例。<br />\n<br />\n<img src=\"/RequireFile.do?fid=M9YYHM3r\" width=\"738\" height=\"284\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含一个或多个测试点来描述领取行李的场景。一个场景描述开头一行为一个单独的整数N(3&lt;=N&lt;=100)，多边形的顶点数。接下来N行每行两个整数x<sub>i</sub>,y<sub>i</sub>,(|x<sub>i</sub>|,|y<sub>i</sub>|&lt;=10000)，按逆时针顺序给出多边形顶点的坐标。多边形是简单多边形，也就是说它不自交，不重合。多边形的描述后接下来一行两个整数p<sub>x</sub>,p<sub>y</sub>(|p<sub>x</sub>|,|p<sub>y</sub>|&lt;=10000)，乘客起始位置所在点的坐标。接下来两个正整数V<sub>L</sub>,V<sub>P</sub>(0&lt;V<sub>L</sub>&lt;V<sub>P</sub>&lt;=10000)，分别是行李和乘客的速度。所有坐标的单位是米，速度的单位是米/分钟。<br />\n　　你可以假设乘客位于多边形外。行李将会从多变形的第一个顶点开始按逆时针顺序沿传送带移动。<br />\n　　输入以一行一个单独的0结束。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组数据，输出一行，包括测试数据编号（从1开始编号）和乘客取得行李的最少时间。使用格式如样例输出所示（用冒号隔开分钟和秒），四舍五入到最近的整数。秒数占两位（不足用前导0补齐）。</div><div class='pdsec'>样例输入</div><div class='pddata'>6<br />\n0 40<br />\n0 0<br />\n20 0<br />\n20 20<br />\n40 20<br />\n40 40<br />\n120 40<br />\n70 100<br />\n4<br />\n0 0<br />\n10 0<br />\n10 10<br />\n0 10<br />\n100 100<br />\n10 11<br />\n0</div><div class='pdsec'>样例输出</div><div class='pddata'>Case 1: Time = 1:02<br />\nCase 2: Time = 12:36</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于10%的数据，给出的多边形保证是凸多边形<br />\n　　对于20%的数据，3&lt;=n&lt;=4<br />\n　　对于40%的数据，3&lt;=n&lt;=50<br />\n　　对于100%的数据，3&lt;=n&lt;=100，数组组数&lt;=10，坐标绝对值、速度&lt;=10000</div>\n","gpid":"T495","lanqiaotitle":"Collecting Luggage","memorylimit":"256.0MB","tid":"ALGO-184","timelimit":"3.0s","title":"算法训练 Collecting Luggage","src":"ACM/ICPC World Finals 2007 E"},{"checkpoint":"模拟","updatetime":"2018-03-09","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　2002年1月1日，12个欧洲国家放弃了它们原来的货币，开始使用欧元。从此，在整个欧元区，再也没有了法郎、马克、里拉、基尔德、克朗……，只有欧元。这些国家使用的纸币相同，但是硬币也相同？不完全是这样。每个国家都有一定的自由来制造自己的欧元硬币：<br />\n　　“每个欧元硬币的一面都有同样的欧洲地形，在另一面，成员国可以用自己的图形装饰硬币。无论哪种图形的硬币，都可以在12个成员国的任何地方使用。比如，一个法国公民可以使用含有西班牙国王印记的欧元硬币，在柏林买到一个热狗。”（来源于http://europa.eu.int/euro/html/entry.html）<br />\n　　在2002年1月1日，巴黎唯一的欧元硬币是法国硬币。不久，第一种非法国硬币出现在巴黎。最终，人们可能会认为所有类型的硬币平均分布在12个成员国（其实并不是这样，因为所有国家一直都在发行自己的硬币，所以即使在稳定的情况下，在柏林，德国硬币应该都是最多的）。所以，多久以后芬兰或爱尔兰的硬币才会第一次在意大利南部流通？每种硬币要多久以后才能出现在所有的地方？<br />\n　　因此，你需要写一个程序来模拟欧元硬币在整个欧洲的传播过程。这里使用一种高度简化的模型，考虑单一的欧元面额。给出一个矩形网格，欧洲城市都在格点上，每个城市最多可以有4个邻接的城市（东西南北各一个）。每个城市都属于且仅属于一个国家，而且一个国家所有城市在平面上刚好组成一个矩形。下图是一个含有3个国家、28个城市的地图。<br />\n<img src=\"/RequireFile.do?fid=yNEHABeq\" width=\"246\" height=\"196\" /><br />\n　　在地图上，国家之间是连通的，但国家之间可能含有洞，这表示海洋或像瑞士、丹麦这样的非欧元区国家。一开始，每个城市都只有一百万个本国的硬币，然后每一天，每个城市都按照它在这一天开始时的余额，将一定量的硬币送给它的所有邻接城市。这”一定量的硬币“指的是对于这个城市目前所拥有的每种图形的硬币，每满1000个就要拿出来一个。<br />\n　　当某个城市中，每种图形的硬币都至少出现了一个，就称这个城市“已经完成”。当一个国家的所有城市都已经完成的时候，就称这个国家已经完成。你的程序需要得出每个国家的完成时间。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含多组数据。每组数据的第一行是一个数<i>c</i>，表示国家的个数，接下来c行，每行描述一个国家。对于国家的描述按照以下格式：<i>name xl yl xh yh</i>，其中<i>name</i>是一个最多25个字符的字符串，表示国家名称，<i>(xl, yl)</i>表示这个国家左下角（西南角）的城市坐标，<i>(xh, yh)</i>表示这个国家右上角（东北角）的城市坐标。<br />\n　　最后一组数据之后是一个0。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组数据，先输出一行表示数据编号，接下来对每个国家输出一行，包括这个国家的名称以及它的完成时间（单位：天）。国家之间按照完成时间递增排序，如果两个国家的完成时间相同，按照国家名称的字典序递增排序。<br />\n　　按照样例输出的格式输出（国家名称之前空3格，国家名称和完成时间之间空3格，样例输出在排版的时候可能出了一点问题）。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\nFrance 1 4 4 6<br />\nSpain 3 1 6 3<br />\nPortugal 1 1 2 2<br />\n1<br />\nLuxembourg 1 1 1 1<br />\n2<br />\nNetherlands 1 3 2 4<br />\nBelgium 1 1 2 2<br />\n0</div><div class='pdsec'>样例输出</div><div class='pddata'>Case Number 1<br />\nSpain   382<br />\nPortugal   416<br />\nFrance   1325<br />\nCase Number 2<br />\nLuxembourg   0<br />\nCase Number 3<br />\nBelgium   2<br />\nNetherlands   2</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=<i>c</i>&lt;=20，1&lt;=<i>xl</i>&lt;=<i>xh</i>&lt;=10，1&lt;=<i>yl</i>&lt;=<i>yh</i>&lt;=10。</div>\n","gpid":"T494","lanqiaotitle":"Eurodiffusion","memorylimit":"128.0MB","tid":"ALGO-183","timelimit":"3.0s","title":"算法训练 Eurodiffusion","src":"ACM/ICPC World Finals 2003 D"},{"checkpoint":"枚举 最小生成树","updatetime":"2018-02-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　一组人要担任在一个特定城市举办的比赛的评委，他们需要找到最便宜的租车方式使得每个人都到达目标城市。他们观察发现，如果几个人在旅途的某一段坐同一辆租的车，就可以减少总费用。你的任务就是找出这些人应该采取的路线使得租车的总费用最小。<br />\n　　我们假定：<br />\n　　1. 租一辆车的费用与它行驶的距离成正比，没有燃油、保险、乘客人数多于一个等产生的额外费用。<br />\n　　2. 所有车的费用与行驶距离的比例相同。<br />\n　　3. 一辆车可以容纳任意数量的乘客。<br />\n　　4. 任意一对城市之间最多只有一条道路直接相连，每条道路都是双向的且长度大于0。<br />\n　　5. 每个人的起始城市到目标城市都至少有一种路线。<br />\n　　6. 若多个人的路线中经过同一城市，则这些人从该城市到目标城市必乘同一辆车。<br />\n　　7. 一个人可以乘一辆车到某个城市，再乘另一辆车离开该城市。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含三个整数nc, dc和nr，表示地图上的城市个数，目标城市的编号和地图上的道路条数。<br />\n　　接下来nr行每行包含三个整数c1, c2和dist，表示一条长度为dist的双向道路(c1, c2)。<br />\n　　接下来一行包含一个整数nj，表示人数。<br />\n　　接下来一行包含nj个整数，表示每个人的起始城市。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第一行包含“distance = ”和一个整数，表示所租的车行驶的最小总距离。<br />\n　　接下来nj行每行包含一个人的访问路线，城市按访问顺序给出并用“-”连接。<br />\n　　存在多种方案时，选择需要访问到的城市集合元素最少的一种；仍然存在多种方案时，选择集合元素升序排列后字典序最小的一种。</div><div class='pdsec'>样例输入</div><div class='pddata'>5 3 5<br />\n1 2 1<br />\n2 3 2<br />\n3 4 3<br />\n4 5 1<br />\n2 4 2<br />\n2<br />\n5 1</div><div class='pdsec'>样例输出</div><div class='pddata'>distance = 6<br />\n5-4-2-3<br />\n1-2-3</div><div class='pdsec'>样例输入</div><div class='pddata'>4 4 3<br />\n1 3 1<br />\n2 3 2<br />\n3 4 2<br />\n2<br />\n1 2</div><div class='pdsec'>样例输出</div><div class='pddata'>distance = 5<br />\n1-3-4<br />\n2-3-4</div><div class='pdsec'>样例输入</div><div class='pddata'>3 3 3<br />\n1 2 2<br />\n1 3 3<br />\n2 3 1<br />\n2<br />\n2 1</div><div class='pdsec'>样例输出</div><div class='pddata'>distance = 3<br />\n2-3<br />\n1-2-3</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于30%的数据，1 &lt;= nc &lt;= 8。<br />\n　　对于100%的数据，1 &lt;= nc &lt;= 20，1 &lt;= nj &lt;= 10，1 &lt;= dist &lt;= 100。</div>\n","gpid":"T485","lanqiaotitle":"The Traveling Judges Problem","memorylimit":"256.0MB","tid":"ALGO-178","timelimit":"1.0s","title":"算法训练 The Traveling Judges Problem","src":"ACM/ICPC World Finals 2005 C"},{"checkpoint":"枚举 几何","updatetime":"2018-02-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　你要写一个程序，使得能够模拟在长方体的盒子里放置球形的气球。<br />\n　　接下来是模拟的方案。假设你已知一个长方体的盒子和一个点集。每一个点代表一个可以放置气球的位置。在一个点上放置一个气球，就是以这个点为球心，然后让这个球膨胀，直到触及盒子的边缘或者一个之前已经被放置好的气球。你不能使用一个在盒子外面或者在一个之前已经放置好的气球里面的点。但是，你可以按你喜欢的任意顺序使用这些点，而且你不需要每个点都用。你的目标是按照某种顺序在盒子里放置气球，使得气球占据的总体积最大。<br />\n　　你要做的是计算盒子里没被气球占据的体积。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含一个整数n表示集合里点的个数（1≤n≤6）。第二行包含三个整数表示盒子的一个角落的(x,y,z)坐标，第三行包含与之相对的那个角落的(x,y,z)坐标。接下来n行，每行包含三个整数，表示集合中每个点的(x,y,z)坐标。这个盒子的每维的长度都是非零的，而且它的边与坐标轴平行。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　只有一行，为那个盒子没被气球占据的最小体积（四舍五入到整数）。</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n0 0 0<br />\n10 10 10<br />\n3 3 3<br />\n7 7 7</div><div class='pdsec'>样例输出</div><div class='pddata'>774</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　所有坐标的绝对值小于等于1000<br />\n　　对于20%的数据：n=1<br />\n　　对于50%的数据：1≤n≤3<br />\n　　对于100%的数据：1≤n≤6</div>\n","gpid":"T484","lanqiaotitle":"Balloons in a Box","memorylimit":"256.0MB","tid":"ALGO-177","timelimit":"1.0s","title":"算法训练 Balloons in a Box","src":"ACM/ICPC World Finals 2002 A"},{"checkpoint":"状压DP","updatetime":"2018-01-10","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　想象你是一个在Warsaw的游客，而且预订了一次乘车旅行，去城镇外看一些令人惊异的景点。这辆公共汽车首先围绕城镇行驶一段时间（一段很长的时间，由于Warsaw是一个大城市），把在各自旅馆的人们带上。接着它就去了那个令人惊异的景点，几个小时后又回到城市中，再一次行驶到每一个旅馆，这一次把乘客放下。<br />\n　　由于某种原因，每当你这样做的时候，你的旅馆总是第一个要上车的，而且是最后一个才下车的，意味着你不得不忍受两段经过所有当地旅馆的不那么愉快的旅行。这很明显不是你想要做的事（除非由于某种原因你真的要进入那些旅馆），所以让我们来做个改变。我们将开发一些软件使得那些观光公司能够把它们的乘车旅行路线安排得更公平——尽管这有时候可能会导致每一个人的总距离更长，但公平就是公平，不是吗？<br />\n　　对于这个问题，有一个起始位置（观光公司的总部），h个需要接送游客的旅馆和一个目的地位置（令人惊异的景点）。我们需要找到一条路径，从总部出发，经过所有的旅馆，到景点去，再回来再一次经过所有的旅馆（可能按照不同的顺序），最后返回总部。为了保证没有一个游客（特别是你）被迫忍受两个完整的旅馆旅行，我们要求在去景点的路上接游客的前<img src=\"/RequireFile.do?fid=R66EGmmT\" width=\"53\" height=\"25\" />个旅馆，在回来的路上也得是前<img src=\"/RequireFile.do?fid=R66EGmmT\" width=\"53\" height=\"25\" />个让游客下车的。受制于这些限制条件，我们想让整个公车旅行尽可能短。注意这些限制条件可能会迫使公共汽车经过某个旅馆但是不停下来（这不算做让游客下车），后来再来这里让游客下车，样例就说明了这种情况。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含两个整数n和m满足3≤n≤20,2≤m，n是位置的总数（旅馆，总部和景点），m是汽车能在两个位置之间行驶的路径条数。<br />\n　　n个不同的位置被标号为0到n-1,0是总部，1到n-2是旅馆，而n-1是景点。假定任意一对位置之间最多只有一条直接路径，而且从任意一个位置都能到达任意另一个位置（并不一定直接到达）。<br />\n　　接下来m行，每行包含三个整数u，v和t，满足0≤u，v≤n-1，u≠v，1≤t≤3600，表示公共汽车可以在t秒的时间内直接在u和v之间到达（两个方向都可以）。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个整数，表示可能的最短路线的总耗时。</div><div class='pdsec'>样例输入</div><div class='pddata'>5 4<br />\n0 1 10<br />\n1 2 20<br />\n2 3 30<br />\n3 4 40</div><div class='pdsec'>样例输出</div><div class='pddata'>300</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于20%的数据：n=3<br />\n　　对于50%的数据：3≤n≤10<br />\n　　对于100%的数据：3≤n≤20，2≤m</div>\n","gpid":"T482","lanqiaotitle":"Bus Tour","memorylimit":"512.0MB","tid":"ALGO-176","timelimit":"10.0s","title":"算法训练 Bus Tour","src":"ACM/ICPC World Finals 2012 C"},{"checkpoint":"模拟","updatetime":"2018-01-05","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　一个对象模块是编译器处理源程序的过程中产生的。一个链接载入程序（或者称为链接程序）能够用来整合许多对象模块。当一个程序包含了许多单独的编译模块的时候，我们就需要用到它。它有两个最主要的功能：一是重新分配每个对象模块的代码和数据（因为编译器不知道一个模块将会被放置在哪一个内存里），二是解决两个模块之间的符号引用。比如一个主程序可能会引用平方根函数sqrt，它可能被定义在一个单独的代码模块中。链接程序需要最低限度地给每个模块中的代码和数据分配地址，然后将sqrt函数的地址放置在主模块代码中合适的位置。<br />\n　　一个对象模块有序地包含0个或多个外部符号定义、0个或多个外部符号引用、0个或多个字节的代码和数据（可能包含对外部符号值的引用）以及一个模块结尾标志。在这个问题中，一个对象模块表示为一个文本行序列，每行以一个大写字母开头，描述了剩余文本的含义。它们的格式如下所示。每行文本间存在空白分隔符（一些空格或制表符），每行的末尾也可能存在多余的空白分隔符。<br />\n<br />\n　　·\tD symbol offset<br />\n　　“D”语句是一个外部符号定义。它定义了symbol的地址为当前模块的代码和数据的第一个字节地址向后偏移offset字节。symbol是一个长度小于等于8的大写字母字符串。offset是一个至多4位的十六进制数（使用大写字母A-F）。比如，在一个模块中，被分配的地址从(100)16开始，“D START 5C”表示符号START将会被分配地址(15C)16。在一组测试数据中，这样的定义至多为100个。<br />\n　　·\tE symbol<br />\n　　“E”语句是一个外部符号引用。它表明symbol的值可能会在当前模块的代码或数据中被调用（可能被定义在另一个对象模块中，并且可能会在当前模块之后）。比如，“E START”表示符号STATR的值（被分配的地址）可能在当前模块的代码和数据中被使用。每一个模块中，“E”语句从0开始连续编号，使它们能够在“C”语句中被引用。<br />\n　　·\tC n byte1 byte2 ... byten<br />\n　　“C”语句指定了当前模块的代码和数据的第一个或后n个字节的地址。数值n是一个一位或两位的十六进制数，并且不超过十六进制的10。每一个byte是一个一位或两位的十六进制数，或者是一个“$”符号。一个“$”符号后方跟随一个字节（中间不存在换行），表示引用当前模块中一个从0开始编号的外部符号。编译器将这个符号的值（即它的地址）插入当前链接程序所指的位置（即“$”符号所代表的地址以及后一个地址），十六进制数的高位放在“$”所指示的位置。其余的字节（不跟随在一个“$”后方）将会被放入连续的内存地址中，起始位置为第一个未使用的内存地址。比如语句“C 4 25 $ 0 37”将会把四个十六进制值(25)16 (01)16 (5C)16 (37)16 放入接下来四个未使用的内存地址，假设当前模块的“E”语句已经引用了一个已经被定义地址为(15C)16的符号。如果这个被引用的符号从未被定义，那么将其地址视为(0000)16。<br />\n　　·\tZ<br />\n　　一行一个字母“Z”代表了当前模块的结束。<br />\n<br />\n　　你可以假设不存在超过四位十六进制数的地址。每行的格式都按照以上所述并且不存在语法错误。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入数据存在多组测试数据。每组数据至少包含一个需要被按顺序链接的模块，以仅包含一个“$”的一行结束。每组数据的起始地址为(100)16。<br />\n　　最后一组数据之后是仅包含一个“$”的一行。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每一组数据，输出它的编号（从1开始），一个对于被载入字节的十六位校验和（将在之后描述）以及一个载入表。载入表按字典序升序给出每个被定义或引用的符号以及他们的地址。对于未定义的符号，地址处输出“????”，但在“C”语句中引用时应视为(0000)16。对于重复定义的符号，在地址后输出“M”，并且使用第一次定义的值。具体格式参考样例输入输出。相邻两组测试数据之间用一个空行分开，但最后一组测试数据后请不要存在多余空行。<br />\n　　十六位校验和的计算方法如下：首先将其值设为0，然后以升序遍历所有地址，每次循环左移一位，然后加上该内存地址所存储的值，并无视溢出。<br />\n<br />\n<br />\n　　循环左移的定义为，将十六位校验和的二进制的最高位移至最低位。比如FF00循环左移一位之后得到FE01。<br />\n　　为了方便理解，此处对样例中第一个测试数据的校验和做出解释，此时内存中存储的6个值分别为01, 02, 03, 04, 05, 06（均为十六进制）。校验和初始为0，<br />\n　　00 × 2 + 01 = 01;<br />\n　　01 × 2 + 02 = 04;<br />\n　　04 × 2 + 03 = 0B;<br />\n　　0B × 2 + 04 = 1A;<br />\n　　1A × 2 + 05 = 39;<br />\n　　39 × 2 + 06 = 78.</div><div class='pdsec'>样例输入</div><div class='pddata'>D MAIN 0<br />\nD END 5<br />\nC 03 01 02 03<br />\nC 03 04 05 06<br />\nZ<br />\n$<br />\nD ENTRY 4<br />\nE SUBX<br />\nE SUBY<br />\nC 10 1 2 3 4 5 $ 0 6 7 8 9 A B C D E<br />\nC 8 10 20 30 40 50 60 70 80<br />\nC 8 90 A0 B0 C0 D0 E0 $ 1<br />\nC 5 $ 0 FF EE DD<br />\nZ<br />\nD SUBX 01<br />\nC 06 A B C D E F<br />\nZ<br />\nD SUBX 05<br />\nC 06 51 52 53 54 55 56<br />\nZ<br />\n$<br />\n$</div><div class='pdsec'>样例输出</div><div class='pddata'><img width=\"200\" height=\"266\" src=\"/RequireFile.do?fid=eFAFYG82\" /></div>\n","gpid":"T473","lanqiaotitle":"A Linking Loader","memorylimit":"128.0MB","tid":"ALGO-170","timelimit":"1.0s","title":"算法训练 A Linking Loader","src":"ACM/ICPC World Finals 2003 G"},{"checkpoint":"数学","updatetime":"2017-12-20","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　卡城著名的格林堡博物馆是加拿大西部最大的博物馆，展品涵盖了艺术、文化史以及矿物学。如今一个全新的展区正在被布置，它是专门为你这样杰出的程序猿（媛）打造的。不幸的是，由于空间不足，博物馆打算建造一栋新的建筑来重新安置这个展区。<br />\n　　新的建筑的尺寸和容量将不同于原始的建筑，但是所有楼层的设计都是直角多边形。一个直角多边形是内角均为90&deg;或270&deg;的多边形。如果我们记90&deg;角为R（Right）、270&deg;角为O（Obtuse），那么一个只包含R和O的字符串能够粗略的表示一个直角多边形。比如，一个矩形（图形1）就是最简单的直角多边形，它能够用RRRR来描述（内角按逆时针排列，起始角任意）。同样地，一个十字形直角多边形（图形2）能够用RRORRORRORRO、RORRORRORROR或者ORRORRORRORR来描述。这些序列被称为角序列。<br />\n<br />\n<img width=\"415\" height=\"170\" src=\"/RequireFile.do?fid=HfNQEQg7\" /><br />\n<br />\n<br />\n<br />\n　　当然，一个角序列不一定能完全对应一个形状的多边形，因为它没有说明边长。并且一个角序列不一定能描述一个合法的直角多边形（比如RRROR）。<br />\n　　为了把事情搞得更麻烦，博物馆并不接受所有的楼层设计。一个博物馆保存了许多价值连城的物品，它们必须要被看守着。出于对成本的考虑，一个楼层最多只能有一个保安。所以只有满足以下要求的楼层设计能被接受：存在一个地点使得一个保安能监视到整个楼层。因此一个角序列能被接受，当且仅当它描述了一个能够被接受的多边形。注意图形2的十字形直角多边形能够被站在中心的保安完全监视，所以它是被接受的，因此角序列RRORRORRORRO是被接受的，即使它也能够描述其他不能被一个保安监视的多边形。<br />\n　　请帮助新建筑的设计师确定有多少给定长度的能够被接受的角序列。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入文件包含多组测试数据。每组数据一行，包含一个正整数 L (1 &lt;= L &lt;= 1000)，表示给定的角序列长度。<br />\n　　输入文件以仅包含0的一行结束。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每一组数据，输出一行，包含测试数据编号（从1开始），之后为给定长度的被接受的角序列的个数。具体格式参考样例输出。</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\n6<br />\n0</div><div class='pdsec'>样例输出</div><div class='pddata'>Case 1: 1<br />\nCase 2: 6</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　按题目描述所示。</div>\n","gpid":"T461","lanqiaotitle":"Glenbow Museum","memorylimit":"256.0MB","tid":"ALGO-165","timelimit":"1.0s","title":"算法训练 Glenbow Museum","src":"ACM/ICPC World Finals 2008 F"},{"checkpoint":"计算几何","updatetime":"2017-12-20","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　作为水污染管理部门的一名雇员，你需要监控那些被有意无意倒入河流、湖泊和海洋的污染物。你的其中一项工作就是估计污染物对不同的水生态系统（珊瑚礁、产卵地等等）造成的影响。<br />\n<img width=\"346\" height=\"200\" src=\"/RequireFile.do?fid=dLyq282M\" /><br />\n<br />\n　　你计算所使用的模型已经在图1中被说明。海岸线（图1中的水平直线）为x轴，污染源位于原点(0, 0)。污染的蔓延呈半圆形，多边形代表了被波及的生态系统。你需要计算出生态系统被污染的面积，也就是图中深蓝色部分。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入文件包含仅包含一组测试数据。<br />\n　　每组测试数据第一行为两个整数n (3 &lt;= n &lt;= 100), r (1 &lt;= r &lt;= 1000)，n表示了多边形的顶点个数，r表示了污染区域的半径；<br />\n　　接下来n行，每行包含两个整数xi (-1500 &lt;= xi &lt;= 1500), yi (0 &lt;= yi &lt;=1500)，表示每个顶点的坐标，以逆时针顺序给出；<br />\n　　数据保证多边形不自交或触及自身，没有顶点会位于圆弧上。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出多边形被圆心位于原点、半径为r的半圆覆盖的面积。<br />\n　　答案的绝对误差不得超过10^-3。</div><div class='pdsec'>样例输入</div><div class='pddata'>6 10<br />\n-8 2<br />\n8 2<br />\n8 14<br />\n0 14<br />\n0 6<br />\n-8 14</div><div class='pdsec'>样例输出</div><div class='pddata'>101.576437872</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　存在约30%的数据，n = 3，r &lt;= 20；<br />\n　　存在另外约30%的数据，n &lt;= 10，r &lt;= 100，坐标范围不超过100；<br />\n　　存在另外约10%的数据，n &lt;= 100，r &lt;= 150，坐标范围不超过250；<br />\n　　存在另外约30%的数据，n &lt;= 100，r &lt;= 1000，数据存在梯度；<br />\n　　对于100%的数据，满足题目所示数据范围。</div>\n","gpid":"T460","lanqiaotitle":"Pollution Solution","memorylimit":"256.0MB","tid":"ALGO-164","timelimit":"1.0s","title":"算法训练 Pollution Solution","src":"ACM/ICPC World Finals 2013 J"},{"checkpoint":"模拟","updatetime":"2017-12-15","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　ACM机场是一个本地机场，对于大多数人来说，机场不是他们的终点或起点，而是中转站。机场有一个规划图。到达的大门在机场的北边（相当于空格）。出发的大门在机场的南边（也相当于空格）。两个正对着的大门距离相当于大门间的距离。每一个到达的大门只对应一个城市。每一个出发的大门也是这样。乘客到达的大门对应他们的起始城市，而出发大门对应他们的目标城市。因为这个问题，我们只需考虑转机的乘客。<br />\n　　转机的乘客会产生机场的交通堵塞。我们已经知道某两个城市之间的平均客流量。用这些信息，有可能能降低交通堵塞。例如，Cx城到Cy城的客流量大，就可以将他们安排得很近，甚至是对位。<br />\n　　因为花园和商店无法穿越，所以到达门G1和出发们G3（见图）的距离为1+2=3。<br />\n　　你需要计算几个方案的客流指数。两个大门间的客流指数等于人数乘以距离。而总的客流指数就是所有门之间的客流指数之和。<br />\n<br />\n<br />\n<br />\n<img src=\"/RequireFile.do?fid=bhT7f62F\" width=\"784\" height=\"386\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入文件有多组测试数据。<br />\n　　最后一组只有一个0。<br />\n　　每组测试数据的输入有两部分。先是客流数据，之后是机场布局。<br />\n　　数据开始时一个n(1&lt;n&lt;25)，表示城市数。接下来n行，每行表示一个城市的数据，第i行先是一个整数，表示起始城市，再一个1到n的整数k，表示目标城市数，k对整数，每对描述一个目标城市，第一个数是城市编号j，然后是乘客数目(最多500)从i到j的人数。<br />\n　　机场布局部分包括1到20个方案。用一个0结束。<br />\n　　一个方案包括3行。第一行一个数表示编号，第二行是1-n的一个排列，描述到达门对应的城市的排列，第三行用同样的方式描述出发大门。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每个测试数据，输出包括一个表格，表示方案编号和客流指数，按照客流指数升序输出。若客流指数相同，则编号小的排在前面。见样例。注意方案编号右对齐，而客流指数左对齐。（样例输出前面4个空格，后面9个空格，然后没有空格，详见未格式化的试题。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n1  2  2 10  3 15<br />\n2  1  3 10<br />\n3  2  1 12  2 20<br />\n1<br />\n1 2 3<br />\n2 3 1<br />\n2<br />\n2 3 1<br />\n3 2 1<br />\n0<br />\n2<br />\n1 1  2 100<br />\n2  1  1 200<br />\n1<br />\n1 2<br />\n1 2<br />\n2<br />\n1 2<br />\n2 1<br />\n0<br />\n0</div><div class='pdsec'>样例输出</div><div class='pddata'>Configuration Load<br />\n2         119<br />\n1         122<br />\nConfiguration Load<br />\n2         300<br />\n1         600</div>\n","gpid":"T434","lanqiaotitle":"Airport Configuration","memorylimit":"256.0MB","tid":"ALGO-162","timelimit":"1.0s","title":"算法训练 Airport Configuration","src":"ACM/ICPC World Finals 2001A"},{"checkpoint":"搜索","updatetime":"2017-12-15","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　在1999年的World Finals中有一个基于Dice Maze(骰子迷宫)的题目。在出题人编写那道题目的时候，他们并没有发现这种迷宫的创意来源。然而在那场比赛结束不久，创作了大量的这种迷宫的Robert Abbott先生，联系了比赛主办方并确认自己是骰子迷宫的原作者。我们很遗憾没有在去年的题目描述中感谢Abbott先生的原创意，但我们很高兴Abbott先生主动为今年的比赛提供他原创的、未公开的“步行通过的箭头迷宫”。<br />\n　　与大多数的迷宫相同，箭头迷宫也是每次从一个路口走到另一个路口，直到到达终点。在每个路口处，如果你从某个方向进入了该路口，那么路口的地面上在靠近你的方向会画有一组箭头，它们相对于你的方向可以是向左，向前，向右，或者是它们的任意组合。<br />\n　　图1描述了一个箭头迷宫。每个路口用二维坐标(x,y)表示，以左上角的路口为(1,1)。在图1给出的迷宫中，起点的坐标是(3,1)，终点的坐标是(3,3)。在你开始后，你只能向北走1步到达(2,1)。由于你是从南边到达(2,1)这一点的，而这一点在南边的箭头是向前指的，所以你只能继续向前走到达(1,1)。在此之后，由于你是从南边到达了(1,1)，这一点在南边的箭头是向右指的，所以你也只能向右拐，到达(1,2)。到目前为止，你还没有做出任何选择。以此类推，你会接着依次经过(2,2) (2,3) (1,3) (1,2)。现在你可以选择继续向前走或者向左转。如果你向前走，你会回到(1,1)，而向左转可以让你到达(2,2)。事实上，唯一最优的方案是依次经过以下路口：(3,1) (2,1) (1,1) (1,2) (2,2) (2,3) (1,3) (1,2) (1,1) (2,1) (2,2) (1,2) (1,3) (2,3) (3,3)。<br />\n　　你需要写一个程序解决这个迷宫。“解决”的意义是：只要迷宫是可解的，你就要找到一条路线，它必须在起点沿指定的方向走出，并最终到达终点，当然，路线的长度需要是所有方案中最短的。<br />\n<img src=\"/RequireFile.do?fid=Lt9MMyqm\" width=\"442\" height=\"428\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入文件包括一个或多个箭头迷宫。每个迷宫描述的第一行是这个迷宫的名称，保证它只由数字和字母组成且长度不超过20。接下来的一行依次包含了起点的坐标，起始时方向，目标点的坐标，以空格隔开。本题的迷宫最大尺寸为9×9，所以行与列的编号均为1到9。起始时的方向为N,S,E,W之一，分别代表北、南、西、东。<br />\n　　剩下的若干行按照以下格式输入：一对整数，若干字符串，以星号(*)结束，以空格隔开。每一行代表一个路口，一对整数表示路口的坐标。对于每一个字符串，第一位为N,S,E,W之一，接下来若干位只可能包含L,F,R，分别代表向左，向前，向右。这个字符串的含义是：朝向某个方向进入该路口(所以箭头被画在这个路口的相反方向)，接下来就只能向某个方向继续行走。<br />\n　　对于每个迷宫，以0作为一行的结束，从接下来一行开始就是一个新的箭头迷宫。输入文件以单独的一行END作为结尾。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每个箭头迷宫，应该先输出它的名字，然后接下来若干行，输出一个路径，格式如问题描述中所述；或者输出\"No Solution Possible\"。迷宫的名字应从第1列开始，而其余所有的行都从第3列开始，即行首有2个空格。对于输出的每个路径，除最后一行外，每行须输出恰好10个路口(坐标)。<br />\n　　在下面的样例中，输入的第一个迷宫是图1中的迷宫。<br />\n　　注意，在下面的样例输出当中，除了SAMPLE和NOSOLUTION两行以外，其余的行首都需要空两格！（由于格式化问题未能显示出来）</div><div class='pdsec'>样例输入</div><div class='pddata'>SAMPLE<br />\n3 1 N 3 3<br />\n1 1 WL NR *<br />\n1 2 WLF NR ER *<br />\n1 3 NL ER *<br />\n2 1 SL WR NF *<br />\n2 2 SL WF ELF *<br />\n2 3 SFR EL *<br />\n0<br />\nNOSOLUTION<br />\n3 1 N 3 2<br />\n1 1 WL NR *<br />\n1 2 NL ER *<br />\n2 1 SL WR NFR *<br />\n2 2 SR EL *<br />\n0<br />\nEND</div><div class='pdsec'>样例输出</div><div class='pddata'>SAMPLE<br />\n(3,1) (2,1) (1,1) (1,2) (2,2) (2,3) (1,3) (1,2) (1,1) (2,1)<br />\n(2,2) (1,2) (1,3) (2,3) (3,3)<br />\nNOSOLUTION<br />\nNo Solution Possible</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　设T为数据组数：对于30%的数据，T=1；对于60%的数据，T≤100；对于100%的数据，T≤1000。</div>\n","gpid":"T433","lanqiaotitle":"Abbott’s Revenge","memorylimit":"256.0MB","tid":"ALGO-161","timelimit":"1.0s","title":"算法训练 Abbott’s Revenge","src":"ACM/ICPC World Finals 2000 A"},{"checkpoint":"大写转小写","updatetime":"2017-12-07","content":"<div class='pdcont'>　　﻿<br />\n　　从键盘输入一个大写字母，要求改用小写字母输出。<br />\n<b>输入</b><br />\n　　A<br />\n<b>输出</b><br />\n　　a</div>\n","gpid":"T428","lanqiaotitle":"P0103","memorylimit":"256.0MB","tid":"ALGO-159","timelimit":"1.0s","title":"算法训练 P0103","src":""},{"checkpoint":"表达式","updatetime":"2017-01-18","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输入一个只包含加减乖除和括号的合法表达式，求表达式的值。其中除表示整除。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入一行，包含一个表达式。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出这个表达式的值。</div><div class='pdsec'>样例输入</div><div class='pddata'>1-2+3*(4-5)</div><div class='pdsec'>样例输出</div><div class='pddata'>-4</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　表达式长度不超过100，表达式运算合法且运算过程都在int内进行。</div>\n","gpid":"T419","lanqiaotitle":"表达式计算","memorylimit":"256.0MB","tid":"ALGO-156","timelimit":"1.0s","title":"算法训练 表达式计算","src":""},{"checkpoint":"","updatetime":"2016-11-23","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　已知一个有理数类Zrf_Ratio，实现如下的操作符重载形式：<br />\n　　friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const zrf_Ratio&amp;);//输出最简分数<br />\n　　friend std::istream&amp; operator&gt;&gt;(std::istream&amp;, zrf_Ratio&amp;);<br />\n　　friend bool operator==(const zrf_Ratio&amp;, const zrf_Ratio&amp;);<br />\n　　friend bool operator&lt;(const zrf_Ratio&amp;, const zrf_Ratio&amp;);</div><div class='pdsec'>测试</div><div class='pdcont'>　　测试时主程序会输入四个整数a, b, c, d，表示两个分数a/b和c/d。要求输出最简分数以及两个分数相等和大小的比较结果。</div><div class='pdsec'>样例输入</div><div class='pddata'>1 7 26 25</div><div class='pdsec'>样例输出</div><div class='pddata'>zrf is:1/7; ssh is:26/25<br />\n(zrf==ssh) is:0; (zrf&lt;ssh) is:1</div>\n","gpid":"T407","lanqiaotitle":"C++ CH08 01","memorylimit":"256.0MB","tid":"ALGO-155","timelimit":"1.0s","title":"算法训练 C++ CH08 01","src":""},{"checkpoint":"","updatetime":"2016-11-09","content":"<div class='pdsec'>问题描述</div><div class='pdcont'><img src=\"/RequireFile.do?fid=5DyfBRyG\" width=\"467\" height=\"69\" /></div><div class='pdsec'>样例输入</div><div class='pddata'>一个满足题目要求的输入范例。<br />\n3 10</div><div class='pdsec'>样例输出</div><div class='pddata'>与上面的样例输入对应的输出。<br />\n<img src=\"/RequireFile.do?fid=t7jLy5DD\" width=\"643\" height=\"54\" /></div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入数据中每一个数的范围。<br />\n　　例：结果在int表示时不会溢出。</div>\n","gpid":"T399","lanqiaotitle":"6-1 递归求二项式系数值","memorylimit":"256.0MB","tid":"ALGO-150","timelimit":"10.0s","title":"算法训练 6-1 递归求二项式系数值","src":""},{"checkpoint":"","updatetime":"2016-11-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编写一函数lcm，求两个正整数的最小公倍数。</div><div class='pdsec'>样例输入</div><div class='pddata'>一个满足题目要求的输入范例。<br />\n例：<br />\n<br />\n3 5</div><div class='pdsec'>样例输出</div><div class='pddata'>与上面的样例输入对应的输出。<br />\n例：<br />\n<img src=\"/RequireFile.do?fid=j7yJHtDa\" width=\"650\" height=\"68\" /></div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入数据中每一个数的范围。<br />\n　　例：两个数都小于65536。</div>\n","gpid":"T392","lanqiaotitle":"5-1最小公倍数","memorylimit":"256.0MB","tid":"ALGO-148","timelimit":"1.0s","title":"算法训练 5-1最小公倍数","src":""},{"checkpoint":"复数运算","updatetime":"2016-01-28","content":"<div class='pdcont'>　　﻿<br />\n　　编程实现两个复数的运算。设有两个复数 和 ，则他们的运算公式为：<br />\n<br />\n　　要求：（1）定义一个结构体类型来描述复数。<br />\n　　（2）复数之间的加法、减法、乘法和除法分别用不用的函数来实现。<br />\n　　（3）必须使用结构体指针的方法把函数的计算结果返回。<br />\n　　说明：用户输入：运算符号(+,-,*,/) a b c d.<br />\n　　输出：a+bi，输出时不管a,b是小于0或等于0都按该格式输出，输出时a,b都保留两位。<br />\n<br />\n<b>输入：</b><br />\n　　- 2.5 3.6 1.5 4.9<br />\n<b>输出：</b><br />\n　　1.00+-1.30i</div>\n","gpid":"T372","lanqiaotitle":"P1103","memorylimit":"256.0MB","tid":"ALGO-142","timelimit":"1.0s","title":"算法训练 P1103","src":""},{"checkpoint":"搜索","updatetime":"2016-01-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一条标有整点(1, 2, 3, ...)的射线. 定义两个点之间的距离为其下标之差的绝对值.<br />\n　　Laharl, Etna, Flonne一开始在这条射线上不同的三个点, 他们希望其中某个人能够到达下标最大的点.<br />\n　　每个角色只能进行下面的3种操作, 且每种操作不能每人不能进行超过一次.<br />\n　　1.移动一定的距离<br />\n　　2.把另一个角色高举过头<br />\n　　3.将举在头上的角色扔出一段距离<br />\n　　每个角色有一个movement range参数, 他们只能移动到没有人的位置, 并且起点和终点的距离不超过movement range.<br />\n　　如果角色A和另一个角色B距离为1, 并且角色B没有被别的角色举起, 那么A就能举起B. 同时, B会移动到A的位置,B原来所占的位置变为没有人的位置. 被举起的角色不能进行任何操作, 举起别人的角色不能移动.同时, 每个角色还有一个throwing range参数, 即他能把举起的角色扔出的最远的距离. 注意, 一个角色只能被扔到没有别的角色占据的位置. 我们认为一个角色举起另一个同样举起一个角色的角色是允许的. 这种情况下会出现3个人在同一个位置的情况. 根据前面的描述, 这种情况下上面的两个角色不能进行任何操作, 而最下面的角色可以同时扔出上面的两个角色. 你的任务是计算这些角色能够到达的位置的最大下标, 即最大的数字x, 使得存在一个角色能够到达x.</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入共三行, 分别为Laharl, Etna, Floone的信息.<br />\n　　每一行有且仅有3个整数, 描述对应角色的初始位置, movement range, throwing range.<br />\n　　数据保证3个角色的初始位置两两不相同且所有的数字都在1到10之间.&lt;/div&gt;</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　仅有1个整数, 即Laharl, Etna, Flonne之一能到达的最大距离.</div><div class='pdsec'>样例输入</div><div class='pddata'>9 3 3<br />\n4 3 1<br />\n2 3 3</div><div class='pdsec'>样例输出</div><div class='pddata'>15</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　一开始Laharl在位置9, Etna在位置4, Flonne在位置2.<br />\n　　首先, Laharl移动到6.<br />\n　　然后Flonne移动到位置5并且举起Etna.<br />\n　　Laharl举起Flonne将其扔到位置9.<br />\n　　Flonne把Etna扔到位置12.<br />\n　　Etna移动到位置15.</div>\n","gpid":"T356","lanqiaotitle":"Lift and Throw","memorylimit":"256.0MB","tid":"ALGO-137","timelimit":"3.0s","title":"算法训练 Lift and Throw","src":"CODEFORCES 105E"},{"checkpoint":"构造","updatetime":"2016-01-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　现有如下一个算法：<br />\n　　repeat ni times<br />\n　　yi := y<br />\n　　y  := yi+1<br />\n　　end repeat<br />\n　　令n[1]为你需要算加法的第一个数字，n[2]为第二个，...n[N]为第N个数字（N为需要算加法的数字个数），<br />\n　　并令y初始值为0，先令i=1运行这个算法（如上所示，重复n[i]次），然后令i=2运行这个算法。。直到i=N。注意y值一直不要清零。最后y的值就是你需要的加法答案。<br />\n　　你想知道，有没有某种运算顺序能使答案等于W。<br />\n　　一个循环中的全部语句，是不能改变在总的语句排列中的相对顺序的。<br />\n　　（这里的第i个循环是指这n[i]*2条语句。就是你把属于第i个循环的语句抽出来看，它们需要按照原顺序排列。在你没有运行完这个循环的最靠前一条未完成的 语句的时候，你是不能跳过它先去完成这个循环后面的语句的。你能做的仅是把若干个循环按照你所规定的顺序“归并”起来。）<br />\n　　举个例子，n[1]= 2 ,n[2]=1, W=1.一种可行的运算顺序是“2 1 1 1 1 2”，数字为几表示运行第几个算法的下一条语句（你可以看到”1”出现了4次，是因为n[1]=2即循环两次，而每次循环里面有两条语句，所以2*2=4次）<br />\n<br />\n<table cellspacing=0 cellpadding=2px style='border-collapse:collapse;' class='table table-striped table-horver'><tbody><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'><br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>y值<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>y[1] 值<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>y[2] 值<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>执行0条语句过后<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>0<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>0<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>0<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>执行1条过后(y[2]=y)<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>0<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>0<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>0<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>执行2条过后(y[1]=y)<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>0<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>0<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>0<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>执行3条过后(y=y[1]+1)<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>0<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>0<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>执行4条过后(y[1]=y)<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>0<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>执行5条过后(y=y[1]+1)<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>2<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>0<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>执行6条过后(y=y[2]+1)<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>0<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'> </td><td valign=\"top\" style='border:solid 1.0pt'><br />\n</td><td valign=\"top\" style='border:solid 1.0pt'><br />\n</td><td valign=\"top\" style='border:solid 1.0pt'> </td></tr></tbody></table>　　可以看到，最后y值变成了1，也就完成了我们的任务。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行你会得到用空格分开的两个整数N(1&lt;=N&lt;=100)和W(-10^9&lt;=W&lt;=10^9)，（N为需要算加法的数字个数，W是你希望算出的数）。<br />\n　　第二行你会得到n个整数n[i] (1&lt;=n[i]&lt;=1000).</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第一行您应该输出Yes(若能以某种顺序使得这个算法得出W的值) 或No。<br />\n　　如果第一行是No，接下来就不用继续输出了。<br />\n　　如果是Yes, 请在第2行输出2*sigma(n[i])个用空格隔开的数，表示任意一种满足条件的运算顺序。</div><div class='pdsec'>样例输入</div><div class='pddata'>1 10<br />\n11</div><div class='pdsec'>样例输出</div><div class='pddata'>No</div><div class='pdsec'>样例输入</div><div class='pddata'>2 3<br />\n4 4</div><div class='pdsec'>样例输出</div><div class='pddata'>Yes<br />\n1 1 2 1 2 2 2 2 2 1 2 1 1 1 1 2</div><div class='pdsec'>样例输入</div><div class='pddata'>3 6<br />\n1 2 3</div><div class='pdsec'>样例输出</div><div class='pddata'>Yes<br />\n1 1 2 2 2 2 3 3 3 3 3 3</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于30%的数据，n&lt;=4, n[i]的和小于10.<br />\n　　对于100%的数据，n&lt;=100 , -10^9&lt;=W&lt;=10^9, 1&lt;=n[i]&lt;=1000</div>\n","gpid":"T347","lanqiaotitle":"Multithreading","memorylimit":"256.0MB","tid":"ALGO-135","timelimit":"1.0s","title":"算法训练 Multithreading","src":"codeforces 26e"},{"checkpoint":"字符串 KMP","updatetime":"2016-01-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　在年轻的时候，我们故事中的英雄——国王 Copa——他的私人数据并不是完全安全地隐蔽。对他来说是，这不可接受的。因此，他发明了一种密码，好记又难以破解。后来，他才知道这种密码是一个长度为奇数的回文串。<br />\n<br />\n　　Copa 害怕忘记密码，所以他决定把密码写在一张纸上。他发现这样保存密码不安全，于是他决定按下述方法加密密码：他选定一个整数 X ，保证 X 不小于 0 ，且 2X 严格小于串长度。然后他把密码分成 3 段，最前面的 X 个字符为一段，最后面的 X 个字符为一段，剩余的字符为一段。不妨把这三段依次称之为 prefix, suffix, middle 。显然， middle 的长度为一个大于 0 的奇数，且 prefix 、 suffix 的长度相等。他加密后的密码即为 A + prefix + B + middle + C + suffix ，其中 A 、 B 、 C 是三个由 Copa 选定的字符串，且都有可能为空， + 表示字符串相连。<br />\n<br />\n　　许多年过去了。Copa 昨天找到了当年写下加密后字符串的那张纸。但是，Copa 把原密码、A、B、C 都忘了。现在，他请你找一个尽量长的密码，使得这个密码有可能被当年的 Copa 发明、加密并写下。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含一个只含有小写拉丁字母的字符串，长度在 1 到 10^5 之内。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第一行包含一个整数 k ，表示你找到的原密码分成的 3 个部分中有多少个非空字符串。显然 k in {1, 3} 。接下来 k 行，每行 2 个用空格分开的整数 x_i l_i ，表示这一部分的起始位置和长度。要求输出的 x_i 递增。<br />\n<br />\n　　起始位置 x_i 应该在 1 到加密后的字符串长度之间。 l_i 必须是正整数，因为你只要输出非空部分的信息。 middle 的长度必须为奇数。<br />\n<br />\n　　如果有多组答案，任意一组即可。提示：你要最大化的是输出的 l_i 的总和，而不是 k 。</div><div class='pdsec'>样例输入</div><div class='pddata'>abacaba</div><div class='pdsec'>样例输出</div><div class='pddata'>1<br />\n1 7</div><div class='pdsec'>样例输入</div><div class='pddata'>axbya</div><div class='pdsec'>样例输出</div><div class='pddata'>3<br />\n1 1<br />\n2 1<br />\n5 1</div><div class='pdsec'>样例输入</div><div class='pddata'>xabyczba</div><div class='pdsec'>样例输出</div><div class='pddata'>3<br />\n2 2<br />\n4 1<br />\n7 2</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于 10% 的数据： n &lt;= 10<br />\n<br />\n　　对于 30% 的数据： n &lt;= 100<br />\n<br />\n　　对于 100% 的数据： n &lt;= 100000<br />\n<br />\n　　存在 20% 的数据，输出文件第一行为 1 。</div>\n","gpid":"T344","lanqiaotitle":"Tricky and Clever Password","memorylimit":"256.0MB","tid":"ALGO-133","timelimit":"2.0s","title":"算法训练 Tricky and Clever Password","src":"CODEFORCES 30E"},{"checkpoint":"排序、贪心","updatetime":"2016-01-04","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　从万能词典来的聪明的海狸已经使我们惊讶了一次。他开发了一种新的计算器，他将此命名为\"Beaver's Calculator 1.0\"。它非常特别，并且被计划使用在各种各样的科学问题中。<br />\n　　为了测试它，聪明的海狸邀请了n位科学家，编号从1到n。第i位科学家给这个计算器带来了 <i>k</i><sub><i>i</i></sub>个计算题。第i个科学家带来的问题编号1到n，并且它们必须按照编号一个一个计算，因为对于每个问题的计算都必须依赖前一个问题的计算结果。<br />\n　　每个教授的每个问题都用一个数  <i>a</i><sub><i>i</i>,&thinsp;<i>j</i></sub>&thinsp; 来描述，i（1≤i≤n）是科学家的编号，j（1≤j≤ <i>k</i><sub><i>i</i></sub> ）是问题的编号， <i>a</i><sub><i>i</i>,&thinsp;<i>j</i></sub>&thinsp; 表示解决这个问题所需资源单位的数量。<br />\n　　这个计算器非常不凡。它一个接一个的解决问题。在一个问题解决后，并且在下一个问题被计算前，计算器分配或解放资源。<br />\n　　计算器中最昂贵的操作是解放资源，解放远远慢于分配。所以对计算器而言，每一个接下来的问题所需的资源不少于前一个，是非常重要的。<br />\n　　给你关于这些科学家所给问题的相关信息。你需要给这些问题安排一个顺序，使得“坏对”尽可能少。<br />\n　　所谓“坏对”，就是相邻两个问题中，后一个问题需求的资源比前一个问题少。别忘了，对于同一个科学家给出的问题，计算它们的相对顺序必须是固定的。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含一个整数n，表示科学家的人数。接下来n行每行有5个整数，<i>k</i><sub><i>i</i></sub>, <i>a</i><sub><i>i</i>,&thinsp;1</sub>, <i>x</i><sub><i>i</i></sub>, <i>y</i><sub><i>i</i></sub>, <i>m</i><sub><i>i</i></sub> (0&thinsp;≤&thinsp;<i>a</i><sub><i>i</i>,&thinsp;1</sub>&thinsp;&lt;&thinsp;<i>m</i><sub><i>i</i></sub>&thinsp;≤&thinsp;10<sup>9</sup>, 1&thinsp;≤&thinsp;<i>x</i><sub><i>i</i></sub>,&thinsp;<i>y</i><sub><i>i</i></sub>&thinsp;≤&thinsp;10<sup>9</sup>) ，分别表示第i个科学家的问题个数，第1个问题所需资源单位数，以及3个用来计算 <i>a</i><sub><i>i</i>,&thinsp;<i>j</i></sub> 的参量。<i>a</i><sub><i>i</i>,&thinsp;<i>j</i></sub>&thinsp;=&thinsp;(<i>a</i><sub><i>i</i>,&thinsp;<i>j</i>&thinsp;-&thinsp;1</sub>&thinsp;*&thinsp;<i>x</i><sub><i>i</i></sub>&thinsp;+&thinsp;<i>y</i><sub><i>i</i></sub>)<i>mod</i> <i>m</i><sub><i>i。</i></sub></div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第一行输出一个整数，表示最优顺序下最少的“坏对”个数。<br />\n　　如果问题的总个数不超过200000,接下来输出 <img src=\"http://codeforces.ru/renderer/a16730dcbb2402871e20647c8aba55beada5c1b6.png\" /> 行，表示解决问题的最优顺序。每一行两个用空格隔开的整数，表示这个问题所需的资源单位数和提供这个问题的科学家的编号。</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n2 1 1 1 10<br />\n2 3 1 1 10</div><div class='pdsec'>样例输出</div><div class='pddata'>0<br />\n1 1<br />\n2 1<br />\n3 2<br />\n4 2</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　20%的数据 <i>n</i>&thinsp;=&thinsp;2, 1&thinsp;≤&thinsp;<i>k</i><sub><i>i</i></sub>&thinsp;≤&thinsp;2000；<br />\n　　另外30%的数据 <i>n</i>&thinsp;=&thinsp;2, 1&thinsp;≤&thinsp;<i>k</i><sub><i>i</i></sub>&thinsp;≤&thinsp;200000；<br />\n　　剩下50%的数据  1&thinsp;≤&thinsp;<i>n</i>&thinsp;≤&thinsp;5000, 1&thinsp;≤&thinsp;<i>k</i><sub><i>i</i></sub>&thinsp;≤&thinsp;5000。</div>\n","gpid":"T340","lanqiaotitle":"Beaver's Calculator","memorylimit":"256.0MB","tid":"ALGO-131","timelimit":"3.0s","title":"算法训练 Beaver's Calculator","src":"CODEFORCES 207A"},{"checkpoint":"递推、动态规划","updatetime":"2015-12-25","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　一个间不容发的时刻：n个牛仔站立于一个环中，并且每个牛仔都用左轮手枪指着他旁边的人！每个牛仔指着他顺时针或者逆时针方向上的相邻的人。正如很多西部片那样，在这一刻，绳命是入刺的不可惜……对峙的场景每秒都在变化。每秒钟牛仔们都会分析局势，当一对相邻的牛仔发现他们正在互指的时候，就会转过身。一秒内每对这样的牛仔都会转身。所有的转身都同时在一瞬间发生。我们用字母来表示牛仔所指的方向。“A”表示顺时针方向，“B”表示逆时针方向。如此，一个仅含“A”“B”的字符串便用来表示这个由牛仔构成的环。这是由第一个指着顺时针方向的牛仔做出的记录。例如，牛仔环“ABBBABBBA”在一秒后会变成“BABBBABBA”；而牛仔环“BABBA”会变成“ABABB”。 这幅图说明了“BABBA”怎么变成“ABABB” 一秒过去了，现在用字符串s来表示牛仔们的排列。你的任务是求出一秒前有多少种可能的排列。如果某个排列中一个牛仔指向顺时针，而在另一个排列中他指向逆时针，那么这两个排列就是不同的。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入数据包括一个字符串s，它只含有“A”和“B”。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出你求出来的一秒前的可能排列数。</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　s的长度为3到100（包含3和100）</div><div class='pdsec'>样例输入</div><div class='pddata'>BABBBABBA</div><div class='pdsec'>样例输出</div><div class='pddata'>2</div><div class='pdsec'>样例输入</div><div class='pddata'>ABABB</div><div class='pdsec'>样例输出</div><div class='pddata'>2</div><div class='pdsec'>样例输入</div><div class='pddata'>ABABAB</div><div class='pdsec'>样例输出</div><div class='pddata'>4</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　测试样例一中，可能的初始排列为：\"ABBBABBAB\"和 \"ABBBABBBA\"。<br />\n　　测试样例二中，可能的初始排列为：\"AABBB\"和\"BABBA\"。</div>\n","gpid":"T336","lanqiaotitle":"Cowboys","memorylimit":"256.0MB","tid":"ALGO-128","timelimit":"2.0s","title":"算法训练 Cowboys","src":"CODEFORCES 212C"},{"checkpoint":"","updatetime":"2015-11-26","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　（图３.１－１）示出了一个数字三角形。 请编一个程序计算从顶至底的某处的一条路<br />\n　　径，使该路径所经过的数字的总和最大。<br />\n　　●每一步可沿左斜线向下或右斜线向下走；<br />\n　　●1＜三角形行数≤100；<br />\n　　●三角形中的数字为整数0，1，…99；<br />\n<br />\n<br />\n　　<img src=\"/RequireFile.do?fid=9RdAy6Be\" width=\"113\" height=\"123\" />.<br />\n　　（图３.１－１）</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　文件中首先读到的是三角形的行数。<br />\n<br />\n　　接下来描述整个三角形</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　最大总和（整数）</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n7<br />\n3 8<br />\n8 1 0<br />\n2 7 4 4<br />\n4 5 2 6 5</div><div class='pdsec'>样例输出</div><div class='pddata'>30</div>\n","gpid":"T312","lanqiaotitle":"数字三角形","memorylimit":"256.0MB","tid":"ALGO-124","timelimit":"1.0s","title":"算法训练 数字三角形","src":"IOI94"},{"checkpoint":"递归 递推","updatetime":"2015-11-19","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　每年冬天，北大未名湖上都是滑冰的好地方。北大体育组准备了许多冰鞋，可是人太多了，每天下午收工后，常常一双冰鞋都不剩。<br />\n　　每天早上，租鞋窗口都会排起长龙，假设有还鞋的m个，有需要租鞋的n个。现在的问题是，这些人有多少种排法，可以避免出现体育组没有冰鞋可租的尴尬场面。（两个同样需求的人（比如都是租鞋或都是还鞋）交换位置是同一种排法）</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　两个整数，表示m和n</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个整数，表示队伍的排法的方案数。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 2</div><div class='pdsec'>样例输出</div><div class='pddata'>5</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　m,n∈［0,18］<br />\n　　问题分析</div>\n","gpid":"T303","lanqiaotitle":"未名湖边的烦恼","memorylimit":"256.0MB","tid":"ALGO-122","timelimit":"1.0s","title":"算法训练 未名湖边的烦恼","src":""},{"checkpoint":"动态规划 资源分配类型（最大乘积）","updatetime":"2015-11-10","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　题目很简单，给出N个数字，不改变它们的相对位置，在中间加入K个乘号和N-K-1个加号，（括号随便加）使最终结果尽量大。因为乘号和加号一共就是N-1个了，所以恰好每两个相邻数字之间都有一个符号。例如：<br />\n　　N=5，K=2，5个数字分别为1、2、3、4、5，可以加成：<br />\n　　1*2*(3+4+5)=24<br />\n　　1*(2+3)*(4+5)=45<br />\n　　(1*2+3)*(4+5)=45<br />\n　　……</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入文件共有二行，第一行为两个有空格隔开的整数，表示N和K，其中（2&lt;=N&lt;=15, 0&lt;=K&lt;=N-1）。第二行为 N个用空格隔开的数字（每个数字在0到9之间）。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出文件仅一行包含一个整数，表示要求的最大的结果</div><div class='pdsec'>样例输入</div><div class='pddata'>5 2<br />\n1 2 3 4 5</div><div class='pdsec'>样例输出</div><div class='pddata'>120</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　(1+2+3)*4*5=120</div>\n","gpid":"T294","lanqiaotitle":"最大的算式","memorylimit":"256.0MB","tid":"ALGO-116","timelimit":"1.0s","title":"算法训练 最大的算式","src":""},{"checkpoint":"循环语句","updatetime":"2015-01-13","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编写一个程序，首先输入一个整数，例如5，然后在屏幕上显示如下的图形（5表示行数）：<br />\n　　* * * * *<br />\n　　* * * *<br />\n　　* * *<br />\n　　* *<br />\n　　*</div>\n","gpid":"T247","lanqiaotitle":"图形显示","memorylimit":"512.0MB","tid":"ALGO-101","timelimit":"1.0s","title":"算法训练 图形显示","src":"程序设计公共基础课(谌卫军)"},{"checkpoint":"循环语句","updatetime":"2015-01-06","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编写一个程序，输入3个整数，然后程序将对这三个整数按照从大到小进行排列。<br />\n　　输入格式：输入只有一行，即三个整数，中间用空格隔开。<br />\n　　输出格式：输出只有一行，即排序后的结果。<br />\n　　输入输出样例</div><div class='pdsec'>样例输入</div><div class='pddata'>9 2 30</div><div class='pdsec'>样例输出</div><div class='pddata'>30 9 2</div>\n","gpid":"T243","lanqiaotitle":"排序","memorylimit":"512.0MB","tid":"ALGO-97","timelimit":"1.0s","title":"算法训练 排序","src":"程序设计公共基础课(谌卫军)"},{"checkpoint":"","updatetime":"2014-12-29","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　任何一个正整数都可以用2进制表示，例如：137的2进制表示为10001001。<br />\n　　将这种2进制表示写成2的次幂的和的形式，令次幂高的排在前面，可得到如下表达式：137=2^7+2^3+2^0<br />\n　　现在约定幂次用括号来表示，即a^b表示为a（b）<br />\n　　此时，137可表示为：2（7）+2（3）+2（0）<br />\n　　进一步：7=2^2+2+2^0  （2^1用2表示）<br />\n　　3=2+2^0<sup>  </sup><br />\n　　所以最后137可表示为：2（2（2）+2+2（0））+2（2+2（0））+2（0）<br />\n　　又如：1315=2^10+2^8+2^5+2+1<br />\n　　所以1315最后可表示为：<br />\n　　2（2（2+2（0））+2）+2（2（2+2（0）））+2（2（2）+2（0））+2+2（0）</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　正整数（1&lt;=n&lt;=20000）</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　符合约定的n的0，2表示（在表示中不能有空格）</div><div class='pdsec'>样例输入</div><div class='pddata'>137</div><div class='pdsec'>样例输出</div><div class='pddata'>2(2(2)+2+2(0))+2(2+2(0))+2(0)</div><div class='pdsec'>样例输入</div><div class='pddata'>1315</div><div class='pdsec'>样例输出</div><div class='pddata'>2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)</div><div class='pdsec'>提示</div><div class='pdcont'>　　用递归实现会比较简单，可以一边递归一边输出</div>\n","gpid":"T235","lanqiaotitle":"2的次幂表示","memorylimit":"512.0MB","tid":"ALGO-95","timelimit":"1.0s","title":"算法训练 2的次幂表示","src":""},{"checkpoint":"字符操作 数学知识","updatetime":"2014-12-16","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编写一个程序，以字符串方式输入一个前缀表达式，然后计算它的值。输入格式为：“运算符  对象1  对象2”，其中，运算符为“+”（加法）、“-”（减法）、“*”（乘法）或“/”（除法），运算对象为不超过10的整数，它们之间用一个空格隔开。要求：对于加、减、乘、除这四种运算，分别设计相应的函数来实现。<br />\n　　输入格式：输入只有一行，即一个前缀表达式字符串。<br />\n　　输出格式：输出相应的计算结果（如果是除法，直接采用c语言的“/”运算符，结果为整数）。<br />\n　　输入输出样例</div><div class='pdsec'>样例输入</div><div class='pddata'>+ 5 2</div><div class='pdsec'>样例输出</div><div class='pddata'>7</div>\n","gpid":"T225","lanqiaotitle":"前缀表达式","memorylimit":"512.0MB","tid":"ALGO-92","timelimit":"1.0s","title":"算法训练 前缀表达式","src":"程序设计公共基础课(谌卫军)"},{"checkpoint":"数组运算 字符操作","updatetime":"2014-11-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Anagrams指的是具有如下特性的两个单词：在这两个单词当中，每一个英文字母（不区分大小写）所出现的次数都是相同的。例如，“Unclear”和“Nuclear”、“Rimon”和“MinOR”都是Anagrams。编写一个程序，输入两个单词，然后判断一下，这两个单词是否是Anagrams。每一个单词的长度不会超过80个字符，而且是大小写无关的。<br />\n　　输入格式：输入有两行，分别为两个单词。<br />\n　　输出格式：输出只有一个字母Y或N，分别表示Yes和No。<br />\n　　输入输出样例</div><div class='pdsec'>样例输入</div><div class='pddata'>Unclear<br />\nNuclear</div><div class='pdsec'>样例输出</div><div class='pddata'>Y</div>\n","gpid":"T223","lanqiaotitle":"Anagrams问题","memorylimit":"512.0MB","tid":"ALGO-91","timelimit":"1.0s","title":"算法训练 Anagrams问题","src":"程序设计公共基础课(谌卫军)"},{"checkpoint":"数组运算","updatetime":"2014-11-27","content":"<div class='pdcont'>　　﻿<b>问题描述</b><br />\n　　编写一个程序，读入一组整数，这组整数是按照从小到大的顺序排列的，它们的个数N也是由用户输入的，最多不会超过20。然后程序将对这个数组进行统计，把出现次数最多的那个数组元素值打印出来。如果有两个元素值出现的次数相同，即并列第一，那么只打印比较小的那个值。<br />\n　　输入格式：第一行是一个整数<i>N</i>，<i>N</i> &pound; 20；接下来有<i>N</i>行，每一行表示一个整数，并且按照从小到大的顺序排列。<br />\n　　输出格式：输出只有一行，即出现次数最多的那个元素值。<br />\n<b>输入输出样例</b></div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n100<br />\n150<br />\n150<br />\n200<br />\n250</div><div class='pdsec'>样例输出</div><div class='pddata'>150</div>\n","gpid":"T222","lanqiaotitle":"出现次数最多的整数","memorylimit":"512.0MB","tid":"ALGO-90","timelimit":"1.0s","title":"算法训练 出现次数最多的整数","src":"程序设计公共基础课(谌卫军)"},{"checkpoint":"","updatetime":"2014-11-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个长度为n的字符串S，还有一个数字L，统计长度大于等于L的出现次数最多的子串（不同的出现可以相交），如果有多个，输出最长的，如果仍然有多个，输出第一次出现最早的。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个数字L。<br />\n　　第二行是字符串S。<br />\n　　L大于0，且不超过S的长度。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行，题目要求的字符串。<br />\n<br />\n　　输入样例1：<br />\n　　4<br />\n　　bbaabbaaaaa<br />\n<br />\n　　输出样例1：<br />\n　　bbaa<br />\n<br />\n　　输入样例2：<br />\n　　2<br />\n　　bbaabbaaaaa<br />\n<br />\n　　输出样例2：<br />\n　　aa</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=60<br />\n　　S中所有字符都是小写英文字母。</div><div class='pdsec'>提示</div><div class='pdcont'>　　枚举所有可能的子串，统计出现次数，找出符合条件的那个</div>\n","gpid":"T219","lanqiaotitle":"字串统计","memorylimit":"512.0MB","tid":"ALGO-87","timelimit":"1.0s","title":"算法训练 字串统计","src":""},{"checkpoint":"","updatetime":"2014-11-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输入两个矩阵，分别是m*s，s*n大小。输出两个矩阵相乘的结果。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行，空格隔开的三个正整数m,s,n（均不超过200）。<br />\n　　接下来m行，每行s个空格隔开的整数，表示矩阵A（i，j）。<br />\n　　接下来s行，每行n个空格隔开的整数，表示矩阵B（i，j）。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　m行，每行n个空格隔开的整数，输出相乘後的矩阵C（i，j）的值。</div><div class='pdsec'>样例输入</div><div class='pddata'>2 3 2<br />\n1 0 -1<br />\n1 1 -3<br />\n0 3<br />\n1 2<br />\n3 1</div><div class='pdsec'>样例输出</div><div class='pddata'>-3 2<br />\n-8 2<br />\n<br />\n<b>提示</b><br />\n矩阵C应该是m行n列，其中C(i,j)等于矩阵A第i行行向量与矩阵B第j列列向量的内积。<br />\n例如样例中C(1,1)=(1,0,-1)*(0,1,3) = 1 * 0 +0*1+(-1)*3=-3<br />\n<b> </b></div>\n","gpid":"T218","lanqiaotitle":"矩阵乘法","memorylimit":"512.0MB","tid":"ALGO-86","timelimit":"1.0s","title":"算法训练 矩阵乘法","src":""},{"checkpoint":"字符操作","updatetime":"2014-11-20","content":"<div class='pdcont'><b>问题描述</b><br />\n　　编写一个程序，输入一个字符串（长度不超过20），然后把这个字符串内的每一个字符进行大小写变换，即将大写字母变成小写，小写字母变成大写，然后把这个新的字符串输出。<br />\n　　输入格式：输入一个字符串，而且这个字符串当中只包含英文字母，不包含其他类型的字符，也没有空格。<br />\n　　输出格式：输出经过转换后的字符串。<br />\n<b>输入输出样例</b></div><div class='pdsec'>样例输入</div><div class='pddata'>AeDb</div><div class='pdsec'>样例输出</div><div class='pddata'>aEdB</div>\n","gpid":"T216","lanqiaotitle":"大小写转换","memorylimit":"512.0MB","tid":"ALGO-84","timelimit":"1.0s","title":"算法训练 大小写转换","src":"程序设计公共基础课(谌卫军)"},{"checkpoint":"","updatetime":"2014-11-13","content":"<pre class='pddata'>\n从键盘读入n个整数，使用动态数组存储所读入的整数，并计算它们的和与平均值分别输出。要求尽可能使用函数实现程序代码。平均值为小数的只保留其整数部分。\n</pre>\n<pre class='pddata'>\n样例输入: <br />5 <br />3 4 0 0 2<br />样例输出:<br />9  1\n</pre>\n<pre class='pddata'>\n样例输入: <br />7<br />3 2 7 5 2 9 1<br />样例输出:<br />29  4\n</pre>\n\n","gpid":"T205","lanqiaotitle":"动态数组使用","memorylimit":"512.0MB","tid":"ALGO-81","timelimit":"1.0s","title":"算法训练 动态数组使用","src":""},{"checkpoint":"","updatetime":"2014-11-11","content":"<pre class='pddata'>\n从键盘读入n个整数放入数组中，编写函数CompactIntegers，删除数组中所有值为0的元素，其后元素向数组首端移动。注意，CompactIntegers函数需要接受数组及其元素个数作为参数，函数返回值应为删除操作执行后数组的新元素个数。输出删除后数组中元素的个数并依次输出数组元素。\n</pre>\n<pre class='pddata'>\n样例输入: （输入格式说明：5为输入数据的个数，3 4 0 0 2 是以空格隔开的5个整数）<br />5 <br />3 4 0 0 2<br />样例输出:（输出格式说明：3为非零数据的个数，3 4 2 是以空格隔开的3个非零整数）<br />3<br />3 4 2\n</pre>\n<pre class='pddata'>\n样例输入: <br />7<br />0 0 7 0 0 9 0<br />样例输出:<br />2<br />7 9\n</pre>\n<pre class='pddata'>\n样例输入: <br />3<br />0 0 0<br />样例输出:<br />0\n</pre>\n\n","gpid":"T201","lanqiaotitle":"删除数组零元素","memorylimit":"512.0MB","tid":"ALGO-79","timelimit":"1.0s","title":"算法训练 删除数组零元素","src":""},{"checkpoint":"","updatetime":"2014-04-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给两组数，各n个。<br />\n　　请调整每组数的排列顺序，使得两组数据相同下标元素对应相乘，然后相加的和最小。要求程序输出这个最小值。<br />\n　　例如两组数分别为:1 3　　-5和-2 4 1<br />\n<br />\n　　那么对应乘积取和的最小值应为：<br />\n　　(-5) * 4 + 3 * (-2) + 1 * 1 = -25</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一个行一个数T表示数据组数。后面每组数据，先读入一个n，接下来两行每行n个数，每个数的绝对值小于等于1000。<br />\n　　n&lt;=8,T&lt;=1000</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个数表示答案。</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n2\n3\n1 3 -5\n-2 4 1\n5\n1 2 3 4 5\n1 0 1 0 1\n</PRE></FONT>\n<P></P>\n<br /></p><p class=\"subtitle\">样例输出</p><p class=\"probcontent\">\n<P><FONT face=\"Times New Roman\" size=3><PRE>-25\n6\n</PRE></FONT>\n<P></P>\n<br />\n</pre>\n\n","gpid":"T133","lanqiaotitle":"最小乘积(基本型)","memorylimit":"512.0MB","tid":"ALGO-53","timelimit":"1.0s","title":"算法训练 最小乘积(基本型)","src":""},{"checkpoint":"","updatetime":"2014-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Torry从小喜爱数学。一天，老师告诉他，像2、3、5、7……这样的数叫做质数。Torry突然想到一个问题，前10、100、1000、10000……个质数的乘积是多少呢？他把这个问题告诉老师。老师愣住了，一时回答不出来。于是Torry求助于会编程的你，请你算出前n个质数的乘积。不过，考虑到你才接触编程不久，Torry只要你算出这个数模上50000的值。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　仅包含一个正整数n，其中n&lt;=100000。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行，即前n个质数的乘积模50000的值。</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n1\n</PRE></FONT>\n<P></P>\n<br /></p><p class=\"subtitle\">样例输出</p><p class=\"probcontent\">\n<P><FONT face=\"Times New Roman\" size=3><PRE>2</PRE></FONT>\n<P></P>\n<br />\n</pre>\n\n","gpid":"T129","lanqiaotitle":"Torry的困惑(基本型)","memorylimit":"512.0MB","tid":"ALGO-51","timelimit":"1.0s","title":"算法训练 Torry的困惑(基本型)","src":""},{"checkpoint":"","updatetime":"2014-03-19","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　对于给定整数数组a[],寻找其中最大值，并返回下标。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　整数数组a[],数组元素个数小于1等于100。输出数据分作两行：第一行只有一个数，表示数组元素个数；第二行为数组的各个元素。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出最大值，及其下标</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n3\n3 2 1</PRE></FONT>\n<P></P>\n<br /></p><p class=\"subtitle\">样例输出</p><p class=\"probcontent\">\n<P><FONT face=\"Times New Roman\" size=3><PRE>3 0</PRE></FONT>\n<P></P>\n<br />\n</pre>\n\n","gpid":"T111","lanqiaotitle":"寻找数组中最大值","memorylimit":"512.0MB","tid":"ALGO-49","timelimit":"1.0s","title":"算法训练 寻找数组中最大值","src":""},{"checkpoint":"","updatetime":"2014-03-19","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有一个n个结点m条边的有向图，请输出他的关联矩阵。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行两个整数n、m，表示图中结点和边的数目。n&lt;=100,m&lt;=1000。<br />\n　　接下来m行，每行两个整数a、b，表示图中有(a,b)边。<br />\n　　注意图中可能含有重边，但不会有自环。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出该图的关联矩阵，注意请勿改变边和结点的顺序。</div><div class='pdsec'>样例输入</div><div class='pddata'>5 9<br />\n1 2<br />\n3 1<br />\n1 5<br />\n2 5<br />\n2 3<br />\n2 3<br />\n3 2<br />\n4 3<br />\n5 4</div><div class='pdsec'>样例输出</div><div class='pddata'>1 -1 1 0 0 0 0 0 0<br />\n-1 0 0 1 1 1 -1 0 0<br />\n0 1 0 0 -1 -1 1 -1 0<br />\n0 0 0 0 0 0 0 1 -1<br />\n0 0 -1 -1 0 0 0 0 1</div>\n","gpid":"T110","lanqiaotitle":"关联矩阵","memorylimit":"512.0MB","tid":"ALGO-48","timelimit":"1.0s","title":"算法训练 关联矩阵","src":""},{"checkpoint":"","updatetime":"2014-02-28","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　这题想得分吗？想，请输出“yes”；不想，请输出“no”。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出包括一行，为“yes”或“no”。</div>\n","gpid":"T106","lanqiaotitle":"送分啦","memorylimit":"512.0MB","tid":"ALGO-42","timelimit":"1.0s","title":"算法训练 送分啦","src":""},{"checkpoint":"线段树","updatetime":"2013-10-16","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n\t<p>有n个格子，从左到右放成一排，编号为1-n。</p>\n\t<p>共有m次操作，有3种操作类型：</p>\n\t<p>1.修改一个格子的权值，</p>\n\t<p>2.求连续一段格子权值和，</p>\n\t<p>3.求连续一段格子的最大值。</p>\n\t<p>对于每个2、3操作输出你所求出的结果。</p>\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\t<p>第一行2个整数n，m。</p>\n\t<p>接下来一行n个整数表示n个格子的初始权值。</p>\n\t<p>接下来m行，每行3个整数p,x,y，p表示操作类型，p=1时表示修改格子x的权值为y，p=2时表示求区间[x,y]内格子权值和，p=3时表示求区间[x,y]内格子最大的权值。</p>\n</div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\t<p>有若干行，行数等于p=2或3的操作总数。</p>\n\t<p>每行1个整数，对应了每个p=2或3操作的结果。</p>\n</div>\n<div class=\"sec_header\">\n样例输入</div>\n<div class=\"sec_text\">\n4 3<br />\n1 2 3 4<br />\n2 1 3<br />\n1 4 3<br />\n3 1 4\n</div>\n<div class=\"sec_header\">\n样例输出</div>\n<div class=\"sec_text\">\n6<br />\n3\n\t</div>\n<div class=\"sec_header\">\n数据规模与约定</div>\n<div class=\"sec_cont\">\n\t<p>对于20%的数据n &lt;= 100，m &lt;= 200。</p>\n\t<p>对于50%的数据n &lt;= 5000，m &lt;= 5000。</p>\n\t<p>对于100%的数据1 &lt;= n &lt;= 100000，m &lt;= 100000，0 &lt;= 格子权值 &lt;= 10000。</p>\n</div>\n","gpid":"T18","lanqiaotitle":"操作格子","memorylimit":"256.0MB","tid":"ALGO-8","timelimit":"1.0s","title":"算法训练 操作格子","src":""},{"checkpoint":"平衡二叉树","updatetime":"2013-10-16","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n<p>Alice是一个让人非常愉跃的人!他总是去学习一些他不懂的问题，然后再想出许多稀奇古怪的题目。这几天，Alice又沉浸在逆序对的快乐当中，他已近学会了如何求逆序对对数，动态维护逆序对对数等等题目，他认为把这些题让你做简直是太没追求了，于是，经过一天的思考和完善，Alice终于拿出了一道他认为差不多的题目：</p>\n<p>有一颗2n-1个节点的二叉树，它有恰好n个叶子节点，每个节点上写了一个整数。如果将这棵树的所有叶子节点上的数从左到右写下来，便得到一个序列a[1]…a[n]。现在想让这个序列中的逆序对数量最少，但唯一的操作就是选树上一个非叶子节点，将它的左右两颗子树交换。他可以做任意多次这个操作。求在最优方案下，该序列的逆序对数最少有多少。</p>\n<p>Alice自己已近想出了题目的正解，他打算拿来和你分享，他要求你在最短的时间内完成。</p>\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n<p>第一行一个整数n。</p>\n<p>下面每行，一个数x。</p>\n<p>如果x=0，表示这个节点非叶子节点，递归地向下读入其左孩子和右孩子的信息，如果x≠0，表示这个节点是叶子节点，权值为x。</p>\n</div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\t输出一个整数，表示最少有多少逆序对。\n</div>\n<div class=\"sec_header\">\n样例输入</div>\n<div class=\"sec_text\">\n3<br />\n0<br />\n0<br />\n3<br />\n1<br />\n2\n</div>\n<div class=\"sec_header\">\n样例输出</div>\n<div class=\"sec_text\">\n1\n\t</div>\n<div class=\"sec_header\">\n数据规模与约定</div>\n<div class=\"sec_cont\">\n<p>对于20%的数据，n &lt;= 5000。</p>\n<p>对于100%的数据，1 &lt;= n &lt;= 200000，0 &lt;= a[i]&lt;2^31。</p>\n</div>\n","gpid":"T17","lanqiaotitle":"逆序对","memorylimit":"256.0MB","tid":"ALGO-7","timelimit":"1.0s","title":"算法训练 逆序对","src":""},{"checkpoint":"最小生成树","updatetime":"2013-10-16","content":"<div class=\"sec_header\">问题描述</div>\n<div class=\"sec_cont\">\n<p>Farmer John变得非常懒，他不想再继续维护供奶牛之间供通行的道路。道路被用来连接N个牧场，牧场被连续地编号为1到N。每一个牧场都是一个奶牛的家。FJ计划除去P条道路中尽可能多的道路，但是还要保持牧场之间 的连通性。你首先要决定那些道路是需要保留的N-1条道路。第j条双向道路连接了牧场S<sub>j</sub>和E<sub>j</sub>(1 &lt;= S<sub>j</sub> &lt;= N; 1 &lt;= E<sub>j</sub> &lt;= N; S<sub>j</sub> != E<sub>j</sub>)，而且走完它需要L<sub>j</sub>的时间。没有两个牧场是被一条以上的道路所连接。奶牛们非常伤心，因为她们的交通系统被削减了。你需要到每一个奶牛的住处去安慰她们。每次你到达第i个牧场的时候(即使你已经到过)，你必须花去C<sub>i</sub>的时间和奶牛交谈。你每个晚上都会在同一个牧场(这是供你选择的)过夜，直到奶牛们都从悲伤中缓过神来。在早上 起来和晚上回去睡觉的时候，你都需要和在你睡觉的牧场的奶牛交谈一次。这样你才能完成你的 交谈任务。假设Farmer John采纳了你的建议，请计算出使所有奶牛都被安慰的最少时间。</p>\n</div>\n<div class=\"sec_header\">输入格式</div>\n<div class=\"sec_cont\">\n<p>第1行包含两个整数N和P。</p>\n<p>接下来N行，每行包含一个整数C<sub>i</sub>。</p>\n<p>接下来P行，每行包含三个整数S<sub>j</sub>, E<sub>j</sub>和L<sub>j</sub>。</p>\n</div>\n<div class=\"sec_header\">输出格式</div>\n<div class=\"sec_cont\">输出一个整数, 所需要的总时间(包含和在你所在的牧场的奶牛的两次谈话时间)。</div>\n<div class=\"sec_header\">样例输入</div>\n<div class=\"sec_text\">5 6<br />\n10<br />\n10<br />\n20<br />\n6<br />\n30<br />\n1 2 5<br />\n2 3 5<br />\n2 4 12<br />\n3 4 17<br />\n2 5 15<br />\n3 5 6</div>\n<div class=\"sec_header\">样例输出</div>\n<div class=\"sec_text\">176</div>\n<div class=\"sec_header\">数据规模与约定</div>\n<div class=\"sec_cont\">\n<p>5 &lt;= N &lt;= 10000，N-1 &lt;= P &lt;= 100000，0 &lt;= L<sub>j</sub> &lt;= 1000，1 &lt;= C<sub>i</sub> &lt;= 1,000。</p>\n</div>","gpid":"T16","lanqiaotitle":"安慰奶牛","memorylimit":"256.0MB","tid":"ALGO-6","timelimit":"1.0s","title":"算法训练 安慰奶牛","src":""},{"checkpoint":"最短路","updatetime":"2013-10-16","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n\t<p>给定一个n个顶点，m条边的有向图（其中某些边权可能为负，但保证没有负环）。请你计算从1号点到其他点的最短路（顶点从1到n编号）。</p>\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\t<p>第一行两个整数n, m。</p>\n\t<p>接下来的m行，每行有三个整数u, v, l，表示u到v有一条长度为l的边。</p>\n</div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\t共n-1行，第i行表示1号点到i+1号点的最短路。\n</div>\n<div class=\"sec_header\">\n样例输入</div>\n<div class=\"sec_text\">\n3 3<br />\n1 2 -1<br />\n2 3 -1<br />\n3 1 2\t\n\n</div>\n<div class=\"sec_header\">\n样例输出</div>\n<div class=\"sec_text\">\n-1<br />\n-2\n\n\t</div>\n<div class=\"sec_header\">\n数据规模与约定</div>\n<div class=\"sec_cont\">\n<p>对于10%的数据，n = 2，m = 2。</p>\n<p>对于30%的数据，n &lt;= 5，m &lt;= 10。</p>\n<p>对于100%的数据，1 &lt;= n &lt;= 20000，1 &lt;= m &lt;= 200000，-10000 &lt;= l &lt;= 10000，保证从任意顶点都能到达其他所有顶点。</p>\n</div>\n","gpid":"T15","lanqiaotitle":"最短路","memorylimit":"256.0MB","tid":"ALGO-5","timelimit":"1.0s","title":"算法训练 最短路","src":""},{"checkpoint":"树形动态规划","updatetime":"2013-10-16","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n\t<p>有一棵 n 个节点的树，树上每个节点都有一个正整数权值。如果一个点被选择了，那么在树上和它相邻的点都不能被选择。求选出的点的权值和最大是多少？</p>\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\t<p>第一行包含一个整数 n 。</p>\n\t<p>接下来的一行包含 n 个正整数，第 i 个正整数代表点 i 的权值。</p>\n\t<p>接下来一共 n-1 行，每行描述树上的一条边。</p>\n</div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\t输出一个整数，代表选出的点的权值和的最大值。\n</div>\n<div class=\"sec_header\">\n样例输入</div>\n<div class=\"sec_text\">\n5<br />\n1 2 3 4 5<br />\n1 2<br />\n1 3<br />\n2 4<br />\n2 5\n</div>\n<div class=\"sec_header\">\n样例输出</div>\n<div class=\"sec_text\">\n12\n\t</div>\n<div class=\"sec_header\">\n样例说明</div>\n<div class=\"sec_cont\">\n选择3、4、5号点，权值和为 3+4+5 = 12 。\n</div>\n<div class=\"sec_header\">\n数据规模与约定</div>\n<div class=\"sec_cont\">\n<p>对于20%的数据， n &lt;= 20。</p>\n<p>对于50%的数据， n &lt;= 1000。</p>\n<p>对于100%的数据， n &lt;= 100000。</p>\n<p>权值均为不超过1000的正整数。</p>\n</div>\n","gpid":"T14","lanqiaotitle":"结点选择","memorylimit":"256.0MB","tid":"ALGO-4","timelimit":"1.0s","title":"算法训练 结点选择","src":""},{"checkpoint":"动态规划","updatetime":"2013-10-16","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n\t<p>如果一个自然数N的K进制表示中任意的相邻的两位都不是相邻的数字，那么我们就说这个数是K好数。求L位K进制数中K好数的数目。例如K = 4，L = 2的时候，所有K好数为11、13、20、22、30、31、33 共7个。由于这个数目很大，请你输出它对1000000007取模后的值。</p>\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\t<p>输入包含两个正整数，K和L。</p>\n</div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\t输出一个整数，表示答案对1000000007取模后的值。\n</div>\n<div class=\"sec_header\">\n样例输入</div>\n<div class=\"sec_text\">\n4 2\n</div>\n<div class=\"sec_header\">\n样例输出</div>\n<div class=\"sec_text\">\n7\n\t</div>\n<div class=\"sec_header\">\n数据规模与约定</div>\n<div class=\"sec_cont\">\n<p>对于30%的数据，K<sup>L</sup> &lt;= 10<sup>6</sup>；</p>\n<p>对于50%的数据，K &lt;= 16， L &lt;= 10；</p>\n<p>对于100%的数据，1 &lt;= K,L &lt;= 100。</p>\n</div>\n","gpid":"T13","lanqiaotitle":"K好数","memorylimit":"256.0MB","tid":"ALGO-3","timelimit":"1.0s","title":"算法训练 K好数","src":""},{"checkpoint":"贪心","updatetime":"2013-10-16","content":"<div class=\"sec_header\">问题描述</div>\n<div class=\"sec_cont\">\n<p>已知一个正整数N，问从1~N中任选出三个数，他们的最小公倍数最大可以为多少。</p>\n</div>\n<div class=\"sec_header\">输入格式</div>\n<div class=\"sec_cont\">\n<p>输入一个正整数N。</p>\n</div>\n<div class=\"sec_header\">输出格式</div>\n<div class=\"sec_cont\">输出一个整数，表示你找到的最小公倍数。</div>\n<div class=\"sec_header\">样例输入</div>\n<div class=\"sec_text\">9</div>\n<div class=\"sec_header\">样例输出</div>\n<div class=\"sec_text\">504</div>\n<div class=\"sec_header\">数据规模与约定</div>\n<div class=\"sec_cont\">\n<p>1 &lt;= N &lt;= 10<sup>6</sup>。</p>\n</div>","gpid":"T12","lanqiaotitle":"最大最小公倍数","memorylimit":"256.0MB","tid":"ALGO-2","timelimit":"1.0s","title":"算法训练 最大最小公倍数","src":""},{"checkpoint":"排序 查找","updatetime":"2013-10-16","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n\t<p>给定一个序列，每次询问序列中第l个数到第r个数中第K大的数是哪个。</p>\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\t<p>第一行包含一个数n，表示序列长度。</p>\n\t<p>第二行包含n个正整数，表示给定的序列。</p>\n\t<p>第三个包含一个正整数m，表示询问个数。</p>\n<p>接下来m行，每行三个数l,r,K，表示询问序列从左往右第l个数到第r个数中，从大往小第K大的数是哪个。序列元素从1开始标号。</p>\n</div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\t总共输出m行，每行一个数，表示询问的答案。\n</div>\n<div class=\"sec_header\">\n样例输入</div>\n<div class=\"sec_text\">\n5<br />\n1 2 3 4 5<br />\n2<br />\n1 5 2<br />\n2 3 2\n</div>\n<div class=\"sec_header\">\n样例输出</div>\n<div class=\"sec_text\">\n4<br />\n2\n\t</div>\n<div class=\"sec_header\">\n数据规模与约定</div>\n<div class=\"sec_cont\">\n<p>对于30%的数据，n,m&lt;=100；</p>\n<p>对于100%的数据，n,m&lt;=1000；</p>\n<p>保证k&lt;=(r-l+1)，序列中的数&lt;=10<sup>6</sup>。</p>\n</div>\n","gpid":"T11","lanqiaotitle":"区间k大数查询","memorylimit":"256.0MB","tid":"ALGO-1","timelimit":"1.0s","title":"算法训练 区间k大数查询","src":""},{"checkpoint":"","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给出N个数字，求出有最大的最大质因数的那个数</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行：一个整数N。<br />\n　　接下来的N行，每行一个整数A_i，表示给出的那N个数字。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第一行：一个整数，拥有最大的最大质因数的那个数。</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\n36<br />\n38<br />\n40<br />\n42</div><div class='pdsec'>样例输出</div><div class='pddata'>38</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　60%的数据满足：N&lt;=100<br />\n　　100%的数据满足：N&lt;=2500,A_i&lt;=20000</div>\n","gpid":"T746","lanqiaotitle":"最大质因数","memorylimit":"256.0MB","tid":"ALGO-331","timelimit":"1.0s","title":"算法训练 最大质因数","src":""},{"checkpoint":"","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给出n个圆，请你求出它们面积的并</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个整数n，表示圆的个数<br />\n　　下面n行，每行三个实数x，y，r<br />\n　　代表每个圆的坐标和半径</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个实数，表示圆面积的并（保留两位小数）</div><div class='pdsec'>样例输入</div><div class='pddata'>1<br />\n0 0 1</div><div class='pdsec'>样例输出</div><div class='pddata'>3.14</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　不会很大的</div>\n","gpid":"T745","lanqiaotitle":"圆的并","memorylimit":"256.0MB","tid":"ALGO-330","timelimit":"3.0s","title":"算法训练 圆的并","src":"WYF"},{"checkpoint":"邻接表","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　没有问题描述。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含两个整数n, m<br />\n　　n代表图中的点的个数，m代表边的个数<br />\n　　接下来m行，每行2个正整数，表示图中连通的两点。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出1个数，与1连通的点的个数。</div><div class='pdsec'>样例输入</div><div class='pddata'>6 3<br />\n1 2<br />\n2 3<br />\n3 4</div><div class='pdsec'>样例输出</div><div class='pddata'>4</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=10000,m&lt;=100000。</div>\n","gpid":"T744","lanqiaotitle":"与1连通的点的个数","memorylimit":"256.0MB","tid":"ALGO-329","timelimit":"1.0s","title":"算法训练 与1连通的点的个数","src":"qq"},{"checkpoint":"","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　对一个字符串中的所有单词，如果单词的首字母不是大写字母，则把单词的首字母变成大写字母。在字符串中，单词之间通过空白符分隔，空白符包括：空格(' ')、制表符('\\t')、回车符('\\r')、换行符('\\n')</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入一行：待处理的字符串（长度小于80）</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行：转换后的字符串。</div><div class='pdsec'>样例输入</div><div class='pddata'>if so, you already have a google account. you can sign in on the right.</div><div class='pdsec'>样例输出</div><div class='pddata'>If So, You Already Have A Google Account. You Can Sign In On The Right.</div>\n","gpid":"T743","lanqiaotitle":"首字母变大写","memorylimit":"512.0MB","tid":"ALGO-328","timelimit":"1.0s","title":"算法训练 首字母变大写","src":""},{"checkpoint":"取余 数字字符混合输出","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个以秒为单位的时间t，要求用“&lt;H&gt;:&lt;M&gt;:&lt;S&gt;”的格式来表示这个时间。&lt;H&gt;表示时间，&lt;M&gt;表示分钟，而&lt;S&gt;表示秒，它们都是整数且没有前导的“0”。例如，若t=0，则应输出是“0:0:0”；若t=3661，则输出“1:1:1”。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入只有一行，是一个整数t（0&lt;=t&lt;=86399）。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出只有一行，是以“&lt;H&gt;:&lt;M&gt;:&lt;S&gt;”的格式所表示的时间，不包括引号。</div><div class='pdsec'>样例输入</div><div class='pddata'>0</div><div class='pdsec'>样例输出</div><div class='pddata'>0:0:0</div><div class='pdsec'>样例输入</div><div class='pddata'>5436</div><div class='pdsec'>样例输出</div><div class='pddata'>1:30:36</div>\n","gpid":"T742","lanqiaotitle":"时间转换","memorylimit":"512.0MB","tid":"ALGO-327","timelimit":"1.0s","title":"算法训练 时间转换","src":""},{"checkpoint":"","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编写递归函数，实现将一个十进制的正整数以二进制的形式输出。<br />\n　　注：不考虑符号位，仅从二进制数不为0的最高位开始输出。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一个十进制正整数</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　该整数对应的二进制数</div><div class='pdsec'>样例输入</div><div class='pddata'>一个满足题目要求的输入范例。<br />\n例：<br />\n96</div><div class='pdsec'>样例输出</div><div class='pddata'>与上面的样例输入对应的输出。<br />\n例：<br />\n<b>1100000</b></div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入为正整数</div>\n","gpid":"T741","lanqiaotitle":"十进制转2进制输出","memorylimit":"256.0MB","tid":"ALGO-326","timelimit":"1.0s","title":"算法训练 十进制转2进制输出","src":""},{"checkpoint":"","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　石头剪刀布是常见的猜拳游戏：石头胜剪刀，剪刀胜布，布胜石头。如果两个人出拳一样，则不分胜负。在《生活大爆炸》第二季第8集中出现了一种石头剪刀布的升级版游戏。升级版游戏在传统的石头剪刀布游戏的基础上，增加了两个新手势：<br />\n　　斯波克：《星际迷航》主角之一。<br />\n　　蜥蜴人：《星际迷航》中的反面角色。<br />\n　　这五种手势的胜负关系如表一所示，表中列出的是甲对乙的游戏结果。<br />\n<img src=\"/RequireFile.do?fid=Gb5JJMGj\" width=\"607\" height=\"203\" /><br />\n　　现在，小A和小B尝试玩这种升级版的猜拳游戏。已知他们的出拳都是有周期性规律的，但周期长度不一定相等。例如：如果小A以“石头-布-石头-剪刀-蜥蜴人-斯波克”长度为6的周期出拳，那么他的出拳序列就是“石头-布-石头-剪刀-蜥蜴人-斯波克-石头-布-石头-剪刀-蜥蜴人-斯波克-……”，而如果小B以“剪刀-石头-布-斯波克-蜥蜴人”长度为5的周期出拳，那么他出拳的序列就是“剪刀-石头-布-斯波克-蜥蜴人-剪刀-石头-布-斯波克-蜥蜴人-……”<br />\n　　已知小A和小B一共进行N次猜拳。每一次赢的人得1分，输的得0分；平局两人都得0分。现请你统计N次猜拳结束之后两人的得分。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含三个整数：N，NA，NB，分别表示共进行N次猜拳、小A出拳的周期长度，小B出拳的周期长度。数与数之间以一个空格分隔。<br />\n　　第二行包含NA个整数，表示小A出拳的规律，第三行包含NB个整数，表示小B出拳的规律。其中，0表示“剪刀”，1表示“石头”，2表示“布”，3表示“蜥蜴人”， 4表示“斯波克”。数与数之间以一个空格分隔。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行， 包含两个整数，以一个空格分隔，分别表示小A、小B的得分。</div><div class='pdsec'>样例输入</div><div class='pddata'>10 5 6<br />\n0 1 2 3 4<br />\n0 3 4 2 1 0</div><div class='pdsec'>样例输出</div><div class='pddata'>6 2</div><div class='pdsec'>样例输入</div><div class='pddata'>9 5 5<br />\n0 1 2 3 4<br />\n1 0 3 2 4</div><div class='pdsec'>样例输出</div><div class='pddata'>4 4</div><div class='pdsec'>数据说明</div><div class='pdcont'>　　对于100%的数据，0 &lt; N ≤ 200，0 &lt; NA ≤ 200， 0 &lt; NB ≤ 200。</div>\n","gpid":"T740","lanqiaotitle":"生活大爆炸版石头剪刀布","memorylimit":"128.0MB","tid":"ALGO-325","timelimit":"1.0s","title":"算法训练 生活大爆炸版石头剪刀布","src":"NOIP2014 提高组 day1"},{"checkpoint":"循环","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有一个数列，它的第一项是1，第二项是2，第三项是第一项与第二项的和，后面的项依次类推，即F（1）=1，F（2）=2，F（n）=F(n-1)+F(n-2)（n≥3，n∈N*）</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　无</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出20行，每行一个数值，表示数列第几项的值。（注意不要输出多余的字符）</div>\n","gpid":"T739","lanqiaotitle":"求数列的项","memorylimit":"256.0MB","tid":"ALGO-324","timelimit":"1.0s","title":"算法训练 求数列的项","src":""},{"checkpoint":"循环","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　如果一个数恰好等于它的所有因子（包括1但不包括自身）之和，则称之为“完数”。例如6的因子是1，2，3，且6=1+2+3，因此6是完数。编写程序找出1000之内的所有完数。注意1不是完数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　无</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　如有多个完数，则分行输出，每行输出一个完数。（注意，不要输出其他任何多余字符）</div>\n","gpid":"T738","lanqiaotitle":"求1000以内的完数","memorylimit":"256.0MB","tid":"ALGO-323","timelimit":"1.0s","title":"算法训练 求1000以内的完数","src":""},{"checkpoint":"求和","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有一个数x，求从1加到x的值</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入一行，一个数x。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出1行，从一加到x的值</div><div class='pdsec'>样例输入</div><div class='pddata'>10</div><div class='pdsec'>样例输出</div><div class='pddata'>55</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1＜x＜10000</div>\n","gpid":"T737","lanqiaotitle":"求1加到x的和(number)","memorylimit":"400.0MB","tid":"ALGO-322","timelimit":"1.0s","title":"算法训练 求1加到x的和(number)","src":""},{"checkpoint":"","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编写程序，输入月份，输出该月包含的天数，例如1月有31天（设定年份为2015年）</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一个整数：月份</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个整数：该月的天数</div><div class='pdsec'>样例输入</div><div class='pddata'>1</div><div class='pdsec'>样例输出</div><div class='pddata'>31</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入数据在1~12之间（包含1、12）</div>\n","gpid":"T736","lanqiaotitle":"每月的天数","memorylimit":"512.0MB","tid":"ALGO-321","timelimit":"1.0s","title":"算法训练 每月的天数","src":""},{"checkpoint":"","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编写一个程序，输入两个正整数min和max（min肯定小于或等于max且                                                  ），然后计算这两个整数之间的所有整数（包括min和max）的平方和。例如，假设用户输入的是2和5，则计算结果为:2<sup>2</sup>+3<sup>2</sup>+4<sup>2</sup>+5<sup>2</sup>=54。（注：引自课本第五章第8题）</div><div class='pdsec'>样例输入</div><div class='pddata'>2 5</div><div class='pdsec'>样例输出</div><div class='pddata'>54</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=min&lt;=max&lt;=1000。</div>\n","gpid":"T735","lanqiaotitle":"连续平方和","memorylimit":"256.0MB","tid":"ALGO-320","timelimit":"1.0s","title":"算法训练 连续平方和","src":""},{"checkpoint":"循环","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　设计一个程序，求一个4*4矩阵（四行四列的整数阵列）的两对角线元素这和。（矩阵的每个元素都是整数）</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入为4行，每行为4个整数</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出为一个数，表示矩阵的两对角线元素之和。（注意不要输出除结果之外的其他任何字符）</div><div class='pdsec'>样例输入</div><div class='pddata'>例：<br />\n1 2 3 4<br />\n5 6 7 8<br />\n9 10 11 12<br />\n13 14 15 16</div><div class='pdsec'>样例输出</div><div class='pddata'>例：<br />\n68</div>\n","gpid":"T734","lanqiaotitle":"矩阵对角线元素之和","memorylimit":"256.0MB","tid":"ALGO-319","timelimit":"1.0s","title":"算法训练 矩阵对角线元素之和","src":""},{"checkpoint":"","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　当x&gt;1时，Hermite多项式的定义见第二版教材125页。用户输入x和n，试编写“非递归”函数，输出对应的Hermite多项式的值。其中x为float型，n为int型。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　x n</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对应多项式的值</div><div class='pdsec'>样例输入</div><div class='pddata'>一个满足题目要求的输入范例。<br />\n例：<br />\n3.6 4</div><div class='pdsec'>样例输出</div><div class='pddata'>与上面的样例输入对应的输出。<br />\n例：<br />\n2077.31</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　x&gt;1<br />\n　　n为自然数</div>\n","gpid":"T733","lanqiaotitle":"非递归","memorylimit":"256.0MB","tid":"ALGO-318","timelimit":"1.0s","title":"算法训练 非递归","src":""},{"checkpoint":"","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Flappy Bird 是一款风靡一时的休闲手机游戏。玩家需要不断控制点击手机屏幕的频率来调节小鸟的飞行高度，让小鸟顺利通过画面右方的管道缝隙。如果小鸟一不小心撞到了水管或者掉在地上的话，便宣告失败。<br />\n　　为了简化问题，我们对游戏规则进行了简化和改编：<br />\n　　1. 游戏界面是一个长为n，高为m的二维平面，其中有 k个管道（忽略管道的宽度）。<br />\n　　2. 小鸟始终在游戏界面内移动。小鸟从游戏界面最左边 任意整数高度位置出发，到达游戏界面最右边时，游戏完成。<br />\n　　3. 小鸟每个单位时间沿横坐标方向右移的距离为1，竖直移动的距离由玩家控制。如 果点击屏幕，小鸟就会上升一定高度X，每个单位时间可以点击多次，效果叠加；如果不点击屏幕，小鸟就会下降一定高度Y。小鸟位于横坐标方向不同位置时，上升的高度X和下降的高度Y可能互不相同。<br />\n　　4. 小鸟高度等于0或者小鸟碰到管道时，游戏失败。小鸟高度为m时，无法再上升。<br />\n　　现在，请你判断是否可以完成游戏。如果可以，输出最少点击屏幕数；否则，输出小鸟最多可以通过多少个管道缝隙。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第1行有3个整数n，m，k，分别表示游戏界面的长度，高度和水管的数量，每两个整数之间用一个空格隔开；<br />\n　　接下来的n行，每行2个用一个空格隔开的整数X和Y，依次表示在横坐标位置0~n-1上玩家点击屏幕后，小鸟在下一位置上升的高度X，以及在这个位置上玩家不点击屏幕时，小鸟在下一位置下降的高度Y。<br />\n　　接下来k行，每行3个整数P，L，H，每两个整数之间用一个空格隔开。每行表示一个管道，其中P表示管道的横坐标，L表示此管道缝隙的下边沿高度为L，H表示管道缝隙上边沿的高度（输入数据保证P各不相同，但不保证按照大小顺序给出）。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出共两行。<br />\n　　第一行，包含一个整数，如果可以成功完成游戏，则输出1，否则输出0。<br />\n　　第二行，包含一个整数，如果第一行为1，则输出成功完成游戏需要最少点击屏幕数，否则，输出小鸟最多可以通过多少个管道缝隙。</div><div class='pdsec'>样例输入</div><div class='pddata'>10 10 6<br />\n3 9<br />\n9 9<br />\n1 2<br />\n1 3<br />\n1 2<br />\n1 1<br />\n2 1<br />\n2 1<br />\n1 6<br />\n2 2<br />\n1 2 7<br />\n5 1 5<br />\n6 3 5<br />\n7 5 8<br />\n8 7 9<br />\n9 1 3</div><div class='pdsec'>样例输出</div><div class='pddata'>1 6</div><div class='pdsec'>样例输入</div><div class='pddata'>10 10 4<br />\n1 2<br />\n3 1<br />\n2 2<br />\n1 8<br />\n1 8<br />\n3 2<br />\n2 1<br />\n2 1<br />\n2 2<br />\n1 2<br />\n1 0 2<br />\n6 7 9<br />\n9 1 4<br />\n3 8 10</div><div class='pdsec'>样例输出</div><div class='pddata'>0 3</div><div class='pdsec'>输入输出样例说明</div><div class='pdcont'>　　如下图所示，蓝色直线表示小鸟的飞行轨迹，红色直线表示管道。<br />\n<img src=\"/RequireFile.do?fid=deM3Hdqg\" width=\"565\" height=\"228\" /></div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于30%的数据：5≤n≤10，5≤m≤10，k=0，保证存在一组最优解使得同一单位时间最多点击屏幕3次；<br />\n　　对于50%的数据：5≤n≤20，5≤m≤10，保证存在一组最优解使得同一单位时间最多点击屏幕3次；<br />\n　　对于70%的数据：5≤n≤1000，5≤m≤100；<br />\n　　对于100%的数据：5≤n≤10000，5≤m≤1000，0≤k&lt;n，0&lt;X&lt;m，0&lt;Y&lt;m，0&lt;P&lt;n，0≤L&lt;H≤m， L+1&lt;H。</div>\n","gpid":"T732","lanqiaotitle":"飞扬的小鸟","memorylimit":"128.0MB","tid":"ALGO-317","timelimit":"1.0s","title":"算法训练 飞扬的小鸟","src":"NOIP2014 提高组 day1"},{"checkpoint":"字符串处理","updatetime":"2020-04-24","content":"<div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包括一个英语句子。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　按单词的顺序把单词倒序输出</div><div class='pdsec'>样例输入</div><div class='pddata'>I love you</div><div class='pdsec'>样例输出</div><div class='pddata'>you love I</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　简单的字符串操作</div>\n","gpid":"T731","lanqiaotitle":"单词翻转","memorylimit":"256.0MB","tid":"ALGO-316","timelimit":"1.0s","title":"算法训练 单词翻转","src":""},{"checkpoint":"期中考试","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输入两个整数，判断第一个数能否被第二个数整除（即第一个数除第二个数能否除尽），如果能够除尽，输出1，否则输出0.</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入两个整数，第一个数表示被除数，第二个数表示除数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出是否能整除，能输出1，不能则输出0。</div><div class='pdsec'>样例输入</div><div class='pddata'>24  12</div><div class='pdsec'>样例输出</div><div class='pddata'>1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入的两个数均为整数。</div>\n","gpid":"T730","lanqiaotitle":"除法运算","memorylimit":"256.0MB","tid":"ALGO-315","timelimit":"1.0s","title":"算法训练 除法运算","src":""},{"checkpoint":"","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有n*n的方格，其中有m个障碍，第i个障碍会消耗你p[i]点血。初始你有C点血，你需要从（1,1）到（n,n），并保证血量大于0，求最小步数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行3个整数n,m,c，表示棋盘大小、障碍数量和你的血量<br />\n　　接下来m行，每行描述一个障碍。包含三个整数x y p，分别表示障碍在第x行第y列，消耗血量为p。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　如果可以到输出步数，如果不可以，输出\"No\"。</div><div class='pdsec'>样例输入</div><div class='pddata'>10 10 10<br />\n2 8 35<br />\n1 10 25<br />\n9 9 63<br />\n5 6 46<br />\n2 6 43<br />\n8 7 92<br />\n5 3 54<br />\n3 3 22<br />\n7 9 96<br />\n9 10 13</div><div class='pdsec'>样例输出</div><div class='pddata'>18</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入数据中每一个数的范围。<br />\n　　0&lt;n,m&lt;100,</div>\n","gpid":"T729","lanqiaotitle":"步与血","memorylimit":"256.0MB","tid":"ALGO-314","timelimit":"1.0s","title":"算法训练 步与血","src":""},{"checkpoint":"","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　现有n个同学站成一圈，顺时针编号1至n。从1号同学开始顺时针1/2报数，报到1的同学留在原地，报到2的同学退出圆圈，直到只剩一名同学为止。问最后剩下的同学编号。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　仅一行，一个正整数n。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　仅一行，一个正整数。</div><div class='pdsec'>样例输入</div><div class='pddata'>400</div><div class='pdsec'>样例输出</div><div class='pddata'>289</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=2000000</div>\n","gpid":"T728","lanqiaotitle":"报数","memorylimit":"64.0MB","tid":"ALGO-313","timelimit":"1.0s","title":"算法训练 报数","src":""},{"checkpoint":"-2进制","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给出1个十进制整数N，计算出它的-2进制表示。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行：一个整数N，表示要转换的十进制数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第一行：N的-2进制表示。</div><div class='pdsec'>样例输入</div><div class='pddata'>-13</div><div class='pdsec'>样例输出</div><div class='pddata'>110111</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　100%的数据满足:|n|&lt;=2000000000。</div><div class='pdsec'>提示</div><div class='pdcont'>　　负二进制：<br />\n　　有这样一个数100110，它是-2进制的数，将它转换成10进制数的方法是1*(-2)5 + 0*(-2)4 + 0*(-2)3 + 1*(-2)2 + 1*(-2)1 + 0*(-2)0 等于-30。<br />\n<br />\n　　110111转换为负二进制数为：1*(-2)5 + 1*(-2)4 + 0*(-2)3 + 1*(-2)2 + 1*(-2)1 + 1*(-2)0 等于-13<br />\n<br />\n　　在-2进制数中，每个位置上的数字只能是0或1。可以证明，每一个10进制数都可以表示成-2进制数，而且表示方式是唯一的。</div>\n","gpid":"T727","lanqiaotitle":"-2进制","memorylimit":"256.0MB","tid":"ALGO-312","timelimit":"1.0s","title":"算法训练 -2进制","src":""},{"checkpoint":"","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个n节点m边的无圈且连通的图，求直径</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行两个数字n,m<br />\n　　接下来m行每行两个数字x,y,代表x,y之间有一条边</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　要求用户的输出满足的格式。<br />\n　　例：输出1行，包含一个整数，表示矩阵中所有元素的和。</div><div class='pdsec'>样例输入</div><div class='pddata'>一个满足题目要求的输入范例。<br />\n3 2<br />\n1 2<br />\n2 3</div><div class='pdsec'>样例输出</div><div class='pddata'>与上面的样例输入对应的输出。<br />\n例：<br />\n2</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　数据不会很大<br />\n　　输入数据满足M=N-1</div>\n","gpid":"T718","lanqiaotitle":"无权最长链","memorylimit":"128.0MB","tid":"ALGO-311","timelimit":"1.0s","title":"算法训练 无权最长链","src":"TTR"},{"checkpoint":"","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输入一段英文，不含标点，将这一段英文以单词为单位倒序输出</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一段英文（段内不含换行），以换行符结尾。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一段英文（段内不含换行），以换行符结尾。</div><div class='pdsec'>样例输入</div><div class='pddata'>aab TTR bbc loV DDE Znr CCD</div><div class='pdsec'>样例输出</div><div class='pddata'>CCD Znr DDE loV bbc TTR aab</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　60%的数据保证单词长度不超过20，字符长度不超过10^3<br />\n　　100%的数据保证单词长度不超过10^5，字符长度不超过10^6</div>\n","gpid":"T717","lanqiaotitle":"文章翻转","memorylimit":"128.0MB","tid":"ALGO-310","timelimit":"1.0s","title":"算法训练 文章翻转","src":""},{"checkpoint":"","updatetime":"2020-04-17","content":"<div class='pdcont'>　　H2 { margin-top: 0.46cm; margin-bottom: 0.46cm; direction: ltr; color: rgb(0, 0, 0); line-height: 173%; text-align: justify; page-break-inside: avoid; }H2.western { font-family: \"Arial\",sans-serif; font-size: 16pt; }H2.cjk { font-family: \"黑体\",\"SimHei\",monospace; font-size: 16pt; }H2.ctl { font-family: \"Times New Roman\",serif; font-size: 16pt; }P { margin-bottom: 0.21cm; direction: ltr; color: rgb(0, 0, 0); text-align: justify; }P.western { font-family: \"Calibri\",sans-serif; font-size: 10pt; }P.cjk { font-family: \"宋体\",\"SimSun\"; font-size: 10pt; }P.ctl { font-family: \"Times New Roman\",serif; font-size: 11pt; }【问题描述】<br />\n　　Lyl大牛今天心情不错，于是走到埃及郊外旅游(会不会碰到MMY?...PS:MMY的含义请自行理解)。他边走边向四周望望，发现周围有许多果树。这些树之间互相到达的时间Lyl是知道的（假定每两棵树之间都拥有独立的边可以到达）。他数出了这些果树上果子的个数，并且估了估每个的价格（真是个奇怪的人）。Lyl规定了一种采摘方案，就是对于第i棵树来说，它有a[i]个果子，且所有果子价值为s[i]，摘取时间为c[i](小时)。并且，当他摘了第i个树上的果子后，后面他所选择去摘的果树上的果子数必须大于第i棵树上的果子数目，说白了就是一个上升序列；并且每到一棵树，他都必须摘下该树上的所有果子。一开始，Lyl可以在任意一棵树，他只有m小时，那么，在他所拥有的限定时间内，他想知道，这样摘取的最大价值是多少？</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入文件<b>tree.in</b>第一行2个数：n（表示这条路上的大树数），m（总共时间）<br />\n　　接下来第n+1行，每行三个数a[i],s[i],c[i] (第i+1行输入的为第i颗果树的信息)<br />\n　　且保证有1&lt;=a[i]&lt;=2^31-1;1&lt;=s[1]+s[2]+…+s[n]&lt;=2^31-1;s[i]&gt;=0; 1&lt;=c[i]&lt;=100<br />\n　　接下来的n行，每行n个数，第i行第j个数表示从树i到树j的时间。（0&lt;=T[I,j]&lt;=100;）</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出文件<b>tree.out</b>有且仅有一个数，即按这样方法摘取的最大价值。</div><div class='pdsec'>样例输入</div><div class='pddata'>4 10<br />\n1 10 2<br />\n2 5 3<br />\n3 6 1<br />\n4 9 4<br />\n0 1 2 3<br />\n1 0 3 4<br />\n2 3 0 5<br />\n3 4 5 0</div><div class='pdsec'>样例输出</div><div class='pddata'>21<br />\n（先摘第1棵树上的，再摘第2棵树上的，然后第3棵树上的）</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于60%的数据 ,1&lt;=N&lt;=60,1&lt;=m&lt;=100;<br />\n　　对于100%的数据 ,1&lt;=N&lt;=100, 1&lt;=m&lt;=1000.</div>\n","gpid":"T716","lanqiaotitle":"采果子","memorylimit":"256.0MB","tid":"ALGO-309","timelimit":"1.0s","title":"算法训练 采果子","src":""},{"checkpoint":"hash","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Xenia去了IOI，拿到了一道字符串题。不幸的是，Xenia并不擅长字符串算法，请你帮助她解决这道题。<br />\n<br />\n　　字符串s是一个由字符s[1]s[2]...s[|s|]组成的序列，|s|表示字符串的长度。<br />\n　　子串s[i...j]是s[i]s[i+1]...s[j]构成的字符串。<br />\n<br />\n　　如果字符串s满足以下条件，那么就称它为Gray串：<br />\n　　(1)串长|s|是奇数；<br />\n　　(2)字符s[(|s|+1)/2]在串s中只出现了一次；<br />\n　　(3)|s|=1或子串s[1...(|s|+1)/2-1]和子串s[(|s|+1)/2+1...|s|]相同且都是Gray串。<br />\n<br />\n　　比如，串\"abacaba\",\"xzx\",\"g\"都是Gray串，而串\"xz\",\"abaxcbc\"则不是。<br />\n<br />\n　　定义一个串p的美丽值为所有串p的子串中，是Gray串的子串的长度的平方和。<br />\n　　也就是说，对于所有数对(i,j)满足(1≤i≤j≤|p|)且子串p[i...j]是Gray串，就把(j-i+1)^2加到美丽值中。<br />\n<br />\n　　Xenia已经得到了一个由小写英文字母构成的串t，她被允许修改串t中最多一个字符(也可以不修改)，来使得串t的美丽值最大。<br />\n　　你的任务就是求出串t修改后的最大美丽值。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一行，一个由小写英文字母构成的字符串t。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行，一个正整数，为串t修改后的最大美丽值。</div><div class='pdsec'>样例输入</div><div class='pddata'>zzz</div><div class='pdsec'>样例输出</div><div class='pddata'>12</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　5%的数据，|t|≤10。<br />\n　　20%的数据，|t|≤100。<br />\n　　40%的数据，|t|≤1000。<br />\n　　100%的数据，|t|≤10^5。</div>\n","gpid":"T715","lanqiaotitle":"Xenia and String Problem","memorylimit":"256.0MB","tid":"ALGO-308","timelimit":"1.0s","title":"算法训练 Xenia and String Problem","src":"Codeforces 356E"},{"checkpoint":"","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　SPFA</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行输入n,m；第二行输入begin,end<br />\n<br />\n　　接下来m行输入x,y,z;<br />\n<br />\n　　n表示点数，m表示边数，begin表示起始点，end表示目标点，x、y表示连同连点z表示权值</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出begin到end的最短路</div><div class='pdsec'>样例输入</div><div class='pddata'>7 12<br />\n1 7<br />\n1 7 10<br />\n1 2 1<br />\n1 3 2<br />\n2 7 8<br />\n2 3 1<br />\n2 4 4<br />\n2 5 1<br />\n2 6 10<br />\n3 4 3<br />\n5 6 1<br />\n5 4 7<br />\n6 7 1</div><div class='pdsec'>样例输出</div><div class='pddata'>4</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n,m&lt;10^6</div>\n","gpid":"T714","lanqiaotitle":"SPFA","memorylimit":"256.0MB","tid":"ALGO-307","timelimit":"1.0s","title":"算法训练 SPFA","src":""},{"checkpoint":"模拟","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给你一个N*M的网格，一开始都是白色的。上面有一个机器人，一开始位于格子（X，Y）上（占据整个格子），面朝某个方向（左上，左下，右上，右下之一）。然后机器人会一直顺着这个方向走下去，每当遇到边界时会遵循光的反射定律改变方向，然后继续走。每当机器人走到一个格子后，它会将这个格子染黑，用掉一个单位颜料。即便这个格子已经被染黑了，也需要耗费一个单位颜料。当机器人意识到这个N*M的网格已经变成黑白相间的时候，它会立即停止行动。现在希望你求出，机器人停下来的时候，已经耗费了多少颜料？或者指出永远不可能停下来。<br />\n<img src=\"http://espresso.codeforces.com/7df2096f6969d97c7028a1bc36952fefb565e8f8.png\" /><br />\n　　左边的图描述了一次机器人的行动。它从1开始，依次走过1、3、5、4、2、3、6，其中3被染了两次（注意在这条路径中，5这种转折点不被算两次）。右边的图描述了一个不可能停下来的情况。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入第一行两个数N，M，均&lt;=10^5。含义如上所述。<br />\n　　第二行先是两个数X、Y，表示机器人一开始的坐标。然后两个字符，表示朝向（UL：左上，UR：右上，DL：左下，DR：右下）<br />\n　　输入保证起点坐标在某一个边界上。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行一个正整数，表示停下来的时候耗费的颜料数。如果不可能停下来，输出-1。</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n3 4<br />3 3 DR\n</pre>\n<div class='pdsec'>样例输出</div><div class='pddata'>11</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于20%的数据，N、M&lt;=10<br />\n　　对于100%的数据，N、M&lt;=100000</div>\n","gpid":"T713","lanqiaotitle":"Shaass and Painter Robot","memorylimit":"512.0MB","tid":"ALGO-306","timelimit":"1.0s","title":"算法训练 Shaass and Painter Robot","src":"Codeforces 294D"},{"checkpoint":"","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　现在请你假想一次考试，这场考试有N个考生。<br />\n　　你可以预测这N个考生最终得分的范围，从而预测他的排名。选手们的分数将按照成绩升序排列，也就是说，分数越高，排名越后。<br />\n　　你知道第i个考生的得分范围是[Li,Ri]（得分可以是实数哦），现在你要预测每个考生得到任何排名的概率。<br />\n　　提示：无需考虑多个考生有相同分数的情况。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个数N，表示考生数量。<br />\n<br />\n　　第2到N+1行中，第i行有两个整数Li,Ri表示第i个考生的得分范围是[Li,Ri]</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出共N行，每行有N个实数。第i行第j个实数表示第i个考生排名第j的概率。</div><div class='pdsec'>样例输入</div><div class='pddata'>8<br />\n0 2<br />\n1 3<br />\n2 4<br />\n3 5<br />\n4 6<br />\n5 7<br />\n6 8<br />\n7 9</div><div class='pdsec'>样例输出</div><pre class='pddata'>\n0.875 0.125 0 0 0 0 0 0 <br />0.125 0.750 0.125 0 0 0 0 0 <br />0 0.125 0.750 0.125 0 0 0 0 <br />0 0 0.125 0.750 0.125 0 0 0 <br />0 0 0 0.125 0.750 0.125 0 0 <br />0 0 0 0 0.125 0.750 0.125 0 <br />0 0 0 0 0 0.125 0.750 0.125 <br />0 0 0 0 0 0 0.125 0.875\n</pre>\n<div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于 10%的数据，1&lt;=n&lt;=2<br />\n　　对于 30%的数据，1&lt;=n&lt;=20<br />\n　　对于 50%的数据，1&lt;=n&lt;=50<br />\n　　对于 100%的数据，1&lt;=n&lt;=80，0&lt;=Li&lt;Ri&lt;=10^9<br />\n　　（保证数据有梯度）<br />\n　　与标准输出相差10^-6以内算做正确。</div>\n","gpid":"T712","lanqiaotitle":"Random Ranking","memorylimit":"256.0MB","tid":"ALGO-305","timelimit":"2.0s","title":"算法训练 Random Ranking","src":"Codeforces 303E"},{"checkpoint":"组合数学","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　P是n个互不相同且不超过n的正整数的一个排列。我们设排列P的第i个元素为P[i]，n为排列的长度。<br />\n　　我们称排列中的第i个位置是完美的，当且仅当|P[i]-i|=1。<br />\n　　请求出长度为n的而且完美的位置数刚好为k的排列数是多少。答案要求取模10^9 + 7。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　单独一行，包含两个用空格分开的两个整数n和k。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出长度为N的而且完美的位置数刚好为k的排列数，答案模10^9 + 7。</div><div class='pdsec'>输入输出样例</div><div class='pdcont'><table cellspacing=0 cellpadding=2px style='border-collapse:collapse;' class='table table-striped table-horver'><tbody><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'><br />\n</td><td valign=\"top\" style='border:solid 1.0pt'></div><div class='pdsec'>输入格式</div><div class='pdcont'></td><td valign=\"top\" style='border:solid 1.0pt'></div><div class='pdsec'>输出格式</div><div class='pdcont'></td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>Sample 1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1 0<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>Sample 2<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>2 1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>0<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>Sample 3<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>3 2<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>4<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>Sample 4<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>4 1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>6<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>Sample 5<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>7 4<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>328<br />\n</td></tr></tbody></table></div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&thinsp;≤&thinsp;n&thinsp;≤&thinsp;1000,&thinsp; 0&thinsp;≤&thinsp;k&thinsp;≤n</div>\n","gpid":"T711","lanqiaotitle":"Positions in Permutations","memorylimit":"256.0MB","tid":"ALGO-304","timelimit":"1.0s","title":"算法训练 Positions in Permutations","src":"Codeforces 285E"},{"checkpoint":"","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Levko非常喜欢在他的城市中进行体育探险比赛。为了提高他的专业水平，Levko利用他的空闲时间来进行训练。这个训练是一个游戏。<br />\n　　这个城市有n个道路交叉口，被m+K条笔直的道路连接。两条或以上的道路可以连接相同的交叉路口。除此之外，可能会有道路连接某个交叉路口和这个路口本身。<br />\n　　Levko和Zenyk在玩一个游戏。首先Levko站在交叉路口S1，Zenyk站在交叉路口S2，他们都想去交叉路口f，他们中先到达交叉路口f的赢得游戏。如果他们同时到达了，这个游戏就是平局。他们约定同时出发并且以相同的速度行进。<br />\n　　Levko非常想赢得游戏。他知道这个城市里所有的道路的长度，他也知道如果他支付给政府一些钱他可以改变一些道路的长度（总共有k条道路可以被他改变）。所以，政府可以把第i条道路的长度变为区间[Li , Ri]里的任何一个值（包括边界）。Levko想知道他能否通过改建这些道路来赢得游戏以及如果他不能赢，他最后能否平局。<br />\n　　你需要知道这两个人都能发挥出最好水平。输入保证他们都能到达交叉路口f。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含3个数n，m，k。<br />\n　　第二行包含3个数s1, s2和f 。<br />\n　　接下来m行包含m条不能改变长度的道路，每行3个整数ai,bi,ci,表示ai路口到bi路口长度为ci.<br />\n　　接下来k行包含k条能改变长度的道路，每行4个整数ai,bi,li,bi表示ai路口到bi路口Levko能把长度改到[li,ri].</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　如果Levko能赢第一行就输出“WIN”，平局输出“DRAW”,输就输出“LOSE”。<br />\n　　如果输出时“WIN”或者“DRAW”，接下来需要输出这k条道路的长度。</div><div class='pdsec'>样例输入</div><div class='pddata'>4 1 3<br />\n1 3 4<br />\n3 2 2<br />\n1 2 1 3<br />\n2 4 1 3<br />\n3 4 1 3</div><div class='pdsec'>样例输出</div><div class='pddata'>WIN<br />\n1 1 3</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于100%的数据1&thinsp;≤&thinsp;n,&thinsp;m&thinsp;≤&thinsp;104, 1&thinsp;≤&thinsp;k&thinsp;≤&thinsp;100,1&thinsp;≤&thinsp;s1,&thinsp;s2,&thinsp;f&thinsp;≤&thinsp;n</div>\n","gpid":"T710","lanqiaotitle":"Levko and Game","memorylimit":"256.0MB","tid":"ALGO-303","timelimit":"1.0s","title":"算法训练 Levko and Game","src":""},{"checkpoint":"DP","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Roland是一个高中数学教师，每天他都会发一大堆作业让学生做。<br />\n　　每一份作业，他会认真地批改并给出一个等级：\"A\"或\"B\"或\"C\"。(Roland的学生都是学霸，不管怎么乱涂都不会拿\"D\"或\"F\")。<br />\n　　每次Roland评定完所有等级，都会把那些作业交给他的助手(你)，你的任务是帮Roland完成成绩的登记。<br />\n<br />\n　　不幸的是，你只有一台非常低能的打字机，但是这个打字机有一些功能可以使用。<br />\n　　这是一个栈式的打字机，支持下面三种操作：<br />\n　　(1)把一个字母加到栈顶。<br />\n　　(2)打印栈顶的字母。<br />\n　　(3)删除栈顶字母。<br />\n<br />\n　　给出你需要打印的字母等级序列，你需要算出打印这个序列的最小操作数。<br />\n　　为了方便下一次工作，栈一开始是空的，当你工作完成后也要使栈是空的。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行，一个正整数T，表示数据组数。<br />\n　　接下来T行，每行一个由\"A\"\"B\"\"C\"组成的字符串S。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组数据输出一行\"Case #x: N\"，x为数据编号(从1开始)，N是最小操作数。</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\nABCCBA<br />\nAAABAAB</div><div class='pdsec'>样例输出</div><div class='pddata'>Case #1: 12<br />\nCase #2: 13</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　40%的数据，T=1，|S|≤100<br />\n　　100%的数据，T≤20，&sum;|S|≤2000</div>\n","gpid":"T709","lanqiaotitle":"Letter Stamper","memorylimit":"256.0MB","tid":"ALGO-302","timelimit":"1.0s","title":"算法训练 Letter Stamper","src":"GCJ 2010 Final A"},{"checkpoint":"DP","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Greg有一个平板电脑，平板电脑的屏幕是一个由N*M个像素点组成的矩形，每个像素点可以是黑色或白色。我们设画板的行从上到下编号从1到N。类似地，画板的列从左到右编号为1到M。<br />\n　　Greg认为，如果符合以下条件，那么平板电脑的屏幕就会呈现一个洞。<br />\n　　一）存在一个区间[L,R](1&lt;=L&lt;=R&lt;=N)，<br />\n　　使得上至行L、下至行R，每一行都恰有2个黑点，而其他列只有白点。<br />\n　　二）存在一个行号t∈[L,R]，使得：<br />\n　　定义：【中间白点是指同一行处在2个黑点之间的白点，black_left[i]表示第i行靠左边的黑点所在列，black_right[i]表示靠右边的黑点所在列】<br />\n　　1）对于任意L&lt;=i&lt;=j&lt;=t，<br />\n　　第i行的任意列的中间白点，第j行的同一列都是中间白点。<br />\n　　且black_left[i]&gt;=black_left[j]、black_right[i]&lt;=black_right[j]<br />\n　　2）对于任意t&lt;=i&lt;=j&lt;=R，<br />\n　　第j行的任意列的中间白点，第i行的同一列都是中间白点。<br />\n　　且black_left[i]&lt;=black_left[j]、black_right[i]&gt;=black_right[j]<br />\n　　求能显示一个洞的方案数。<br />\n　　Greg想知道，有多少种方法使得平板上显示一个洞。<br />\n　　两种方法不同当且仅当一个对应位置的像素点颜色不同。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　只有一行，包含两个正整数N和M。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　只包含一个整数，为方案数模1000000007后的结果。</div><div class='pdsec'>样例输入输出</div><div class='pdcont'><table cellspacing=0 cellpadding=2px style='border-collapse:collapse;' class='table table-striped table-horver'><tbody><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'><br />\n</td><td valign=\"top\" style='border:solid 1.0pt'></div><div class='pdsec'>输入格式</div><div class='pdcont'></td><td valign=\"top\" style='border:solid 1.0pt'></div><div class='pdsec'>输出格式</div><div class='pdcont'></td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>Sample 1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1 1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>0<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>Sample 2<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>4 4<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>485<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>Sample 3<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>3 5<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>451<br />\n</td></tr></tbody></table></div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&thinsp;≤&thinsp;N,&thinsp;M&thinsp;≤&thinsp;2000</div>\n","gpid":"T708","lanqiaotitle":"Greg and Caves","memorylimit":"256.0MB","tid":"ALGO-301","timelimit":"1.0s","title":"算法训练 Greg and Caves","src":"Codeforces 295D"},{"checkpoint":"数学期望 点分治 DFS","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　在计算机科学领域里，有一种解决复杂树链问题的算法叫做”点分治”。让我们来定义一下这个算法的流程：<br />\n　　Solve(T) (T是一棵树)<br />\n　　1.选择一个树T上的结点x(通常选用树的重心)，我们将这个操作叫做”第一步”。<br />\n　　2.处理所有经过点x的路径<br />\n　　3.从树T中删除结点x<br />\n　　4.然后树T分裂成若干子树<br />\n　　5.分治处理所有的Solve(S) (S是分裂出来的子树)<br />\n　　这个算法会结束，因为当T只有一个结点时，删除这个点是就什么都不剩了。<br />\n<br />\n　　现在WJMZBMR错误的认为在”第一步”中选择任何一个点都是可以的，所以他在第一步中随机选点，而不是选树的重心。为了使情况更糟，他认为一棵”树”应该满足边数和点数相等。所以他做点分治的过程变成这样：<br />\n　　让我们定义变量totalCost，初始totalCost=0。然后，solve(T) (现在T是一个图)<br />\n　　1.totalCost=totalCost+(size of T).运算符’=’表示赋值。(Size of T)表示图T中的结点个数。<br />\n　　2.在图T中随机选择一个结点x(图T中每个点被选中的概率相等)<br />\n　　3.从图T中删除结点x<br />\n　　4.然后T变成了一些联通快<br />\n　　6.分治处理所有的Solve(S) (S是剩下的连通块)<br />\n<br />\n　　他将新的solve函数用于一个n个结点n条边的连通图，并且认为这种算法会运行的很快，但是结果恰恰相反，它运行的非常慢。所以他想知道对于某个连通图这个算法中变量totalCost的数学期望。你能帮帮他吗？</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行仅一个整数n(3≤n≤3000)——图中点和边的数量。接下来n行，每行包含两个由空格隔开的整数ai,bi(0≤ai,bi≤n-1)，表示有一条边在ai,bi之间。图中结点编号从0到(n-1)，保证没有重边和自环，保证图连通。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个实数表示totalCost的数学期望，和标准答案相差10^-6以内都被认为是正确的。</div><div class='pdsec'>样例输入</div><div class='pddata'>样例输入一<br />\n5<br />\n3 4<br />\n2 3<br />\n2 4<br />\n0 4<br />\n1 2<br />\n样例输入二<br />\n3<br />\n0 1<br />\n1 2<br />\n0 2<br />\n样例输入三<br />\n5<br />\n0 1<br />\n1 2<br />\n2 0<br />\n3 0<br />\n4 1</div><div class='pdsec'>样例输出</div><div class='pddata'>样例输出一<br />\n13.166666666666666<br />\n样例输出二<br />\n6.000000000000000<br />\n样例输出三<br />\n13.166666666666666</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　0&lt;n&lt;=3000</div>\n","gpid":"T707","lanqiaotitle":"Graph Game","memorylimit":"256.0MB","tid":"ALGO-300","timelimit":"1.0s","title":"算法训练 Graph Game","src":"Codeforces 235D"},{"checkpoint":"","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有关贝茜和她的朋友们的一个鲜为人知的事实是他们喜欢爬楼梯比赛。一个更多人知道的事实是奶牛非常讨厌下楼梯，所以在奶牛爬到了他们最喜欢的那座摩天大厦的顶部后，她们有了一个问题。奶牛拒绝使爬楼梯回去，她想用电梯回到1楼。<br />\n　　电梯有W(1 &lt;= W &lt;= 100,000,000) 的磅的最大承重，第i只奶牛有Ci (1 &lt;= C_i &lt;= W) 磅的体重。请你帮助贝茜算出最少坐多少次电梯才能使所有的奶牛回到第1层楼。每个电梯里的奶牛的总体重不能超过电梯的最大承重。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第1行：2个数n和m，中间用一个空格隔开。<br />\n　　接下来n行，第i+1行描述第i只奶牛的体重。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个正整数</div><div class='pdsec'>样例输入</div><div class='pddata'>4 10<br />\n5<br />\n6<br />\n3<br />\n7</div><div class='pdsec'>样例输出</div><div class='pddata'>3</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于10%的数据n&lt;=5<br />\n<br />\n　　对于100%的数据n&lt;=18</div>\n","gpid":"T706","lanqiaotitle":"Cows in a Skyscrape","memorylimit":"256.0MB","tid":"ALGO-299","timelimit":"1.0s","title":"算法训练 Cows in a Skyscrape","src":"USACO Mar 12"},{"checkpoint":"字符串 dp","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　假设有p和q两个长度为正整数的字符串，我们分别叫它们为匣子和钥匙。<br />\n<br />\n　　其中，钥匙串q只包含字符0和1。<br />\n<br />\n　　下面给出一段简单的算法用以描述如何从匣子串p中提取出信息串s<br />\n　　i = 0;<br />\n　　j = 0;<br />\n　　s = &lt;&gt;;<br />\n　　while i is less than the length of the string p<br />\n　　{<br />\n　　if q[j] == 1, then add to the right of string s character p[i];<br />\n　　increase variables i, j by one;<br />\n　　if the value of the variable j equals the length of the string q, then j = 0;<br />\n　　}<br />\n　　在上面一段伪代码中 i,j是整形变量，s是字符串， \"=\"是赋值运算符, \"==\"是一个比较运算符,\"[]\"是获取字符串某个下标上的字符的运算符,\"&lt;&gt;\"是一个空字符串。我们假定所有字符串都是从下标0开始的。<br />\n<br />\n　　我们知道这个算法实现起来非常简单，所以你的任务会稍微复杂一些。你需要构造一个字典序最小的长度为k的钥匙串。使该钥匙串用于以上算法时，从给定的匣子串p中获得给定的信息串s</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入数据的前两行包含两个非空字符串p和s(1 &lt;= |p| &lt;= 10^6, 1 &lt;= |s| &lt;= 200) 分别为上述的匣子串和信息串。这两个字符串可以包含所有ASCII码从32到126的字符。请注意，空格符的ASCII码为32。<br />\n　　输入数据的第三行是一个整数k, (1 &lt;= k &lt;= 2000),钥匙串的长度。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行包含一个01串，表示你求出来的字典序最小的钥匙串。</div><div class='pdsec'>样例输入</div><div class='pddata'>abacaba<br />\naba<br />\n6</div><div class='pdsec'>样例输出</div><div class='pddata'>100001</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于25%的数据k &lt;= 20, |p| &lt;= 100<br />\n　　对于50%的数据k &lt;= 60<br />\n　　对于100%的数据k &lt;= 2000, |p| &lt;= 10^6, |s| &lt;= 200<br />\n　　对于两个钥匙串之间的字典序大小的比较方式为比较他们的01字符串的大小</div>\n","gpid":"T705","lanqiaotitle":"Binary Key","memorylimit":"256.0MB","tid":"ALGO-298","timelimit":"1.0s","title":"算法训练 Binary Key","src":"Codeforces 332E"},{"checkpoint":"字符串 后缀数组","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　FJ准备带领他的n(1&lt;=n&lt;=30000)头奶牛去参加一年一度的“年度农夫”大赛。在这个比赛中每个农夫都要把他的奶牛排成一行，然后驱赶他们通过检查官。<br />\n　　今年，比赛的组办方通过了一个新的登记方案：简单的按顺序奶牛的出场顺序登记每个奶牛名字的第一个字母（假如FJ带领Bessie，Sylvia，Dora，并以这个顺序排列，那么登记的结果BSD）。在登记步骤结束后，每个农夫会根据登记序列的字典序，从小到大接受检查。<br />\n　　FJ这年非常的忙碌，需要马上回他的农场，所以他希望能被检查的越快越好。他的奶牛在登记前已经排好了。Fj决定重新安排他的奶牛。<br />\n　　FJ选好了新队伍的位置，然后他动手把他的奶牛一个一个从旧队伍中安排到新队伍里面。Fj不断把剩下的旧队伍中，第一个或者最后一个安排到新队伍的末尾。当他完成的时候，FJ便会以这个新的顺序去参加登记。 给定初始奶牛的顺序，输出用这个方法可以的到的字典序最小的方案。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个整数n<br />\n　　第2到第n+1行，每行一个字母('A'...'Z')，表示在原序列中奶牛们的名字第一个字母。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出若干行，表示FJ能得到字典序最小的排列。每80个字母一行。</div><div class='pdsec'>样例输入</div><div class='pddata'>6<br />\nA<br />\nC<br />\nD<br />\nB<br />\nC<br />\nB</div><div class='pdsec'>样例输出</div><div class='pddata'>ABCBCD</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=30000</div>\n","gpid":"T704","lanqiaotitle":"Best Cow Line","memorylimit":"256.0MB","tid":"ALGO-297","timelimit":"1.0s","title":"算法训练 Best Cow Line","src":"usaco Dec 2007 gold"},{"checkpoint":"","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　现有一个n个点m条边的网络。每条边有一个容量限制，对于一条边&lt;x,y&gt;，设其流量为t，容量为c，如果t大于0则是从x流向y，反之就是从y流向x，但t的绝对值不能超过c且可以不是整数。网络中节点1是源点，节点n是汇点，对于除1,n外的所有点，流入的流量等于流出的流量。这个网络有一个奇怪的性质，对于任意一对节点(x,y)，x到y的路径上流量之和不会随着选择不同的路径而改变（有可能有小于0的流量，流量的符号取决于x到y路径上这条边的方向）。<br />\n　　求满足上述条件且流过该网络的流量尽可能大的方案以及最大的流量是多少。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含两个正整数n,m。<br />\n　　接下来有m行，每行3个整数a_i,b_i,c_i，描述一条边，分别表示连接的两个端点和这条边的容量限制。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第一行输出最大的通过该网络的流量的值。<br />\n　　接下来m行，分别表示每条边的流量，顺序和输入一致。<br />\n　　至少需要保留到小数点后五位。</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n3<br />\n1 2 2<br />\n1 2 4<br />\n2 1 1000</div><div class='pdsec'>样例输出</div><div class='pddata'>6.00000<br />\n2.00000<br />\n2.00000<br />\n-2.00000</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=100, m&lt;=5000<br />\n　　1&lt;=a_i,b_i&lt;=n, c_i&lt;=10000</div>\n","gpid":"T703","lanqiaotitle":"Berland Traffic","memorylimit":"256.0MB","tid":"ALGO-296","timelimit":"1.0s","title":"算法训练 Berland Traffic","src":"codeforces - 267C"},{"checkpoint":"联通分块","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　连通分块</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含两个整数n, m<br />\n　　n代表图中的点的个数，m代表边的个数<br />\n　　接下来m行，每行2个正整数，表示图中连通的两点。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出1行，与1连通的点的集合，并按升序排列输出。</div><div class='pdsec'>样例输入</div><div class='pddata'>6 3<br />\n1 2<br />\n2 3<br />\n3 4</div><div class='pdsec'>样例输出</div><div class='pddata'>1 2 3 4</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=10000,m&lt;=100000</div>\n","gpid":"T695","lanqiaotitle":"连通分块","memorylimit":"8.0MB","tid":"ALGO-295","timelimit":"200ms","title":"算法训练 连通分块","src":""},{"checkpoint":"状态压缩的动态规划","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给了一nxm的方格，用1x3的瓷砖铺满，请问有多少种铺法。瓷砖可以旋转。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含两个整数，n, m。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个整数，表示总的铺法数。这个数可能很大，请输出对65521取余的结果。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 3</div><div class='pdsec'>样例输出</div><div class='pddata'>2</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于30%的数据，1&lt;=n&lt;=10, 1&lt;=m&lt;=3。<br />\n　　对于50%的数据，1&lt;=n&lt;=30，1&lt;=m&lt;=6。<br />\n　　对于100%的数据，1&lt;=n&lt;=100，1&lt;=m&lt;=7。</div>\n","gpid":"T694","lanqiaotitle":"瓷砖铺放","memorylimit":"256.0MB","tid":"ALGO-294","timelimit":"3.0s","title":"算法训练 瓷砖铺放","src":""},{"checkpoint":"计算几何","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　魔兽世界里有很多掉率很低的坐骑，它们一般都比较好看，WYF自然经常会去刷它们，他有4个号，每周都要往返于各个副本之间。作为一个RP不错的大神，他已经有了奥的灰烬，乌鸦之神，奥利瑟拉佐尔的烈焰之爪，纯血火鹰等等稀有坐骑。但是坐骑何其多！还有更多的坐骑在等着他！可是他在重装游戏后，竟然忘记了几个重要的副本位置，只好在游戏里求助GM大大，GM大大告诉他艾泽拉斯大陆上的3个地点A,B,C，并告诉他奥妮克希亚的巢穴在BC的中点处，卡拉赞在角ＢＡＣ的平分线与BC的交点处，而巨龙之魂在A在直线BC上的投影处。WYF有强烈的预感这次要出坐骑了，请你帮助他算出三个副本的位置吧！</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入不共线的3个点A，B，C</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第一行输出ＢＣ的中点<br />\n　　第二行输出角ＢＡＣ的平分线与BC的交点<br />\n　　第三行输出A在直线BC上的投影（垂线的垂足）<br />\n　　保留2位小数！！！<br />\n<br />\n　　保留2位小数！！！<br />\n<br />\n　　保留2位小数！！！<br />\n<br />\n　　保留2位小数！！！<br />\n<br />\n　　保留2位小数！！！<br />\n<br />\n　　保留2位小数！！！<br />\n<br />\n　　保留2位小数！！！</div><div class='pdsec'>样例输入</div><div class='pddata'>0 0<br />\n1 0<br />\n0 1</div><div class='pdsec'>样例输出</div><div class='pddata'>0.50 0.50<br />\n0.50 0.50<br />\n0.50 0.50</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　不会很大的</div>\n","gpid":"T693","lanqiaotitle":"WYF刷坐骑","memorylimit":"256.0MB","tid":"ALGO-293","timelimit":"1.0s","title":"算法训练 WYF刷坐骑","src":"WYF系列主角"},{"checkpoint":"计算几何","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　今天是WYF的85935396岁大寿，他要吃一个圆形蛋糕，蛋糕有\"WYF\"字样的花边。现在WYF要切第一刀了，他想知道花边的哪些位置被切开了。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入蛋糕的圆心和半径，再输入一个数tou，若tou为0，则再输入WYF想切的第一刀（直线）上的任意两个不重合的点；若tou为1，则再输入WYF想切的第一刀（线段）的两个端点。（输入均为2位小数）</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出花边被切的所有位置（按横坐标从小到大输出，若横坐标相同则按纵坐标从小到大输出），每个位置一行，保留5位小数。如果花边没有被切，输出\"LLJJ\"（不含引号）。</div><div class='pdsec'>样例输入</div><div class='pddata'>5.00 4.00<br />\n3.00<br />\n0<br />\n4.00 4.00<br />\n6.00 0.00</div><div class='pdsec'>样例输出</div><div class='pddata'>2.91938 6.16125<br />\n5.48062 1.03875</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　所有输入坐标的绝对值&lt;=8593。<br />\n　　0&lt;=半径&lt;=5396。<br />\n　　tou只可能为0或1。</div>\n","gpid":"T692","lanqiaotitle":"WYF切蛋糕","memorylimit":"256.0MB","tid":"ALGO-292","timelimit":"1.0s","title":"算法训练 WYF切蛋糕","src":"WYF系列"},{"checkpoint":"计算几何","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　玩完魔兽世界，WYF发现他的数学作业还没写。他知道：如果不写作业，明天会被碎尸85935396段。可是WYF不打算写作业（他也没想写过），就从网上找每道题的答案。但是恰好有一道题没有找到。这道题是这样的：已知A、B、C、D的坐标，求线段AC与BD的交点E的坐标。<br />\n　　那么现在问题来了——WYF用好友聊天找到你，求你帮他做出这道题。如果没有交点，输出LLJJ。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包括4行。<br />\n　　Xa，Ya<br />\n　　Xb，Yb<br />\n　　Xc，Yc<br />\n　　Xd，Yd<br />\n　　均保留2位小数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出仅一行，为Xe，Ye，保留5位小数。</div><div class='pdsec'>样例输入</div><div class='pddata'>1.00 1.00<br />\n1.00 -1.00<br />\n-1.00 -1.00<br />\n-1.00 1.00</div><div class='pdsec'>样例输出</div><div class='pddata'>0.00000 0.00000</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　|X|、|Y|&lt;=3180。</div>\n","gpid":"T691","lanqiaotitle":"WYF的数学作业","memorylimit":"256.0MB","tid":"ALGO-291","timelimit":"1.0s","title":"算法训练 WYF的数学作业","src":"WYF系列"},{"checkpoint":"网络流","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　热情的选手Sphinny正在看新一年的日程表，并发现已经安排了很多编程竞赛。她将这一年的每一天都用以下三种方式之一在日程表上打标记。<br />\n　　1.  白色：这一天她将不参加竞赛。或许这一天没有预定的竞赛，或许\t\t\t这一天有更重要的事情要做（生活中肯定还有其他美好的事情）。<br />\n　　2.  蓝色：这一天她将参加一场竞赛。<br />\n　　3.  问号：这一天有预定好的竞赛，但她还没有决定好是否参加。<br />\n　　为了简化问题，我们假设没有资格的概念：你不必参加一场比赛去取得另一场比赛的参赛资格。<br />\n　　Sphinny生活的世界与我们的世界有所不同，那个世界里一年有n个月，每个月恰有m天。<br />\n　　下面的图片是一张5个月，每个月有8天的日程表。上面有15天标记为蓝色，5天标记了问号。<br />\n<img src=\"/RequireFile.do?fid=FaAme8Lf\" width=\"303\" height=\"207\" /><br />\n　　看她美丽的日程表。Sphinny认为对于每一天，有四天与它相邻（可能有的不存在）：同一个月的前一天，同一个月的后一天，前一个月的同一天，后一个月的同一天。<br />\n　　Sphinny想最大化所有竞赛的喜悦值之和。一场竞赛的喜悦值的计算方式是：<br />\n　　1.  初始为4。<br />\n　　2.  每有与那一天相邻的一天要参赛，喜悦值减1。（你可以认为Sphinny喜欢竞赛，但连续参赛让她感觉很累。并且出于审美的原因，在相邻两个月的同一天参赛也不是很好。）<br />\n　　现在，Sphinny想计划这一年，并决定把每一个问号标记都改为白色标记或蓝色标记。她的目标很简单，就是最大化总喜悦值。<br />\n　　下图是上面例子的一种解决方案。通过把2个问号标记变为蓝色标记，剩下的3个问号标记变为白色标记，她可以得到喜悦值42。<br />\n<img src=\"/RequireFile.do?fid=65BtnBer\" width=\"303\" height=\"211\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个整数T表示测试数据组数。<br />\n　　对于每一组数据：第一行两个整数n，m表示有n个月，每个月有m天。之后n行每行一个长度为m的字符串，第i行第j个字符表示第i个月的第j天的状态，“#”表示这一天被标记为蓝色，“.”表示这一天被标记为白色，“?”表示这一天被标记为问号。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每一组数据，输出：<br />\n　　Case #X: Y<br />\n　　X是第几组测试数据，Y是最大总喜悦值。</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n3 3<br />\n.?.<br />\n.?.<br />\n.#.<br />\n5 8<br />\n.#...##.<br />\n.##..?..<br />\n.###.#.#<br />\n??#..?..<br />\n###?#...</div><div class='pdsec'>样例输出</div><div class='pddata'>Case #1: 8<br />\nCase #2: 42</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于10%的数据     n，m≤5<br />\n　　对于30%的数据     n，m≤15<br />\n　　另20%的数据       m≤10<br />\n　　另20%的数据       T=1<br />\n　　对于100%的数据     n，m≤50 ； T≤100</div>\n","gpid":"T690","lanqiaotitle":"The Year of Code Jam","memorylimit":"256.0MB","tid":"ALGO-290","timelimit":"1.0s","title":"算法训练 The Year of Code Jam","src":"Google Code Jam 2008 Final E"},{"checkpoint":"构造 并查集","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Piegirl终于发现了红色按钮，你现在还剩最后一个机会去改变这个结局。这个按钮下面的电路由n个从0到n-1编号节点组成。为了关闭这个按钮，这n个节点必须以特定的序列拆解。节点0必须首先拆解，在拆解了节点i后，下一个被拆解的节点必须是(2·i) mod n或(2·i)+1 mod n。最后一个被拆解的节点必须是节点0。节点0必须被拆解两次，其他节点必须刚好被拆解一次。你的任务是找到一个符合要求的顺序并输出它。如果没有任何一个顺序满足条件，输出-1。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　包含一个整数n(2&lt;=n&lt;=10<sup>5</sup>)</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个可以拆解所有节点的顺序。如果不可能输出-1。如果有多个可能的顺序，输出任意一个。</div><div class='pdsec'>样例输入</div><div class='pddata'>数据1<br />\n2<br />\n数据2<br />\n3<br />\n数据3<br />\n4<br />\n数据4<br />\n16</div><div class='pdsec'>样例输出</div><div class='pddata'>数据1<br />\n0 1 0<br />\n数据2<br />\n-1<br />\n数据3<br />\n0 1 3 2 0<br />\n数据4<br />\n0 1 2 4 9 3 6 13 10 5 11 7 15 14 12 8 0</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于15%的数据2&lt;=n&lt;=10<br />\n　　对于30%的数据2&lt;=n&lt;=20<br />\n　　对于100%的数据2&lt;=n&lt;=10<sup>5</sup></div>\n","gpid":"T689","lanqiaotitle":"The Red Button","memorylimit":"256.0MB","tid":"ALGO-289","timelimit":"1.0s","title":"算法训练 The Red Button","src":"cf 325E"},{"checkpoint":"计算几何","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　StarCowraft II的测试版已经准备好了。农夫John和Bessie正在测试这个游戏，他们在与其他军队啊一对一战斗中尝试不同的策略。StarCowraft II的目标是在战斗中击败敌人的军队。<br />\n　　每个玩家的军队都在战斗。任何一支军队最多包含三种不同的单位，这三种单位拥有各自的优势，并且通过一些未知的恒定的正实数传递为玩家。cattlebruisers有强度S1, cow templars有强度S2,以及ultracows有强度S3.唯一确定的边界信息，没有单位的强度高达其他单位的100倍以上。<br />\n　　一支军队的总强度是这支军队中所有的单位的强度之和。如果一支军队拥有三个单位中的cattlebruisers共32个，那么就从cattlebruisers这一种单位中，这只军队可以获得32*S1的强度。<br />\n　　当两只军队开战时，总强度高的那支军队将会获胜。如果两只军队的总强度相等，那么会随机产生一个获胜者。<br />\n　　农夫John和Bessie总共测试了n次战斗。在第i次战斗中，John的军队拥有J1_i个cattlebruisers,J2_i个cow templars,以及J3_i个ultracows (0 &lt;= J1_i + J2_i + J3_i &lt;= 1,000).同样的，Bessie的军队拥有B1_i个cattlebruisers,B2_i个cow templars,以及B3_i个ultracows (0 &lt;= B1_i + B2_i + B3_i &lt;= 1,000).当他们的军队打完之后，John和Bessie将胜者的名字记录成'victory letter' V_i:“J”表示John获得了胜利，“B”表示Bessie获得了胜利。<br />\n　　虽然这些胜利的结果是他们拥有的唯一的信息，他们仍然希望如果给出两个对立的军队单位组成，就能够预测战斗的结果。但是对于一些战斗，他们可能无法确定哪一方是必胜的。<br />\n　　给出n次测试的结果，要求写一个程序来判断m个新的战斗的胜者（如果可能）。<br />\n　　所有测试的结果都是正确的，数据保证存在一组解满足所有条件。<br />\n　　下面给出一个例子，我们知道S1=9.0，S2=7.0，S3=4.0。<br />\n　　---- Farmer John ----    ------- Bessie ------    Battle<br />\n　　J1  J2  J3 J_Strength    B1  B2  B3 B_Strength   Outcome<br />\n　　6    5    4     105                5    4    7     101                   J<br />\n　　5    4    2      81                 3    5    5      82                    B<br />\n　　9    0   10    121               8    2    7     114                   J<br />\n　　通过这三次战斗的结果，我们能预测出之后两次新的战斗的结果：<br />\n　　---- Farmer John ----    ------- Bessie ------    Battle<br />\n　　J1  J2  J3 J_Strength    B1  B2  B3 B_Strength   Outcome<br />\n　　6    6     4     112                5   4   7    101                      J<br />\n　　FJ's army is even stronger than in test battle 1<br />\n　　9    0   10    121                 8   2   6    110                      J<br />\n　　Bessie's army is even weaker than in test battle 3<br />\n　　（以上部分可以查看未格式化的试题）</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第1行：两个整数n和m<br />\n　　第2..n+1行：第i+1行有 V_i, J1_i, J2_i, J3_i, B1_i, B2_i, B3_i七个参数，描述第i次测试。<br />\n　　接下来m行，每行六个参数J1_i, J2_i, J3_i, B1_i, B2_i, B3_i，描述一次新的战斗。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出共m行，每行一个字符——“J”表示John获得了胜利，“B”表示Bessie获得了胜利，“U”表示无法确定最后的获胜者</div><div class='pdsec'>样例输入</div><div class='pddata'>3 3<br />\nJ 6 5 4 5 4 7<br />\nB 5 4 2 3 5 5<br />\nJ 9 0 10 8 2 7<br />\n6 6 4 5 4 7<br />\n9 0 10 8 2 6<br />\n3 4 8 4 4 6</div><div class='pdsec'>样例输出</div><div class='pddata'>J<br />\nJ<br />\nU</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于50%的数据， n ≤ 100<br />\n　　对于100%的数据，n ≤ 300，m ≤ 2000</div>\n","gpid":"T688","lanqiaotitle":"StarCowraft","memorylimit":"256.0MB","tid":"ALGO-288","timelimit":"1.0s","title":"算法训练 StarCowraft","src":"USACO MAR10"},{"checkpoint":"codeforces 241F","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　TOC是一个长方形的城市，有着N*M个方格状的街区。<br />\n　　若干建筑物，双向直线的道路以及交叉路口组成了TOC。<br />\n　　每个建筑物：占恰好的一个街区。<br />\n　　每条道路：所有道路的宽度都为1个街区，并且道路都是水平的或竖直的。<br />\n　　每个交叉路口：占一个街区，位于道路的交汇处。<br />\n　　我们称两个街区是相邻的，当且仅当它们之间存在着公共边。<br />\n　　没有两条道路或两个交叉路口是相邻的。<br />\n<br />\n　　在每年的狂欢节中，TOP总会按照一条特殊的路线游行。<br />\n　　TOP会从一个街区出发，接下来经过若干个交叉路口，最终在一个街区停下。<br />\n　　TOP知道从某一个街区到其相邻的街区所花费的时间。<br />\n　　同时，从交叉路口需要花费1分钟来到达相邻的街区。<br />\n　　TOP不能经过有建筑物的地方。<br />\n<br />\n　　我们知道TOP的初始与结束位置，也知道TOP途中经过的交叉路口的顺序。<br />\n　　但他完成游行之后，他会一直呆在结束位置。<br />\n　　你的问题是，找出在他出发了K分钟之后，位于哪个位置。<br />\n　　TOP总会沿着最短的道路经过给定的交叉路口，而到达终点。<br />\n<br />\n　　注意到TOP可能会访问某些格子多于一次。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含三个整数m,n,k，接下来的m行代表这座城市的地图。<br />\n　　每一行都会包含着n个字符，每个字符代表着一个街区。<br />\n　　*字符‘#’代表一座建筑物。<br />\n　　*字符‘1’，‘2’，...，‘9’代表道路，其中的数字代表TOP从这个街区到其相邻的街区所花费的时间。<br />\n　　*字符‘a’，‘b’，...，‘z’代表这个交叉路口的名字。每个交叉路口的名字是唯一的。<br />\n<br />\n　　第i行的第j个街区用坐标表示为(i,j)。<br />\n　　接下来的一行，包含两个整数rs,cs,字符串s,和另外的两个整数re,ce。<br />\n　　TOP游行的从(rs,cs)出发，连续地经过s中的交叉路口，最后在(re,ce)结束。<br />\n<br />\n　　数据保证存在一条合法的游行路径。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第一行输出两个整数rf,cf，(rf,cf)代表在K分钟之后位于的位置。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 10 6<br />\n##########<br />\n#z1a1311b#<br />\n##########<br />\n2 3 ab 2 8</div><div class='pdsec'>样例输出</div><div class='pddata'>2 7</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于100%的数据，3&lt;=m,n&lt;=100,1&lt;=k&lt;=100000。</div>\n","gpid":"T687","lanqiaotitle":"Race","memorylimit":"256.0MB","tid":"ALGO-287","timelimit":"1.0s","title":"算法训练 Race","src":"codeforces 241F"},{"checkpoint":"DP","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有n个人坐在一张长桌边上。对于每个人，我们知道他总是说真话或是说谎。<br />\n<br />\n　　小塞尔吉问他们：你们中有几位总是说真话呢？桌子上的每个人都知道关于桌子上的所有人的所有事情（某个人说真话或是说谎）。诚实的人总是回答正确的答案，而说谎的人会回答1到n之间除了正确答案以外的任意一个整数。每个说谎的人都会选择他自己的答案，并不会考虑其他说谎的人的答案，所以两个说谎的人可能会给出不一样的答案。<br />\n<br />\n　　塞尔吉除了知道这些人对于他的问题所给的答案之外，并不知道其他的信息。他拿来一张纸并写下n个整数a<sub>1</sub>,a<sub>2</sub>,...,a<sub>n</sub>，其中a<sub>i</sub>表示第i个人的答案。得到这个序列后，塞尔吉断定，桌上至少k个人明显说谎了。<br />\n<br />\n　　塞尔吉想，有多少种不同的答案（长度为n的答案序列a）可以得出桌上恰好k个人明显说谎了。由于可能有相当多种符合描述的答案，统计答案对777777777取模后的值即可。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包括两个整数n,k,(1&lt;=k&lt;=n&lt;=2<sup>8</sup>)。保证n是2的整数次幂。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个整数——答案对777777777取模后的值。</div><div class='pdsec'>样例输入</div><div class='pddata'>样例输入1:<br />\n1 1<br />\n样例输入2:<br />\n2 1</div><div class='pdsec'>样例输出</div><div class='pddata'>样例输出1:<br />\n0<br />\n样例输出2:<br />\n2</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于20%的数据有n&lt;=8。<br />\n　　对于50%的数据有n&lt;=128。<br />\n　　对于100%的数据有1&lt;=k&lt;=n&lt;=2<sup>8</sup>。</div>\n","gpid":"T686","lanqiaotitle":"Liars and Serge","memorylimit":"256.0MB","tid":"ALGO-286","timelimit":"1.0s","title":"算法训练 Liars and Serge","src":"Codeforces 256D"},{"checkpoint":"图论 最短路 差分约束系统","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　LiLand 是一个国家，包含 <i>n</i> 个城市。城市的编号从 1 到 <i>n</i>。这个国家因为它的非常奇怪的交通运输系统而闻名。这里有许多单向的航班让你可以在两个城市之间旅行，但是这些航班的安排使得你一旦离开一个城市就永远不会再回来了。<br />\n　　在以前，每趟航班恰好飞行一个小时，但是最近由于 Lily 成为了交通运输系统的新经理，她想要改变一些航班的飞行时间。具体来说，她想要把某些航班的飞行时间改为 2 小时，使得所有从 1 号城市到 <i>n</i> 号城市的旅行路线都花费相同的时间。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入数据的第一行包含两个整数 <i>n</i> 和 <i>m</i>，表示城市的数量和航班的数量。<br />\n　　接下来 <i>m</i> 行，每行包含两个整数 <i>a<sub>i</sub></i> 和 <i>b<sub>i</sub></i> (1 ≤ <i>a<sub>i</sub></i> &lt; <i>b<sub>i</sub></i> ≤ <i>n</i>)，表示城市 <i>a<sub>i</sub></i> 到城市 <i>b<sub>i</sub></i> 有一趟单向航班。数据保证存在至少一条从城市1到城市 <i>n</i> 的路径，且航班不会形成环，任意两个城市之间不会有多趟航班。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　如果不能满足 Lily 的要求，只输出一行\"No\"(不包含引号)。<br />\n　　否则，第一行输出\"Yes\"(不包含引号)，接下来的 <i>m</i> 行，每行输出一个整数 <i>ans<sub>i</sub></i> (1 ≤ <i>ans<sub>i</sub></i> ≤ 2)，表示每条航班新的飞行时间。你的输出顺序需要与输入的航班顺序相符。<br />\n　　如果有多解，输出任意一种即可。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 3<br />\n1 2<br />\n2 3<br />\n1 3</div><div class='pdsec'>样例输出</div><div class='pddata'>Yes<br />\n1<br />\n1<br />\n2</div><div class='pdsec'>样例输入</div><div class='pddata'>4 4<br />\n1 2<br />\n2 3<br />\n3 4<br />\n1 4</div><div class='pdsec'>样例输出</div><div class='pddata'>No</div><div class='pdsec'>样例输入</div><div class='pddata'>5 6<br />\n1 2<br />\n2 3<br />\n3 5<br />\n1 4<br />\n4 5<br />\n1 3</div><div class='pdsec'>样例输出</div><div class='pddata'>Yes<br />\n1<br />\n1<br />\n1<br />\n2<br />\n1<br />\n2</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于20%的数据，2 ≤ <i>n</i> ≤ 10，1 ≤ <i>m</i> ≤ 20；<br />\n　　对于60%的数据，2 ≤ <i>n</i> ≤ 100，1 ≤ <i>m</i> ≤ 300；<br />\n　　对于100%的数据，2 ≤ <i>n</i> ≤ 1000，1 ≤ <i>m</i> ≤ 5000。</div>\n","gpid":"T685","lanqiaotitle":"Flights","memorylimit":"256.0MB","tid":"ALGO-285","timelimit":"1.0s","title":"算法训练 Flights","src":"Codeforces 241E"},{"checkpoint":"USACO Open 13","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Farmer John的奶牛最近收到一块大理石。但不幸的是，这块石头有些不完整。<br />\n　　为了说明这块石头的状况，我们就可以用一个N*N正方形网格（5 &lt;= N &lt;=300）来描述，<br />\n　　其中字符'*'代表石头的缺损部分，'.'表示石头完美无瑕的部分。<br />\n<br />\n　　奶牛要在这块大理石上雕刻一个数字\"8\"（自从奶牛们把它们的四只蹄子都劈开，可以方便地用它们的\"脚趾\"数出8以内的数，奶牛就十分喜爱数字8）。<br />\n　　然而，它们也需要你的帮助，以确定数字8在这块大理石上最佳的雕刻位置。这里有几个要求来定义一个有效的数字8：<br />\n<br />\n　　*数字8由上下两个矩形构成。<br />\n　　*数字8的上下两个矩形都满足至少有一个单元格在矩形内部。<br />\n　　*数字8顶部的矩形的底边必须为底部矩形顶边的子集。<br />\n　　*数字8只能刻在大理石完美无瑕的部分。<br />\n　　*规定数字8的得分为上矩形和下矩形的面积的乘积，它们希望得分能达到最大。<br />\n<br />\n　　例如，给出这样的一块大理石：<br />\n<img src=\"/RequireFile.do?fid=R6Ahjnfe\" width=\"178\" height=\"310\" /><br />\n<br />\n　　最优的8摆放位置如下图所示：<br />\n<img src=\"/RequireFile.do?fid=AbR9RTJy\" width=\"177\" height=\"319\" /><br />\n<br />\n　　上矩形的面积为6*9=54，而下矩形的面积则是12*6=72。所以，它的得分就是54*72=3888。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包括一个整数N，代表大理石的边长。<br />\n　　第二到N+1行，每一行描述了大理石的一行，包含着N个字符，每一个字符是\"*\"（代表缺损的部分）与\".\"（代表完美无瑕的部分）其中一个。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第一行包含一个整数，代表符合条件数字8中最大的得分。若没有一个合法的数字8，请输出-1。</div><div class='pdsec'>样例输入</div><div class='pddata'>15<br />\n...............<br />\n...............<br />\n...*******.....<br />\n.*....*.......*<br />\n.*......*....*.<br />\n....*..........<br />\n...*...****....<br />\n...............<br />\n..**.*..*..*...<br />\n...*...**.*....<br />\n*..*...*.......<br />\n...............<br />\n.....*..*......<br />\n.........*.....<br />\n...............</div><div class='pdsec'>样例输出</div><div class='pddata'>3888</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于30%的数据，5&lt;=N&lt;=80。<br />\n　　对于100%的数据，5&lt;=N&lt;=300。</div>\n","gpid":"T684","lanqiaotitle":"Figure Eight","memorylimit":"256.0MB","tid":"ALGO-284","timelimit":"1.0s","title":"算法训练 Figure Eight","src":"USACO Open 13"},{"checkpoint":"DP 计算几何","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　农场有n个木桩，现在要选择其中的一些，来围成一个凸多边形的栅栏，问最多选取多少个木桩。<br />\n　　简洁版题意：给定n个点，问最多选取其中多少个点可以构成一个凸多边形。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个数n。<br />\n　　接下来n行每行两个整数xi,yi，表示第i个点的坐标。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出1行，包含一个整数，表示最多可以选取的点数。</div><div class='pdsec'>样例输入</div><div class='pddata'>6<br />\n5 5<br />\n2 3<br />\n3 2<br />\n1 5<br />\n5 1<br />\n1 1</div><div class='pdsec'>样例输出</div><div class='pddata'>5</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　除去1 1，其他所有的点构成一个凸多边形，所以最多可以选取5个点。</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于4.5%的数据，n&lt;=65<br />\n　　对于100%的数据，n&lt;=250，1&lt;=xi,yi&lt;=1000，保证无任意三点共线。</div>\n","gpid":"T683","lanqiaotitle":"Fence","memorylimit":"256.0MB","tid":"ALGO-283","timelimit":"1.0s","title":"算法训练 Fence","src":"USACO DEC08 P4"},{"checkpoint":"Codeforces 273D","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Dima喜欢在一块长方形纸片上作自己喜欢的画。<br />\n　　一块大小为N*M的长方形纸片，包含着N行与M列，并且初始所有格子都是白色的。<br />\n　　Dima每一次作画，会把纸片上一些格子涂黑，并定义这幅“画”就是所涂黑的格子。<br />\n　　Dima喜欢一幅画仅当：<br />\n　　*包含至少一个涂黑的格子。<br />\n　　*所有的涂黑的格子形成一个连通块，换句话说，你可以从任意一个涂黑的格子移动到另一个任意涂黑的格子（一个格子可以移动到四联通的格子里）。<br />\n　　*从一个涂黑的格子(x1,y1)到另一个涂黑的格子(x2,y2)所需的最少移动步数等于|x1-x2|+|y1-y2|。<br />\n　　请帮助困惑的Dima，在N*M的长方形纸片上，他能画出多少幅自己喜欢的画呢？你只须回答答案对10^9+7取模就行了。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包括两个整数N,M，代表长方形纸片的长与宽。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第一行包含一个整数，代表答案模10^9+7的余数。</div><div class='pdsec'>样例输入</div><div class='pddata'>【样例输入1】2 2<br />\n【样例输入2】3 4</div><div class='pdsec'>样例输出</div><div class='pddata'>【样例输出1】13<br />\n【样例输出2】571</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于所有的数据，1&lt;=N,M&lt;=150。</div>\n","gpid":"T682","lanqiaotitle":"Dima and Figure","memorylimit":"256.0MB","tid":"ALGO-282","timelimit":"1.0s","title":"算法训练 Dima and Figure","src":"Codeforces 273D"},{"checkpoint":"网络流","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　SmallR是个生物学家，她最近的一次研究就是关于怎样改变狗狗的性别，换句话说，她可以把雄性狗变成雌性狗，反之亦然。<br />\n　　她正准备展示她的成果。现在她拥有n条狗，改变每条狗的花费不一定相同，这n条狗分别被编号1-n，改变编号为i的狗的代价为v<sub>i</sub>元，每条狗只能被改变一次。<br />\n　　这个实验引起了社会的广泛关注，有m个富人对实验很怀疑 ，他们都想要强行和SmallR打赌，如果SmallR赢了，那么第i个富人会给SmallR W<sub>i</sub>人民币，但是奇怪的是他们有特殊的方法来判定是否是SmallR赢了。对于第i个富人，提前地，他将指定确定的k<sub>i</sub>只狗狗以及他希望狗狗所变成的性别，只有在某一天那些指定的狗全部变为指定的性别这个富人才会认为SmallR赢了。<br />\n　　如果SmallR不能使某些不是她朋友的人满意的话她不用支付金钱给那个人，但是如果她不能使她的好朋友满意的话她必须支付给好朋友g人民币作为她对好朋友的失误的道歉。<br />\n　　SmallR希望从这个实验里获得尽可能多地金钱，请算出SmallR能得到的最多的金钱是多少。顺便一说，她可能无法获得任何金钱，甚至会亏掉金钱。这种情况下请算出她会失去的最少的金钱。SmallR是个生物学家，她最近的一次研究就是关于怎样改变狗狗的性别，换句话说，她可以把雄性狗变成雌性狗，反之亦然。<br />\n　　她正准备展示她的成果。现在她拥有n条狗，改变每条狗的花费不一定相同，这n条狗分别被编号1-n，改变编号为i的狗的代价为v<sub>i</sub>元，每条狗只能被改变一次。<br />\n　　这个实验引起了社会的广泛关注，有m个富人对实验很怀疑 ，他们都想要强行和SmallR打赌，如果SmallR赢了，那么第i个富人会给SmallR W<sub>i</sub>人民币，但是奇怪的是他们有特殊的方法来判定是否是SmallR赢了。对于第i个富人，提前地，他将指定确定的k<sub>i</sub>只狗狗以及他希望狗狗所变成的性别，只有在某一天那些指定的狗全部变为指定的性别这个富人才会认为SmallR赢了。<br />\n　　如果SmallR不能使某些不是她朋友的人满意的话她不用支付金钱给那个人，但是如果她不能使她的好朋友满意的话她必须支付给好朋友g人民币作为她对好朋友的失误的道歉。<br />\n　　SmallR希望从这个实验里获得尽可能多地金钱，请算出SmallR能得到的最多的金钱是多少。顺便一说，她可能无法获得任何金钱，甚至会亏掉金钱。这种情况下请算出她会失去的最少的金钱。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包括3个整数n , m , g (1&thinsp;≤&thinsp;n&thinsp;≤&thinsp;10<sup>4</sup>,&thinsp;0&thinsp;≤&thinsp;m&thinsp;≤&thinsp;2000,&thinsp;0&thinsp;≤&thinsp;g&thinsp;≤&thinsp;10<sup>4</sup>)。<br />\n　　第二行包括n个值为0或1的数表示每只狗狗的性别，0代表雌性，1代表雄性。<br />\n　　第三行包括n个数 v<sub>1</sub>,&thinsp;v<sub>2</sub>,&thinsp;...,&thinsp;v<sub>n</sub> (0&thinsp;≤&thinsp;v<sub>i</sub>&thinsp;≤&thinsp;10<sup>4</sup>)。<br />\n　　接下来m行每行描述一个富人，第i行第一个数是该富人所指定的狗狗的性别，接下来2个数是w<sub>i</sub> 和 k<sub>i</sub>，(0&thinsp;≤&thinsp;w<sub>i&thinsp;</sub>≤&thinsp;10<sup>4</sup>,&thinsp;1&thinsp;≤&thinsp;k<sub>i</sub>&thinsp;≤&thinsp;10)，接下来k<sub>i</sub>个数是指定的每只狗狗的编号，1&lt;=每个编号&lt;=n，第i行最后一个数表示第i个人是否是SmallR的好朋友（0代表不是，1代表是）。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个简单的数表示SmallR能获得的最大金钱，输出负数表示SmallR会失去金钱。</div><div class='pdsec'>样例输入</div><div class='pddata'>5 5 9<br />\n0 1 1 1 0<br />\n1 8 6 2 3<br />\n0 7 3 3 2 1 1<br />\n1 8 1 5 1<br />\n1 0 3 2 1 4 1<br />\n0 8 3 4 2 1 0<br />\n1 7 2 4 1 1</div><div class='pdsec'>样例输出</div><div class='pddata'>2</div><div class='pdsec'>样例输入</div><div class='pddata'>5 5 8<br />\n1 0 1 1 1<br />\n6 5 4 2 8<br />\n0 6 3 2 3 4 0<br />\n0 8 3 3 2 4 0<br />\n0 0 3 3 4 1 1<br />\n0 10 3 4 3 1 1<br />\n0 4 3 3 4 1 1</div><div class='pdsec'>样例输出</div><div class='pddata'>16</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&thinsp;≤&thinsp;<i>n</i>&thinsp;≤&thinsp;10<sup>4</sup>,&thinsp;0&thinsp;≤&thinsp;<i>m</i>&thinsp;≤&thinsp;2000,&thinsp;0&thinsp;≤&thinsp;<i>g</i>&thinsp;≤&thinsp;10<sup>4</sup><br />\n　　0&thinsp;≤&thinsp;<i>v</i><i><sub>i</sub></i>&thinsp;≤&thinsp;10<sup>4</sup><br />\n　　0&thinsp;≤&thinsp;<i>w</i><i><sub>i</sub></i>&thinsp;≤&thinsp;10<sup>4</sup>,&thinsp;1&thinsp;≤&thinsp;<i>k</i><i><sub>i</sub></i>&thinsp;≤&thinsp;10</div>\n","gpid":"T681","lanqiaotitle":"Biologist","memorylimit":"256.0MB","tid":"ALGO-281","timelimit":"1.0s","title":"算法训练 Biologist","src":"CF 311E"},{"checkpoint":"概率，动态规划","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　在游戏英雄联盟里，你可以玩一种游戏叫“ARAM”，这是“All Random, All Mid”的缩写。这个题目和它有点相似，但并不需要你了解英雄联盟。<br />\n<br />\n　　每次你开始玩“ARAM”，你会被随机分配为一种“champion”，总共n种。有一些“champion”你能更加轻松地取胜。所以如果你不幸分到一个概率低的，你会想得到一个不同的“champion”。幸运的是，游戏包含“Reroll”功能。<br />\n　　“Reroll”会重新将你随机分配为一种“champion”，但你不能任意时刻都“Reroll”。具体地说它需要耗费钱。在你玩“ARAM”游戏前，你一开始就有R的“RD”（“Reroll dollars”）。你能“Reroll”当且仅当你有至少1RD。进行一次“Reroll”操作会花费1RD。 每次游戏后，你都会得到1/G的RD（G是个整数），但你不能得到超过R的RD。如果你有R的RD，再玩一盘，你仍然是R的RD。<br />\n<br />\n　　如果你有至少1RD，并且你选择\"Reroll\"，你会花费1RD并重新随机分配成n个\"champion\"中的一个。你有可能会和之前分配给同一个。如果你不喜欢这次\"Reroll\"所得到的，并且你还有至少1RD，你可以再进行一次\"Reroll\"。只要你有至少1RD，你就能继续\"Reroll\"。<br />\n<br />\n　　举个例子，如果R=2,G=2，并且你使用了一次reroll在你第一次游戏中，第一次游戏结束后你会有1.5RD。如果你又玩了一个游戏，没有用reroll，你会有2.0RD。如果你再玩一个游戏不用reroll，你仍然是2.0RD（因为任意时刻不允许超过R）。如果你使用了两次reroll在你下一次游戏中，你就会变成0.5RD。<br />\n<br />\n　　你有一张表，记录你用第i个“champion”的胜率。你会玩10^100盘游戏并选择一种最优秀的策略。求期望的取胜次数比例。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个整数T表示数据组数。接下来T,1≤T≤100组数据，每组数据第一行输入三个整数n,R,G,1≤n≤1000,1≤R,G≤20。接下来一行n个实数p[i],0.0≤p[i]≤1.0，表示获胜概率。p[i]会是一个四位小数。<br />\n<br />\n　　由于原题是提交答案题，所以我把数据规模做了些调整。将在下面说明</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组数据，前面输出Case #数据编号:，然后输出一个实数表示期望的取胜次数所占比例。如果你的答案与标准答案绝对误差或相对误差不超过10^-10，你就会被判定为正确。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n2 1 1<br />\n1.0000 0.0000<br />\n3 1 1<br />\n1.0000 0.0000 0.5000<br />\n6 2 3<br />\n0.9000 0.6000 0.5000 0.1000 0.2000 0.8000</div><div class='pdsec'>样例输出</div><div class='pddata'>Case #1: 0.750000000000<br />\nCase #2: 0.666666666667<br />\nCase #3: 0.618728522337<pre class='pddata'>\n<span style=\"background-color: rgb(255, 255, 255);\"><font face=\"Arial, Verdana, sans-serif\"> 【数据规模和约定】</font></span>\n</pre>\n<br />\n对于测试点1~2，有T=100,n,R,G≤10<br />\n对于测试点3~5，有T=1,n≤200，R,G≤3<br />\n对于测试点6~8，有T=10,n≤200,R,G≤3<br />\n对于测试点9~10，有T=1,n≤1000,R,G≤3<br />\n对于测试点11~14，有T=10,n≤500,R,G≤20<br />\n对于测试点15~20，有T=1,n≤1000,R,G≤20</div>\n","gpid":"T680","lanqiaotitle":"ARAM","memorylimit":"256.0MB","tid":"ALGO-280","timelimit":"5.0s","title":"算法训练 ARAM","src":"GCJ 2014 Final F"},{"checkpoint":"CCF计算机软件能力认证 201409","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定n个不同的整数，问这些数中有多少对整数，它们的值正好相差1。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含一个整数n，表示给定整数的个数。<br />\n　　第二行包含所给定的n个整数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个整数，表示值正好相差1的数对的个数。</div><div class='pdsec'>样例输入</div><div class='pddata'>6<br />\n10 2 6 3 7 8</div><div class='pdsec'>样例输出</div><div class='pddata'>3</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　值正好相差1的数对包括(2, 3), (6, 7), (7, 8)。</div><div class='pdsec'>评测用例规模与约定</div><div class='pdcont'>　　1&lt;=n&lt;=1000，给定的整数为不超过10000的非负整数。</div>\n","gpid":"T672","lanqiaotitle":"相邻数对","memorylimit":"256.0MB","tid":"ALGO-279","timelimit":"1.0s","title":"算法训练 相邻数对","src":"CCF计算机软件能力认证 201409"},{"checkpoint":"CCF计算机软件能力认证 201409","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　在一个定义了直角坐标系的纸上，画一个(x1,y1)到(x2,y2)的矩形指将横坐标范围从x1到x2，纵坐标范围从y1到y2之间的区域涂上颜色。<br />\n　　下图给出了一个画了两个矩形的例子。第一个矩形是(1,1) 到(4, 4)，用绿色和紫色表示。第二个矩形是(2, 3)到(6, 5)，用蓝色和紫色表示。图中，一共有15个单位的面积被涂上颜色，其中紫色部分被涂了两次，但在计算面积时只计算一次。在实际的涂色过程中，所有的矩形都涂成统一的颜色，图中显示不同颜色仅为说明方便。<br />\n<img src=\"/RequireFile.do?fid=f2GfHNjA\" width=\"365\" height=\"344\" /><br />\n　　给出所有要画的矩形，请问总共有多少个单位的面积被涂上颜色。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含一个整数n，表示要画的矩形的个数。<br />\n　　接下来n行，每行4个非负整数，分别表示要画的矩形的左下角的横坐标与纵坐标，以及右上角的横坐标与纵坐标。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个整数，表示有多少个单位的面积被涂上颜色。</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n1 1 4 4<br />\n2 3 6 5</div><div class='pdsec'>样例输出</div><div class='pddata'>15</div><div class='pdsec'>评测用例规模与约定</div><div class='pdcont'>　　1&lt;=n&lt;=100，0&lt;=横坐标、纵坐标&lt;=100。</div>\n","gpid":"T671","lanqiaotitle":"画图","memorylimit":"256.0MB","tid":"ALGO-278","timelimit":"1.0s","title":"算法训练 画图","src":"CCF计算机软件能力认证 201409"},{"checkpoint":"后缀数组","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个长度为n的数串，求至少出现k 次的最长重复子串的长度，这k 个子串可以重叠。保证有子串出现至少k次。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行：两个整数n, k;<br />\n　　第二行：2到n + 1行：n个整数，这n个整数组成了一个数串。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个整数，表示最长重复子串的长度。</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n8 2\n</pre>\n<pre class='pddata'>\n1\n</pre>\n<pre class='pddata'>\n2<br style=\"font-family: Arial, Verdana, sans-serif; font-size: 12px; white-space: normal;\" />\n</pre>\n<pre class='pddata'>\n3<br style=\"font-family: Arial, Verdana, sans-serif; font-size: 12px; white-space: normal;\" />\n</pre>\n<pre class='pddata'>\n2<br style=\"font-family: Arial, Verdana, sans-serif; font-size: 12px; white-space: normal;\" />\n</pre>\n<pre class='pddata'>\n3<br style=\"font-family: Arial, Verdana, sans-serif; font-size: 12px; white-space: normal;\" />\n</pre>\n<pre class='pddata'>\n2<br style=\"font-family: Arial, Verdana, sans-serif; font-size: 12px; white-space: normal;\" />\n</pre>\n<pre class='pddata'>\n3<br style=\"font-family: Arial, Verdana, sans-serif; font-size: 12px; white-space: normal;\" />\n</pre>\n<pre class='pddata'>\n1\n</pre>\n<div class='pdsec'>样例输出</div><pre class='pddata'>\n4\n</pre>\n<div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　0 ≤ n ≤ 20000, 2 ≤ <i>k</i> ≤ <i>n，0</i>≤ <i>数串中的整数</i>≤ 1000000</div>\n","gpid":"T670","lanqiaotitle":"后缀数组——最长重复子串","memorylimit":"256.0MB","tid":"ALGO-277","timelimit":"100ms","title":"算法训练 后缀数组——最长重复子串","src":"poj3261"},{"checkpoint":"动态规划","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Yaroslav称数列a<sub>1</sub>，a<sub>2</sub>，… ，&thinsp;a<sub>r</sub>为良好的，当它满足：<br />\n　　1.| a<sub>1</sub> – a<sub>2</sub> | = 1，| a<sub>2</sub> – a<sub>3</sub> | = 1，…，| a<sub>r-1</sub> – a<sub>r</sub> | = 1，| a<sub>r </sub>– a<sub>1</sub> |= 1<br />\n　　2. <img src=\"/RequireFile.do?fid=gnbbgMHq\" width=\"100\" height=\"47\" /><br />\n　　Yaroslav称数列b1，b2，… ，&thinsp;br为优秀的，当它满足：<br />\n　　1.  数列中的元素不下降<br />\n　　2.  满足 1 ≤ r ≤ n 、 1 ≤ b<sub>i</sub> ≤ m<br />\n　　3.  通过重排数列中的元素可以得到至少一个至多k个不同的良好数列。<br />\n　　Yaroslav有三个整数n，m，k 。他需要知道有多少个不同的优秀数列。帮助Yaroslav！考虑到答案可能相当大，将答案模1000000007  (10<sup>9</sup>+7)<br />\n　　两个数列{x<sub>n</sub>}、{y<sub>n</sub>}被认为不同，仅当存在一个位置i，使x<sub>i</sub>≠y<sub>i</sub></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　单独一行三个整数n，m，k</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　单独一行输出答案</div><div class='pdsec'>样例输入</div><div class='pddata'>样例1：  1 1 1<br />\n样例2：  3 3 3<br />\n样例3：  28 15 34</div><div class='pdsec'>样例输出</div><div class='pddata'>样例1：  0<br />\n样例2：  2<br />\n样例3：  54737</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　30%的数据   n，m，k≤8<br />\n　　60%的数据   n，m，k≤60<br />\n　　100%的数据   n，m，k≤100</div>\n","gpid":"T669","lanqiaotitle":"Yaroslav and Arrangements","memorylimit":"256.0MB","tid":"ALGO-276","timelimit":"1.0s","title":"算法训练 Yaroslav and Arrangements","src":"Codeforces 301E"},{"checkpoint":"DP","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Manao在一家建筑公司工作。最近，有一项在儿童公园内建设Wall Bar的订单。Manao被委托设计一个能使公司最节省资金的建设方案。<br />\n　　在回顾了Wall Bar 的正常规格之后，Manao发现许多要求是模糊的，决定按照公司的利益处理。他的最终设计描述如下：<br />\n　　1、我们定义单位长度，建筑物中间那根管子高度为n。<br />\n　　2、在高度为1、2...n的地方，恰好有一根水平的横杆从中间的杆子连向四个方向中的某一个预先固定好的杆子上。<br />\n　　3、如果两根横杆的距离不超过h，且方向相同，那么一个孩子可以从一个一根横杆爬到另一根上。在地上的孩子，可以爬到任何一根高度在1-h之间的横杠上。在Manao的建筑物上，一个从地面出发的孩子至少能到达一根高度在n-h+1、n-h+2...n的横杠。<br />\n　　Manao想知道有多少种设计方案满足上述要求。这个数字可能会非常大，输出其除以1000000009 (10^9+&thinsp;9)的余数即可。两个设计方案被认为是不同的，当且仅当在某个高度他们的横杠方向不同。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一行，包含两个空格隔开的正整数，n和h。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行，输出答案mod 1000000009 (10^9+&thinsp;9)。</div><div class='pdsec'>样例输入</div><div class='pddata'>5 1</div><div class='pdsec'>样例输出</div><div class='pddata'>4</div><div class='pdsec'>样例输入</div><div class='pddata'>4 2</div><div class='pdsec'>样例输出</div><div class='pddata'>148</div><div class='pdsec'>样例输入</div><div class='pddata'>4 3</div><div class='pdsec'>样例输出</div><div class='pddata'>256</div><div class='pdsec'>样例输入</div><div class='pddata'>5 2</div><div class='pdsec'>样例输出</div><div class='pddata'>376</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1≤<i>n</i>≤1000, 1≤<i>h</i>≤<i>min</i>(<i>n</i>,30)</div><div class='pdsec'>提示</div><div class='pdcont'>　　考虑几个h=2的设计方案。<br />\n　　一个第一层方向为d1,第二层方向为d2...的方案被描述成串d1d2...dn。<br />\n　　方案1231，孩子无法爬到3或4的高度。<br />\n　　方案414141，孩子可以到达5的高度：先到达高度1、3后即可。也可以到达6的高度，先到达2、4即可。<br />\n　　方案123333，孩子不能到达最上面的两个横杠。<br />\n　　方案323323，可以通过1、3、4到达高度6.<br />\n<br />\n<table cellspacing=0 cellpadding=2px style='border-collapse:collapse;' class='table table-striped table-horver'><tbody><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'> </td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'> </td><td style='border:solid 1.0pt'><img width=\"390\" height=\"298\" src=\"/RequireFile.do?fid=6Y7FMHjQ\" /></td></tr></tbody></table><br />\n　　左边是一个正常的Wall Bar的样子,右边是Manao的一种设计方案。</div>\n","gpid":"T668","lanqiaotitle":"Wall Bars","memorylimit":"512.0MB","tid":"ALGO-275","timelimit":"1.0s","title":"算法训练 Wall Bars","src":"CF 268D"},{"checkpoint":"三分、贪心、网络流","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Bessie的生日快到了, 她希望用D (1 &lt;= D &lt;= 100,000)天来庆祝. 奶牛们的注意力不会太集中, 因此Bessie想通过提供玩具的方式来使它们高兴. 她已经计算出了第i天需要的玩具数T_i (1 &lt;= T_i &lt;= 50).<br />\n　　Bessie的幼儿园提供了许多服务给它们的奶牛程序员们, 包括一个每天以Tc (1 &lt;= Tc&lt;= 60)美元卖出商品的玩具店. Bessie想尽可能的节省钱, 但是Farmer John担心没有经过消毒的玩具会带来传染病(玩具店卖出的玩具是经过消毒的).<br />\n　　有两种消毒的方式. 第1种方式需要收费C1美元, 需要N1个晚上的时间; 第2种方式需要收费C2美元, 需要N2个晚上的时间(1 &lt;= N1 &lt;= D; 1 &lt;= N2 &lt;= D; 1 &lt;= C1 &lt;= 60;1 &lt;= C2 &lt;= 60). Bessie在party结束之后把她的玩具带去消毒. 如果消毒只需要一天,那么第二天就可以拿到; 如果还需要一天, 那么第三天才可以拿到.<br />\n<br />\n　　作为一个受过教育的奶牛, Bessie已经了解到节约的意义. 帮助她找到提供玩具的最便宜的方法.</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第 1 行: 六个用空格隔开的整数 D, N1, N2, C1, C2, Tc<br />\n　　第 2..D+1 行: 第 i+1 行包含一个整数: T_i</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第 1 行: 提供玩具所需要的最小费用.</div><div class='pdsec'>样例输入</div><div class='pddata'>4 1 2 2 1 3<br />\n8<br />\n2<br />\n1<br />\n6</div><div class='pdsec'>样例输出</div><div class='pddata'>35</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　第 1 天   买8个玩具, 花去$24; 送2个玩具去快洗, 6个慢洗.<br />\n　　第 2 天   取回2个快洗的玩具, 花去$4. 送1个玩具去慢洗.<br />\n　　第 3 天   取回6个慢洗的玩具, 花去$6.<br />\n　　第 4 天   取回所有的玩具(与现有的加在一起正好6个), 花去$1. 这样就用了最少的钱.</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1 &lt;= D &lt;= 100,000<br />\n　　1 &lt;= T_i &lt;= 50<br />\n　　1 &lt;= N1 &lt;= D; 1 &lt;= N2 &lt;= D; 1 &lt;= C1 &lt;= 60;1 &lt;= C2 &lt;= 60</div><div class='pdsec'>注释</div><div class='pdcont'>　　快洗不一定快于慢洗，也不一定贵于慢洗</div>\n","gpid":"T667","lanqiaotitle":"Toys","memorylimit":"256.0MB","tid":"ALGO-274","timelimit":"1.0s","title":"算法训练 Toys","src":"Usaco Nov08 Gold"},{"checkpoint":"dfs","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　饲养员Xenia有n（n&gt;1）只站成一排的马。每只马都有它自己的独一无二的号码。最开始的时候，从左数第i只马编号为i，也就是说，马的号码序列是下面这样（从左到右）：1，2，3，……，n<br />\n　　Xenia在演出之前训练这些马。在练习期间，她会给马命令。每个命令是一对数l，r（1&lt;=l&lt;r&lt;=n）。命令l，r意思是从左数第l个位置到第r个位置上的马要被重新排列。站在l，r位置上的马交换位置；l+1，r-1位置上的马交换位置；以此类推。也就是说，[l，r]位置内的马反向排列<br />\n　　例如，如果Xenia命令l=2，r=5并且命令之前马的编号序列为（2，1，3，4，5，6），那么命令之后序列就会是（2，5，4，3，1，6）。<br />\n　　我们知道在训练时，Xenia最多最多给出三个命令。现在你已经知道了最后马的编号序列，请给出训练时Xenia的命令是什么。注意你不需要使得命令数最小，只需要找到一个在三次命令以内的正确的方案。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包括一个n表示马的数量。第二行包含n个不同的数a1，a2，……，an（1&lt;=ai&lt;=an），ai表示训练完成后从左数第i只马的编号。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第一行包含一个整数k表示Xenia训练时给出的命令数。接下来k行每行输出两个数，第i+1行输出li和ri（1&lt;=li&lt;ri&lt;=n）——Xenia训练时给出的命令。\t保证至少出现一个方案。如果出现多组方案，输出任意一组即可。</div><div class='pdsec'>样例输入</div><div class='pddata'>6<br />\n2 1 4 3 6 5</div><div class='pdsec'>样例输出</div><div class='pddata'>3<br />\n1 2<br />\n3 4<br />\n5 6</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;n&lt;=1000</div>\n","gpid":"T666","lanqiaotitle":"Three Swaps","memorylimit":"256.0MB","tid":"ALGO-273","timelimit":"1.0s","title":"算法训练 Three Swaps","src":"codeforces 339E"},{"checkpoint":"计算几何","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Luyi在平面上放了n个圆，第i个圆的圆心在(xi,yi)。最开始所有圆半径都为0，然后所有圆同时开始变大，在时刻t(t&gt;0)所有圆的半径都为t。我们可以想象成一些黑色的实心圆放在一个无穷大的白色平面上，每个时刻都会存在一些黑色和白色的联通快。需要注意一点，随着圆的增大，越来越多的圆会相交。<br />\n<img src=\"/RequireFile.do?fid=daRLGdRm\" width=\"300\" height=\"239\" /><br />\n　　我们定义一个白色的封闭区域为一个’洞 ’，例如图中包含两个红色边框的’洞’，随着圆的增大，一些新的洞会出现，也会有一些旧的洞小时。Luyi想知道最后一个洞消失的时刻。换句话说，你应该找一个最早的时刻，使得之后再也没有洞。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行仅有一个整数n(1≤n≤100)<br />\n　　接下来n行每行两个整数(xi,yi)(-10^4≤xi,yi≤10^4)，描述每个圆的圆心。<br />\n　　输入保证没有两个圆圆心相同。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出最后一个洞消失的时刻。如果从始至终都没有洞出现的话输出-1。<br />\n　　输出和标准答案相差10^-4之内都被认为是正确的。</div><div class='pdsec'>样例输入</div><div class='pddata'>样例输入一<br />\n3<br />\n0 0<br />\n1 1<br />\n2 2<br />\n样例输入二<br />\n4<br />\n0 0<br />\n0 2<br />\n2 2<br />\n2 0<br />\n样例输入三<br />\n4<br />\n0 1<br />\n0 -1<br />\n-2 0<br />\n4 0</div><div class='pdsec'>样例输出</div><div class='pddata'>样例输出一<br />\n-1<br />\n样例输出二<br />\n1.414214<br />\n样例输出三<br />\n2.125000</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　0&lt;n&lt;=100, -10^4≤xi,yi≤10^4。</div>\n","gpid":"T665","lanqiaotitle":"The Last Hole!","memorylimit":"256.0MB","tid":"ALGO-272","timelimit":"1.0s","title":"算法训练 The Last Hole!","src":"Codeforces 274C"},{"checkpoint":"dp","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　又一个世界末日正在到来！这回的元凶是Julya部落日历。<br />\n　　这个部落的海狸非常了解数学。Smart Beaver，一个考古学家，得到了一个上面有着魔法数字的神圣板块。从老海狸那得到了这样的翻译：<br />\n　　愿Great Beaver保佑你们！愿你们的第三只眼永不会对真理视而不见！取走魔法数字，从中减去一个数字（这个数字必须在魔法数字的数位中出现过）并得到一个新的魔法数字。重复这个操作直到一个魔法数字等于0。地球将会站在Three Beavers上，时间等同于你执行的减法次数。<br />\n　　不同的减法序列显然能得到不同的操作数。但是Smart Beaver已经做好最坏的打算并且让你计算最少他需要的操作数来把魔法数字减至0。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一行包含魔法数字n (0&lt;=n&lt;=10^18)</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个整数——把给定的魔法数字减至0所需最少操作数。</div><div class='pdsec'>样例输入</div><div class='pddata'>24</div><div class='pdsec'>样例输出</div><div class='pddata'>5</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　0&lt;=n&lt;=10^18</div>\n","gpid":"T664","lanqiaotitle":"The Great Julya Calendar","memorylimit":"256.0MB","tid":"ALGO-271","timelimit":"1.0s","title":"算法训练 The Great Julya Calendar","src":"CODEFORCES 331C"},{"checkpoint":"暴力 几何","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　进行专业的体育运动需要努力锻炼，更需要顶尖设计师设计的装备。比如说网球。你不仅得体魄强健，还得拥有一把史诗级的球拍。在这道题里，你的任务是对网球业的发展作出杰出贡献，设计一种具有革命意义的全新理念的史诗级球拍！<br />\n<br />\n　　这将是一种三角形的球拍——不仅仅是三角形，更是一个正三角形！设计完外形后你要在这个框架上穿线。正三角形的每条边上有n个小孔，把该边分成了等距的n+1段。每条边上，离每个顶点最近的m个小孔是用来改善气流的通风孔，因此线不能穿过这些孔。源于一种创新的理念，球拍网需要连成一个钝角三角形，三个角分居正三角形框架三条不同的边上。请你帮忙统计，有多少种可行的三角形球拍网设计方案。<br />\n<br />\n　　两个三角形球拍网不同，当且仅当它们固定在某一位置拍照片是不同的。（即不考虑旋转同构）<br />\n<img src=\"/RequireFile.do?fid=TQt644YD\" width=\"407\" height=\"368\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一行两个整数n、m。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个整数，表示可行的三角形球拍网设计方案的数量。</div><div class='pdsec'>样例输入</div><div class='pddata'>10 1</div><div class='pdsec'>样例输出</div><div class='pddata'>210</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于30%的数据：n≤1001。<br />\n　　对于100%的数据：1≤n≤32000，0≤m≤n/2。</div>\n","gpid":"T663","lanqiaotitle":"Tennis Rackets","memorylimit":"256.0MB","tid":"ALGO-270","timelimit":"3.0s","title":"算法训练 Tennis Rackets","src":"Codeforces 309D"},{"checkpoint":"最短路","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　大雨无情地侵蚀着亚特兰蒂斯的土地，并终将毁灭它。为了组织人民撤离，你想知道亚特兰蒂斯多快就会毁灭殆尽。<br />\n　　你有一幅亚特兰蒂斯的地图。地图是一个矩形的网格，每个格子里有一个整数表示该位置海拔为多少米。网格外面是大海，海拔为零。所有为海拔零的格子都是水域，所有海拔大于零的格子都是陆地，没有海拔小于零的区域。<br />\n　　如果两个格子有公共边，水就能从高的格子流向低的格子。如果两个有公共边的格子一样高，水能向任意一边流。<br />\n　　因为雨非常大，所以如果一个格子里的水流不走，就会积在那里，直到水平面足够高使其得以流走。地图外面的大海可以接收任意多的水。举个例子，比如下面这幅地图：<br />\n<img src=\"/RequireFile.do?fid=edRa4Dj3\" width=\"90\" height=\"62\" /><br />\n　　低洼地区会积水。我们把积水地区的海拔加上水深称为水平面，上面地图的水平面将会是：<br />\n<img src=\"/RequireFile.do?fid=4A98gr8j\" width=\"93\" height=\"65\" /><br />\n　　注意中间地域的0，尽管它是水域，因为它不与外界相连，所以它也会积水。边界上的0与外界相连，所以来自8的水可以经它流走。<br />\n　　水流动的方向决定于水平面的高低。如果与一个区域相邻（有公共边）有若干个区域的水平面都比它低，那么它的水就会流向其中最低的一个。如果最低的也有多个，流向哪里没有所谓，这在下文会提到。<br />\n　　现在流水侵蚀开始了。每天，一个格子被侵蚀掉多少——海拔降低多少——决定于水怎么流过它。如果水从S流到与S相邻的T，那么S的海拔将降低min(S的水平面-T的水平面,M)。所有的侵蚀都在同一时间——一天结束的时候——发生。例如，M=5时，上面的地图描绘的土地就会被侵蚀成下面这个样子：<br />\n<img src=\"/RequireFile.do?fid=7ytJT2he\" width=\"87\" height=\"59\" /><br />\n　　一天的侵蚀过后，多余的水会流走：当一片区域的水平面高于与它相邻的区域的水平面时，水就会从高处流到低处，直到两个区域水面相平。水依然回像第一天那样积累。第二天，水平面变成：<br />\n<img src=\"/RequireFile.do?fid=B9Jejydb\" width=\"88\" height=\"62\" /><br />\n　　又过了一天的侵蚀，地图又变成下面这样：<br />\n<img src=\"/RequireFile.do?fid=rTTMm4M9\" width=\"90\" height=\"57\" /><br />\n　　……这时亚特兰蒂斯的居民就要紧急疏散了。你的任务是计算要过多少天亚特兰蒂斯的海拔高度会全变成0。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行读入一个整数T，表示接下来有T组数据。<br />\n　　每组数据由包含三个整数H、W、M的一行开始，这三个整数分别表示地图的长、宽和一天最大的侵蚀高度。<br />\n　　接下来H行每行W个整数，其中的第i行第j个数表示地图中(i,j)格子的高度。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组测试数据，输出一行“Case #x: y”（不包含引号），其中x表示测试数据的编号，y表示多少天就能侵蚀完整个亚特兰蒂斯。</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n3 6 5<br />\n5 9 9 9 9 9<br />\n0 8 9 0 2 5<br />\n3 9 9 9 9 9<br />\n3 6 3<br />\n3 8 10 11 10 8<br />\n7 5 2 12 8 8<br />\n6 9 11 9 8 4</div><div class='pdsec'>样例输出</div><div class='pddata'>Case #1: 3<br />\nCase #2: 5</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　共20个测试点，每个点5分。<br />\n　　测试点1~4：1≤T≤10, 1≤H,W≤10, 1≤M≤100, 0≤所有海拔≤100。<br />\n　　测试点5~8：1≤T≤50, 1≤H,W≤20, 1≤M≤100, 0≤所有海拔≤100。<br />\n　　测试点9~20：1≤T≤10, 1≤H,W≤20, 1≤M≤10^15, 0≤所有海拔≤10^15。</div>\n","gpid":"T662","lanqiaotitle":"Rains Over Atlantis","memorylimit":"256.0MB","tid":"ALGO-269","timelimit":"2.0s","title":"算法训练 Rains Over Atlantis","src":"Google Code Jam World Final 2011 B"},{"checkpoint":"计算几何","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　在一个正方形的空旷的房间里，有两个点光源：一个是红色的，另一个是绿色的。<br />\n　　房间里还有n个圆柱。<br />\n<br />\n　　光线沿直线传播并且会被墙壁和圆柱所吸收。由于光线无法穿过圆柱，房间会产生阴影区域。<br />\n　　房间里有些区域没有光线到达，是黑色的。<br />\n　　有些区域只有红光到达，是红色的。<br />\n　　有些区域只有绿光到达，是绿色的。<br />\n　　还有些区域既有红光到达也有绿光到达，是黄色的。<br />\n<br />\n　　请你统计房间里四种颜色每一种的总面积分别是多少。<br />\n　　注意，所求面积不包括圆柱所占的面积。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行两个整数x1、y1，表示红光的光源为（x1，y1）。<br />\n　　第一行两个整数x2、y2，表示绿光的光源为（x2，y2）。<br />\n　　第三行一个整数n，为圆柱的个数。<br />\n　　接下来n行，每行三个整数x、y、r，描述一个圆柱，圆形在（x，y）半径为r。<br />\n<br />\n　　房间是0≤x,y≤100所描述的正方形区域，四条边为墙壁。圆柱、墙壁、光源是相互分离的，互相不会相交或者触碰。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第一行一个实数表示黑色面积。<br />\n　　第二行一个实数表示红色面积。<br />\n　　第三行一个实数表示绿色面积。<br />\n　　第四行一个实数表示黄色面积。<br />\n<br />\n　　你的输出被认为正确，当且仅当你和标准输出的绝对误差或者相对误差不超过1e-5。</div><div class='pdsec'>样例输入</div><div class='pddata'>5 50<br />\n95 50<br />\n1<br />\n50 50 10</div><div class='pdsec'>样例输出</div><div class='pddata'>0.7656121<br />\n1437.986<br />\n1437.986<br />\n6809.104</div><div class='pdsec'>样例说明</div><div class='pdcont'><img src=\"/RequireFile.do?fid=n7JMjTjA\" width=\"283\" height=\"283\" /></div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于40%的数据：n=1。<br />\n　　对于100%的数据：0≤n≤50，0≤x,y≤100。</div>\n","gpid":"T661","lanqiaotitle":"Lights","memorylimit":"256.0MB","tid":"ALGO-268","timelimit":"2.0s","title":"算法训练 Lights","src":"Google Code Jam 2009 World Final - F"},{"checkpoint":"动态规划 树状数组","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　这个故事发生在...<br />\n　　很久以前，国王Tryone the Fair有4个大臣。第1个大臣（国王的顶级建议者）每周要被支付7块金子。第2个大臣每周要被支付4块金子。第3、4个大臣每周都要被支付6块金子。不幸的是，一天，Tryone偶然地忘了照片复制器中的大臣补偿表，并且这个表格在Kingdom Times的头版的末尾。就此，第2个大臣要求向国王讲话，因为他自己的薪水比比自己等级低的第3个大臣的薪水低而心烦意乱。<br />\n　　他的不公平的国王Tryone看到没有更好的方法比解雇第3个大臣更好的方法了。毕竟，降低第3个大臣的薪水，提升第2个大臣的薪水，或者改变工作的头衔，在国王看来，都是不公平的解决方法。并且我们有什么资格质问国王Tyrone呢？当然，解雇第3个大臣不能解决这个问题。第2个大臣继续抱怨，因为他的薪水仍然比第4个大臣的薪水低。因此国王Tryone也解雇了第4个大臣。这时，这两个剩下的大臣都没有抱怨了，所有人在这以后都快乐地生活。<br />\n　　...等一下。我把这个搅乱了。对不起。我的记忆不是它之前的那样。等一下...对。国王Tyrone是公平的。4个大臣。被支付的钱数分别是7、4、6和6。啊，对。结局是这样的...<br />\n　　当第2个大臣抱怨不公平的时候，国王Tyrone解雇了第1个大臣。有些人也许说这有一点这有点残酷，因为第1个大臣无论如何都与这个事情没有关系，但是我们不应该质问国王Tyrone。显然，第二个大臣仍然抱怨，因此国王Tyrone简单地解雇了他。剩下的两个大臣，每个人都被支付了至少比任何比自己等级低的大臣高的薪水，因此没有人抱怨。并且这以后所有人快乐地生活。<br />\n　　这样更好...我觉得。也许？现在我不再确定了。我确定有N个大臣，并且我清晰地记得他们的薪水。我也知道每当一个大臣的薪水比比他等级低的大臣的薪水低的时候，某个人就会抱怨，并且某个大臣就会被解雇；但是任何大臣，不管他是否与这个问题有任何关系，都有可能被解雇。一直有大臣会被解雇，直到没有人抱怨，因为薪水的总和是不会增加的。这时，解雇停止了。但是我记不得大臣被解雇的顺序。<br />\n　　你能帮助我修复我的故事吗？或者至少告诉我我能够讲出多少个不同的故事？两个故事不同当且仅当两个故事中被解雇的大臣的顺序不同。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入中的第一行包含测试数据的组数。之后是T组数据。每组数据包含两行。第一行包含一个整数N，第二行包含N个整数，按照第1个到第N个大臣的顺序描述所有大臣的薪水。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组测试数据，输出一行，格式为\"Case #x: y\"，这里x是测试数据的编号（从1开始），y表示可能讲出的故事的数量，对10007取模。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n4<br />\n7 4 6 6<br />\n4<br />\n90 80 70 60<br />\n2<br />\n7 8</div><div class='pdsec'>样例输出</div><div class='pddata'>Case #1: 14<br />\nCase #2: 1<br />\nCase #3: 2</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于30%的数据，1&lt;=T&lt;=20，1&lt;=N&lt;=100；<br />\n　　对于另外70%的数据，1&lt;=T&lt;=5，1&lt;=N&lt;=2000。<br />\n　　对于全部的数据，所有大臣的薪水均为正整数且不超过10000。</div>\n","gpid":"T660","lanqiaotitle":"Let Me Tell You a Story","memorylimit":"128.0MB","tid":"ALGO-267","timelimit":"5.0s","title":"算法训练 Let Me Tell You a Story","src":"GCJ 2013 Final E"},{"checkpoint":"hash","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　一个字符串的子串是该字符串的一段连续子序列，如bca是abcabc的子串，而cc不是。<br />\n<br />\n　　一个重复块(repeating block)由一个字符串与自身连接而成，如abcabc是一个重复块，而abcabd, ababab不是。<br />\n<br />\n　　你有一个由拉丁字符组成的字符串。每一步你要找到它的子串中最短的重复块，如果有多于一个，你必须选择最左边的那个。你要将那个形如XX(X - 某个字符串)的重复块替换成X，换句话说你要删除其中的一个X。重复以上步骤直到字符串中不存在重复块。<br />\n<br />\n　　最终的字符串会是怎样的？看样例解释来更清楚地理解问题描述。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一行，一个由小写拉丁字符组成的字符串。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出做完所有操作后的字符串。</div><div class='pdsec'>样例输入</div><div class='pddata'>aaaabaaab</div><div class='pdsec'>样例输出</div><div class='pddata'>ab</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=输入字符串长度&lt;=50000</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　字符串变换过程如下：aaaabaaab &thinsp;→&thinsp; aaabaaab &thinsp;→&thinsp; aabaaab &thinsp;→&thinsp; abaaab &thinsp;→&thinsp; abaab &thinsp;→&thinsp; abab &thinsp;→&thinsp; ab</div>\n","gpid":"T659","lanqiaotitle":"Have You Ever Heard About the Word?","memorylimit":"256.0MB","tid":"ALGO-266","timelimit":"1.0s","title":"算法训练 Have You Ever Heard About the Word?","src":"CODEFORCES 319D"},{"checkpoint":"数学","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有一个n行m列的表格G，G[i][j]=gcd(i,j)。gcd(i,j)是i和j的最大公约数。<br />\n　　给你一个正整数数列a[1],a[2],...,a[k]。如果这个序列在G的某行的连续位置出现，则这个序列在表格中出现。<br />\n　　具体地说，就是存在i,j（1&lt;=i&lt;=n,1&lt;=j&lt;=m-k+1)，使得gcd(i,j+L-1)=a[L](1&lt;=L&lt;=k）。<br />\n　　询问序列a是否在G中出现。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行是n,m,k。<br />\n　　第二行是由空格隔开的k个整数a[1],a[2],...,a[k]。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　出现则输出“YES”，否则输出“NO”。</div><div class='pdsec'>样例输入</div><div class='pddata'>100 100 5<br />\n5 2 1 2 1</div><div class='pdsec'>样例输出</div><div class='pddata'>YES</div><div class='pdsec'>样例输入</div><div class='pddata'>100 8 5<br />\n5 2 1 2 1</div><div class='pdsec'>样例输出</div><div class='pddata'>NO</div><div class='pdsec'>样例输入</div><div class='pddata'>100 100 7<br />\n1 2 3 4 5 6 7</div><div class='pdsec'>样例输出</div><div class='pddata'>NO</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n,m&lt;=10^12,k&lt;=10000,数列a中的每一个数都不超过10^12。</div>\n","gpid":"T658","lanqiaotitle":"GCD Table","memorylimit":"256.0MB","tid":"ALGO-265","timelimit":"1.0s","title":"算法训练 GCD Table","src":"codeforces 338D"},{"checkpoint":"BFS","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Old MacDonald有一个农场和大小为(10<sup>10</sup>&thinsp;+&thinsp;1)&thinsp;×&thinsp;(10<sup>10</sup>&thinsp;+&thinsp;1)平方米的巨大的土豆种植地。这块田地被分成正方形的小块，每块占地一平方米。<br />\n　　Old MacDonald知道科罗拉多土豆甲虫将要入侵，并且会破坏收成。Old MacDonald想在一些土地上喷上杀虫剂。<br />\n　　所以，Old MacDonald去了田里，站在田地中间的那个小块中间并将这个格子撒上杀虫剂。现在，他将要通过一系列的移动来在更多田地喷洒杀虫剂。每次移动的时候，Old MacDonald会在上下左右四个方向中选择一个并移动整数米。当他移动的时候，他会在走过的每个格子上喷洒杀虫剂。也就是说，和Old MacDonald的移动轨迹有任何交点的小块都会被撒上杀虫剂。<br />\n　　当Old MacDonald停止喷洒杀虫剂后，他将他所有的移动记录在一张纸上。现在，他想知道，有多少小块不会受到科罗拉多甲虫入侵的影响。<br />\n　　我们知道，科罗拉多甲虫的入侵按照以下顺序展开。一开始，一些土地边缘的小块被入侵。接着，任何没有撒过杀虫剂且有一个相邻（与其有公共边的）小块被感染的尚未被感染的土地也会被感染。帮助Old MacDonald计算有多少小块不会受到科罗拉多甲虫的感染。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含一个正整数n，表示Old MacDonald的移动步数。<br />\n　　接下来n行包含了对Old MacDonald移动的描述。其中的第i行描述第i次移动。每次移动通过“di xi”的形式给出。di是一个字母描述移动的方向，（”L”,”R”,”U”,”D”分别表示左右上下），xi表示这次移动的距离。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行，不会被科罗拉多甲虫感染的土地数量。</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\nR 8<br />\nU 9<br />\nL 9<br />\nD 8<br />\nL 2</div><div class='pdsec'>样例输出</div><div class='pddata'>101</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n<span lang=\"EN-US\">7<br /> R 10<br /> D 2<br /> L 7<br /> U 9<br /> D 2<br /> R 3<br /> D 10</span>\n</pre>\n<div class='pdsec'>样例输出</div><div class='pddata'>52</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1≤n≤1000, 1≤x≤1000000</div>\n","gpid":"T657","lanqiaotitle":"Colorado Potato Beetle","memorylimit":"256.0MB","tid":"ALGO-264","timelimit":"1.0s","title":"算法训练 Colorado Potato Beetle","src":"CF 243C"},{"checkpoint":"","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　小X的作业是老师给他布置的，题目很简单，求出第N个斐波那契数 mod P的值。小X怎么想也想也想不出来，只好求助于你了。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行为数据组数T。<br />\n　　第二行开始，以下T行，每行为老师给小X布置的作业中的N和P。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　包含T行，每行是一个作业的答案。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n7 3<br />\n1000000 89<br />\n987654321 30000</div><div class='pdsec'>样例输出</div><div class='pddata'>0<br />\n55<br />\n19111</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于50%的数据，T&lt;=100，N&lt;=10000。<br />\n　　对于100%的数据，T&lt;=10000，N&lt;=1000000000，P&lt;=30000。<br />\n　　斐波那契数的第0个是1。</div>\n","gpid":"T649","lanqiaotitle":"小X的暑假作业","memorylimit":"128.0MB","tid":"ALGO-263","timelimit":"1.0s","title":"算法训练 小X的暑假作业","src":"小X的暑假模拟赛"},{"checkpoint":"","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　新的一年又开始了。<br />\n　　在这一年里，有几场对little Josh来说意义重大的线上赛。虽然这些线上赛的开始日期还没有确定，但是主办方都已将日程安排公布（即线上赛开始后的每一天是否有比赛）。<br />\n　　在某些情况下，一天可能有多场比赛。对于能一天秒100场比赛的little Josh来说，他更喜欢比赛较多的日子。具体来说，对于每一个拥有S个比赛的日子，little Josh会获得S^2点愉悦值。little Josh的初始愉悦值为0。<br />\n　　下面这张图展示了有3场线上赛的一年，每种颜色代表一场线上赛。在这种情况下little Josh的愉悦值为20。其中一场线上赛在这一年的第二天开始，一场在第五天，一场在第六天。<br />\n<img src=\"/RequireFile.do?fid=fgtM2Th5\" width=\"331\" height=\"116\" /><br />\n　　这一年有N天，每场线上赛的开始日期等概率地分布在每一天上（即：在每一天开始的概率都是1/N）。现在最大的问题就是little Josh在这一年的期望愉悦值是多少。<br />\n　　作为一个神犇，little Josh不想知道近似值，他想知道准确的答案。总共有T场线上赛，所以有N^T种不同的安排方式。little Josh将用带分数K+A/B来表示他的期望愉悦值（K是正整数，A是小于B的非负整数，当A=0时B必须是1，否则A和B必须互质）<br />\n　　假如一场线上赛的某次比赛的日期在第二年，那么不应该被算入总愉悦值内。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行N和T含义如题。<br />\n　　接下来T行格式为：m d[2] d[3] ... d[m]，表示这场线上赛有m次比赛，分别在比赛开始后第 d[1] d[2] ... d[m] 天（比赛开始的当天算第一天）。注意：d[1]总是等于1。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出K+A/B格式如题。</div><div class='pdsec'>样例输入</div><div class='pddata'>4 2<br />\n3 2 4<br />\n2 3</div><div class='pdsec'>样例输出</div><div class='pddata'>5+1/8</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于100%的数据，1&lt;=N&lt;=10^9,2&lt;=m&lt;=50,1&lt;d[2]&lt;d[3]&lt;...&lt;d[m]&lt;=10000,T&lt;=50</div>\n","gpid":"T648","lanqiaotitle":"Year of More Code Jam","memorylimit":"256.0MB","tid":"ALGO-262","timelimit":"1.0s","title":"算法训练 Year of More Code Jam","src":"Google Code Jam 2009 Final A"},{"checkpoint":"状压DP","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Xenia非常喜欢拼图。她特别喜欢由多米诺骨牌组成的拼图。图片中就是一个这样的拼图。<br />\n<br />\n<img src=\"/RequireFile.do?fid=4dBFmjH5\" width=\"524\" height=\"145\" /><br />\n<br />\n　　一个拼图是一个3 × n的桌子，除掉一些禁止块(forbidden cells)（图中的黑色正方形），并包含多米诺骨牌。一个拼图被称作合法当它符合以下条件：<br />\n<br />\n　　每个多米诺骨牌覆盖正好两个非禁止块；<br />\n　　没有两个多米诺骨牌覆盖桌子上的同一块区域；<br />\n　　有且仅有一个非禁止块没被任何多米诺骨牌覆盖（图中的圆点）。<br />\n<br />\n　　要完成一个拼图，你需要用若干步把空格子从开始位置移动某个指定位置。一步移动是在保证拼图合法的情况下，把一个多米诺骨牌移到空格子里。横向的多米诺骨牌只能横向移动，纵向的多米诺骨牌只能纵向移动。你不能旋转多米诺骨牌。图中表示了一个合法的移动。<br />\n<br />\n　　Xenia有一个3 × n的带禁止块和一个圆圈标记(circle-marked)的格子的桌子。Xenia还有很多完全一样的多米诺骨牌。现在Xenia想知道，如果她把多米诺骨牌放在桌子上，能有多少种不同的合法的拼图。同时，Xenia要求圆圈标记的格子没有被覆盖。这个拼图还必须至少能移动一次。<br />\n<br />\n　　帮助Xenia统计上述拼图的种数。这个数字可能很大，输出它对1000000007(10^9+7)取模的余数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个整数n - 拼图的大小。接下来3行，每行n个字符，描述这个桌子。第i行的第j个字符为\"X\"表示对应的格子为禁止块；为\".\"表示非禁止块；为\"O\"表示它是圆圈标记的。<br />\n<br />\n　　保证有且仅有一个格子是圆圈标记的。保证所有与圆圈标记的各种相邻的格子都是非禁止块。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个整数 - 问题的答案对1000000007(10^9 + 7)取模的余数。</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n....X<br />\n.O...<br />\n...X.</div><div class='pdsec'>样例输出</div><div class='pddata'>1</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n.....<br />\n.O...<br />\n.....</div><div class='pdsec'>样例输出</div><div class='pddata'>2</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　3&lt;=n&lt;=10^4</div><div class='pdsec'>提示</div><div class='pdcont'>　　两个拼图被认为是不同的当存在一对格子在一个拼图中有一个多米诺骨牌而在另一个中没有。</div>\n","gpid":"T647","lanqiaotitle":"Xenia and Dominoes","memorylimit":"256.0MB","tid":"ALGO-261","timelimit":"1.0s","title":"算法训练 Xenia and Dominoes","src":"CODEFORCES 342D"},{"checkpoint":"","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Polycarpus的生活总是满足“一些好事，然后一些坏事，然后一些好事”这样的规律。所以Polycarpus认为接下来的n天也是满足这样的规律的。<br />\n　　Polycarpus知道，接下来会发生w件两两不同的好事和b件两两不同坏事，每天至少发生一件事，每天要么全部发生好事要么全部发生坏事。<br />\n　　由于Polycarpus的规律，这n天会先有若干天发生好事，再有若干天发生坏事，再有若干天发生好事。(若干代指&gt;0)<br />\n　　要求统计事件发生的方案数（每天发生的事的顺序也不一样），答案取模10^9+9输出</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　三个正整数n,w,b</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个正整数，表示方案数<br />\n　　一些</div><div class='pdsec'>样例输入</div><div class='pddata'>4 2 2</div><div class='pdsec'>样例输出</div><div class='pddata'>4</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　3&lt;=n&lt;=4000<br />\n<br />\n　　2&lt;=w&lt;=4000<br />\n<br />\n　　1&lt;=b&lt;=4000<br />\n<br />\n　　w+b&gt;=n</div>\n","gpid":"T646","lanqiaotitle":"White, Black and White Again","memorylimit":"256.0MB","tid":"ALGO-260","timelimit":"1.0s","title":"算法训练 White, Black and White Again","src":"CF 306C"},{"checkpoint":"构造","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　你要构造一个有N个结点的竞赛图，使得对任意两个结点u和v（u≠v），从u到v的最短距离不超过2。<br />\n　　竞赛图就是基图为无向完全图的有向图（每对结点之间有一条有向边相连，且无自环）。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入只有一个正整数N（3≤N≤1000），表示要求的竞赛图的结点数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　如果满足要求的竞赛图不存在，则输出-1。<br />\n　　否则输出一个N行N列的01矩阵（0表示没有边，1表示有边），要符合竞赛图的条件。</div><div class='pdsec'>样例输入一</div><div class='pdcont'>　　3</div><div class='pdsec'>样例输出一</div><div class='pdcont'>　　0 1 0<br />\n　　0 0 1<br />\n　　1 0 0</div><div class='pdsec'>样例输入二</div><div class='pdcont'>　　4</div><div class='pdsec'>样例输出二</div><div class='pdcont'>　　-1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于40%的数据，N≤10；<br />\n　　对于70%的数据，N≤300；<br />\n　　对于100%的数据，N≤1000。</div>\n","gpid":"T645","lanqiaotitle":"Tournament-graph","memorylimit":"256.0MB","tid":"ALGO-259","timelimit":"1.0s","title":"算法训练 Tournament-graph","src":"Codeforces 323B (Testing Round #7)"},{"checkpoint":"数学","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Bike是个十分喜欢数学的聪明孩子。他发明了“可旋转数”，其灵感来自于142857。<br />\n　　正如你所见，142857是一个十分神奇的数，因为所有从它通过旋转得到的数都是它自己乘以1,2,3...,6（从1到数的长度）。旋转一个数就是将它的最后一位数字放到最前面。比如说，通过旋转12345你能够得到这些数：12345,51234,45123,34512,23451。值得一提的是这里允许有前导0。因而4500123和0123450都能够通过旋转0012345得到。你可以看看142857满足条件的原因了。下面的6个方程都在十进制下成立：<br />\n　　142857 * 1 = 142857;<br />\n　　142857 * 2 = 285714;<br />\n　　142857 * 3 = 428571;<br />\n　　142857 * 4 = 571428;<br />\n　　142857 * 5 = 714285;<br />\n　　142857 * 6 = 857142<br />\n　　现在，Bike提出了一个问题。他将“可旋转数”推广到了任意进制b。如上所示，142857是十进制下的一个“可旋转数”。另外一个例子是二进制下的0011。下面的4个方程都在二进制下成立：<br />\n　　0011 * 1 = 0011;<br />\n　　0011 * 10 = 0110;<br />\n　　0011 * 11 = 1001;<br />\n　　0011 * 100 = 1100<br />\n　　他想要找到最大的b(1 &lt; b &lt; x)，满足在b进制下存在一个长度为n的正“可旋转数”（允许有前导零）。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　仅一行包含两个用空格分隔的整数n,x。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行一个整数，表示你找到的最大的b。如果不存在满足条件的b，输出-1。</div><div class='pdsec'>样例输入I</div><div class='pdcont'>　　6 11</div><div class='pdsec'>样例输出I</div><div class='pdcont'>　　10</div><div class='pdsec'>样例输入II</div><div class='pdcont'>　　5 8</div><div class='pdsec'>样例输出II</div><div class='pdcont'>　　-1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于20%的数据，n &lt;= 10, x &lt;= 15<br />\n　　对于50%的数据，x &lt;= 10<br />\n　　对于100%的数据，1 &lt;= n &lt;= 5 * 10^6，2 &lt;= x &lt;= 10^9</div>\n","gpid":"T644","lanqiaotitle":"Rotatable Number","memorylimit":"256.0MB","tid":"ALGO-258","timelimit":"1.0s","title":"算法训练 Rotatable Number","src":"Codeforces303D"},{"checkpoint":"构造、最短路","updatetime":"2020-04-03","content":"<div class='pdsec'>题目背景</div><div class='pdcont'>　　Vlada 公主喜欢在草坪和森林中游玩。在一个美好的晴天，公主正漫步于森林中。突然她惊讶地发现她的影子消失了！“啊呀！”，思索片刻公主便开始在森林寻找她的影子。<br />\n　　正常情况下影子只会懒散地睡在公主脚下。但是在这么热的夏天，影子也厌倦了这种生活，于是她决定和 Vlada 玩玩。</div><div class='pdsec'>问题描述</div><div class='pdcont'>　　她们所在的森林可以被表示为平面上一系列的整数方格。在这里，公主和影子只能沿上下左右一格一格移动。一些格子长有树木，而影子和公主都不允许进入这样的格子。不幸的是，现在是森林的困难时期，所以这里几乎没有树。。。<br />\n　　最开始公主在 (v<sub>x</sub>,v<sub>y</sub>) ，而影子藏在 (s<sub>x</sub>,s<sub>y</sub>) 。公主，影子和树木都在不同的格子上。<br />\n　　影子在捉弄公主。一旦公主移动一格，只要可行，影子也在同一方向移动一格（如果这个格子没有树木）；否则，影子不移动。影子是虚无的，所以她们并不互相干扰。<br />\n　　如果在某次移动后影子和公主在同一格子，那么我们说影子被抓住了。 Vlada 正设法抓住影子！你可以吗？</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入数据第一行包含她们的坐标 v<sub>x</sub>,v<sub>y</sub>,s<sub>x</sub>,s<sub>y</sub> 和树的数量 m(0≤m≤400) 。接下来 m 行表示树的坐标。<br />\n　　所有坐标都是 -100 到 100 间的整数（包括100和-100）。公主和影子和树木都在不同的格子上。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　如果不可能抓到，输出\"-1\"（没有引号）。<br />\n　　否则输出一个只包含\"L\",\"R\",\"D\",\"U\"的字母序列，表示公主的移动方案，要求最后能够抓住影子。（L——左移，R——右移，U——上，D——下；x轴的正方向是右，y轴的是上）<br />\n　　移动步数不能超过10<sup>6</sup>。公主的移动必须是正确的，即不能让公主走到长有树木的格子上。最后一回合之前公主和影子可以在同一位置。</div><div class='pdsec'>样例输入</div><div class='pddata'>0 0 1 0 1<br />\n0 1</div><div class='pdsec'>样例输出</div><div class='pddata'>LLUR</div><div class='pdsec'>样例输入</div><div class='pddata'>5 0 3 0 8<br />\n2 -1<br />\n2 0<br />\n2 1<br />\n3 -1<br />\n4 1<br />\n4 0<br />\n3 1<br />\n4 -1</div><div class='pdsec'>样例输出</div><div class='pddata'>-1</div><div class='pdsec'>样例输入</div><div class='pddata'>3 2 1 1 3<br />\n0 1<br />\n1 0<br />\n0 0</div><div class='pdsec'>样例输出</div><div class='pddata'>DLL</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　蓝色点代表中心(0,0)方格的左下角。<br />\n　　粉色代表公主，灰色代表影子，黑色代表树。:<br />\n　　样例1：<img src=\"http://espresso.codeforces.com/53914ec8dc41cae8614795afdc5111a23466c10c.png\" /><br />\n<br />\n　　样例2：<img src=\"http://espresso.codeforces.com/d51249e4e9ecb6f53745fe586efaa9e1bba72448.png\" /><br />\n<br />\n　　样例3：<img src=\"http://espresso.codeforces.com/93aebd1309873c9c7295360a8ff0741f152eb16f.png\" /></div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　m(0≤m≤400)<br />\n　　读入的坐标绝对值&lt;=100</div>\n","gpid":"T643","lanqiaotitle":"Princess and Her Shadow","memorylimit":"256.0MB","tid":"ALGO-257","timelimit":"1.0s","title":"算法训练 Princess and Her Shadow","src":"CODEFORCES 317E"},{"checkpoint":"","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Polycarpus喜欢凸多边形，尤其喜欢每个角角度都相同，每条边长度都不相同的凸多边形。你需要在知晓给定的顶点数的情况下，为他描绘出这样的任意一个凸多边形。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入文件包含一个整数——凸多边形的顶点数</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出有n行，每行两个实数表示凸多边形的顶点的坐标，按逆时针顺序给出。顶点坐标的绝对值不应该超过1000000。凸多边形的变成应该在[1,1000]范围内（不一定是整数）。精度在10^-3，如果无解请输出“No solution”<br />\n　　（不包含引号）</div><div class='pdsec'>样例输入</div><div class='pddata'>8</div><div class='pdsec'>样例输出</div><div class='pddata'>1.000 0.000<pre class='pddata'>\n7.000 0.000<br />9.000 2.000<br />9.000 3.000<br />5.000 7.000<br />3.000 7.000<br />0.000 4.000<br />0.000 1.000\n</pre>\n</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　3&lt;=n&lt;=100</div>\n","gpid":"T642","lanqiaotitle":"Polygon","memorylimit":"256.0MB","tid":"ALGO-256","timelimit":"1.0s","title":"算法训练 Polygon","src":"codeforces306D"},{"checkpoint":"搜索，动态规划","updatetime":"2020-04-03","content":"<div class='pdsec'>试题来源</div><div class='pdcont'>　　Codeforces 261E</div><div class='pdsec'>问题描述</div><div class='pdcont'>　　Maxim 得到了一个计算器，这个计算器有两个整数单元，一开始，第一个单元包含数字1，第二个单元包含数字0。 这个计算器支持一以下两种操作：<br />\n<br />\n　　1.假设第一个单元的数字为a，第二个单元的数字为b，那么将第二个单元的数字改成b+1。<br />\n<br />\n　　2.假设第一个单元的数字为a，第二个单元的数字为b，那么将第一个单元的数字改成a*b。<br />\n<br />\n　　现在Maxim 想知道，有多少个正整数x(l&lt;=x&lt;=r)满足， 存在一种方式从计算器初始状态开始，操作不超过p步之后使得第一个单元中的数字为x。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　共一行，为三个空格隔开的正整数(2&lt;=l&lt;=r&lt;=10^9, 1&lt;=p&lt;=100)</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出仅一行一个整数ans，即为问题所求。</div><div class='pdsec'>样例输入I</div><div class='pdcont'>　　2 10 3</div><div class='pdsec'>样例输出I</div><div class='pdcont'>　　1</div><div class='pdsec'>样例输入II</div><div class='pdcont'>　　2 111 100</div><div class='pdsec'>样例输出II</div><div class='pdcont'>　　106</div><div class='pdsec'>样例输入III</div><div class='pdcont'>　　2 111 11</div><div class='pdsec'>样例输出III</div><div class='pdcont'>　　47</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　30%的数据满足，2&lt;=l&lt;=r&lt;=10^6,1&lt;=p&lt;=15。<br />\n<br />\n　　另外20%的数据满足，2&lt;=l=r&lt;=10^9,1&lt;=p&lt;=100。<br />\n<br />\n　　100%的数据满足，2&lt;=l&lt;=r&lt;=10^9,1&lt;=p&lt;=100.</div>\n","gpid":"T641","lanqiaotitle":"Maxim and Calculator","memorylimit":"256.0MB","tid":"ALGO-255","timelimit":"4.0s","title":"算法训练 Maxim and Calculator","src":""},{"checkpoint":"dp 概率","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　相信很多人都知道GCJ的规则，现在让我们来大致回顾一下。在每场比赛中，参赛者有几道题目可以做，每道题目有两个部分:简单(small input)和困难(large input)。在你做出简单部分之前是不允许做困难部分的。除此之外，没有其他做题顺序的限制。也就是说，你可以先做(某题，比如说)A题的简单部分，然后去做其他题目，再接着回来做A的困难部分。解出每道题目的简单或者困难部分后，会得到一些分数，前提是你的解是正确的。参赛者能够立刻知道自己的简单部分的解的提交的结果，但是困难部分的解的正确与否只能在比赛结束公布。最后排名以得分从高到底排序，得分相同按罚时从低到高排序。注意<img src=\"/fckeditor/editor/images/smiley/msn/regular_smile.gif\" />：GCJ的罚时指的是最后一次提交正确解的时间。<br />\n　　Vasya打算去做GCJ，他可以在比赛开始后快速（忽略所有读题时间）读题。然后对于n道题目，他知道以下5个值。<br />\n　　1、<i>scoreSmall_i</i> 表示的是做出简单部分之后得到的分数。<i>scoreLarge_</i><i>i</i> 指的是做出困难部分后得到的另外分数。也就是说在第i题你的最大得分为<i>scoreSmall_</i><i>i</i>&thinsp;+&thinsp;<i>scoreLarge_</i><i>i。</i><br />\n　　2、 <i>timeSmall_</i><i>i</i> 表示的是做第i题的简单部分所花的时间。<i>timeLarge_</i><i>i表示从简单解法，优化到困难的解法的所需额外时间。</i><br />\n　　3、Vasya是一个身经百战的coder。所以他一旦写完简单部分的解，就可以1A。然而对于困难部分，他有<i>probFail_</i><i>i</i> 的概率FST(fail system test)。并且值得注意的是<img src=\"/fckeditor/editor/images/smiley/msn/regular_smile.gif\" />，如果FST，那么就不会得到困难部分的分数，并且这次提交也不算一个正确解的提交。<br />\n　　比赛总共有t时间。读题和提交题的时间忽略不计。并且值得注意的是<img src=\"/fckeditor/editor/images/smiley/msn/regular_smile.gif\" />：Vasya不允许在一道题目的其中一个部分中提交两次解。<br />\n　　Vasya想要正确安排时间和解题顺序，然后使得得到的期望分数尽可能高，同时保证期望罚时尽可能少。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行为两个整数n和t。<br />\n　　接着n行，每行为4个整数和1个实数：<br />\n<i>scoreSmall_</i><i>i</i>,&thinsp;<i>scoreLarge_</i><i>i</i>,&thinsp;<i>timeSmall_</i><i>i</i>,&thinsp;<i>timeLarge_</i><i>i</i>,&thinsp;<i>probFail_</i><i>i</i><br />\n<br />\n　　其中<i>probFail_</i><i>i是实数，输入数据中最多保留6位小数。</i></div><div class='pdsec'>输出格式</div><pre class='pddata'>\n两个实数，最大的期望得分和对应的尽可能小的期望罚时。当你的答案与标准答案的精度误差（相对或绝对）不超过1e-9时，被认为是正确的。\n</pre>\n<div class='pdsec'>样例输入</div><pre class='pddata'>\n3 40<br />10 20 15 4 0.500000<br />4 100 21 1 0.990000<br />1 4 1 1 0.250000<br />\n【样例输出】\n</pre>\n<pre class='pddata'>\n24.0 18.875<br />\n【数据规模和约定】\n<span style=\"white-space: normal; color: rgb(34, 34, 34); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 19.600000381469727px; background-color: rgb(255, 255, 255);\">(</span><span class=\"tex-span\" style=\"white-space: normal; font-size: 18px; font-family: 'times new roman', sans-serif; color: rgb(34, 34, 34); line-height: 19.600000381469727px; background-color: rgb(255, 255, 255);\">1&thinsp;≤&thinsp;<i>n</i>&thinsp;≤&thinsp;1000,&thinsp;1&thinsp;≤&thinsp;<i>t</i>&thinsp;≤&thinsp;1560</span><span style=\"white-space: normal; color: rgb(34, 34, 34); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 19.600000381469727px; background-color: rgb(255, 255, 255);\">)</span><br style=\"color: rgb(0, 0, 0); font-family: Arial, Verdana, sans-serif; font-size: 12px; line-height: normal; white-space: normal; background-color: rgb(255, 255, 255);\" /><span style=\"white-space: normal; color: rgb(34, 34, 34); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 19.600000381469727px; background-color: rgb(255, 255, 255);\">(</span><span class=\"tex-span\" style=\"white-space: normal; font-size: 18px; font-family: 'times new roman', sans-serif; color: rgb(34, 34, 34); line-height: 19.600000381469727px; background-color: rgb(255, 255, 255);\">1&thinsp;≤&thinsp;<i>scoreSmall</i><span class=\"lower-index\" style=\"font-size: 13px; line-height: 0; position: relative; vertical-align: baseline; bottom: -0.25em;\"><i>i</i></span>,&thinsp;<i>scoreLarge</i><span class=\"lower-index\" style=\"font-size: 13px; line-height: 0; position: relative; vertical-align: baseline; bottom: -0.25em;\"><i>i</i></span>&thinsp;≤&thinsp;10^<span class=\"upper-index\" style=\"font-size: 13px; line-height: 0; position: relative; vertical-align: baseline; top: -0.5em;\">9</span>,&thinsp;1&thinsp;≤&thinsp;<i>timeSmall</i><span class=\"lower-index\" style=\"font-size: 13px; line-height: 0; position: relative; vertical-align: baseline; bottom: -0.25em;\"><i>i</i></span>,&thinsp;<i>timeLarge</i><span class=\"lower-index\" style=\"font-size: 13px; line-height: 0; position: relative; vertical-align: baseline; bottom: -0.25em;\"><i>i</i></span>&thinsp;≤&thinsp;1560,&thinsp;0&thinsp;≤&thinsp;<i>probFail</i><span class=\"lower-index\" style=\"font-size: 13px; line-height: 0; position: relative; vertical-align: baseline; bottom: -0.25em;\"><i>i</i></span>&thinsp;≤&thinsp;1</span><span style=\"white-space: normal; color: rgb(34, 34, 34); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 19.600000381469727px; background-color: rgb(255, 255, 255);\">)</span>\n样例解释\n依次为\n<pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0.25em; font-family: Consolas, 'Lucida Console', 'Andale Mono', 'Bitstream Vera Sans Mono', 'Courier New', Courier; line-height: 1.25em; white-space: pre-wrap; word-wrap: break-word;\">\n1、第1题的简单部分\n</pre>\n<div class='pddata'>2、第3题的简单部分3、第3题的困难部分4、第1题的困难部分其中第1和2步可以调换如果你在最后解了第2题的简单部分，而不是第3题的两个部分，那么虽然你的得分都是24，但是罚时将会达到38。</div>\n","gpid":"T640","lanqiaotitle":"Google Code Jam","memorylimit":"256.0MB","tid":"ALGO-254","timelimit":"1.0s","title":"算法训练 Google Code Jam","src":"Codeforcces #277 D"},{"checkpoint":"状压DP","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　一个长方形的网格每个格子里有一个小写英文字母。我们称这个网格是双排序(doubly sorted)的，当每一行从左到右都是不下降的，每一列从上到下也是不下降的。在下面的例子中，前两个网格是双排序的，而后两个不是。<br />\n<br />\n　　abc\t\tace\t\taceg\t\tbase<br />\n　　def\t\tade\t\tcdef\t\tbase<br />\n　　ghi\t\tbdg\t\txxyy\t\tbase<br />\n<br />\n<br />\n　　给你一个部分格子填了英文字母的网格。你的任务是计算有多少种方式把剩下的格子填满，使所得网格是双排序的。答案可能很大，你只要输出方案数对10007取模的余数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个整数T，表示数据组数。接下来有T组数据。每组数据的第一行有两个整数R和C，表示网格的行数和列数。接下来R行，每行有一个长度为C的字符串，表示部分填写的网格。每个字符是一个小写英文字母，或'.'（表示这个格子没有被填写）。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对每组数据，输出一行。这行包含\"Case #X: y\"，X是这组数据的编号（从1开始），y是可能的双排序网格的个数，模10007。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n2 2<br />\nad<br />\nc.<br />\n3 3<br />\n.a.<br />\na.z<br />\n.z.<br />\n4 4<br />\n....<br />\n.g..<br />\n.cj.<br />\n....</div><div class='pdsec'>样例输出</div><div class='pddata'>Case #1: 23<br />\nCase #2: 7569<br />\nCase #3: 0</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1 ≤ T ≤ 3<br />\n　　1 ≤ R, C ≤ 10<br />\n　　网格中每个字符都是'.'或一个小写英文字母。<br />\n　　对于MAX(R,C)=10的数据T&lt;=2。</div>\n","gpid":"T639","lanqiaotitle":"Doubly-sorted Grid","memorylimit":"512.0MB","tid":"ALGO-253","timelimit":"4.0s","title":"算法训练 Doubly-sorted Grid","src":"GCJ 2009 Final C"},{"checkpoint":"博弈 SG函数","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Dima和Anya喜欢玩各种游戏。现在Dima想出了一个新游戏想和Anya玩。<br />\n<br />\n　　Dima在纸上写下n对整数(l[i],r[i])(1&lt;=l[i]&lt;r[i]&lt;=p)。然后玩家轮流进行操作。轮到自己时，可以进行下面的操作：<br />\n　　1.选择第i对数(1&lt;=i&lt;=n)，满足r[i]-l[i]&gt;2;<br />\n　　2.将第i对数替换为( l[i]+floor((r[i]-l[i])/3) , l[i]+2*floor((r[i]-l[i])/3) )或者( l[i] , r[i]-floor((r[i]-l[i])/3) )。floor(x)表示向下取整。<br />\n<br />\n　　不能进行操作的玩家则输。<br />\n<br />\n　　当然，Dima希望先进行操作的Anya赢得游戏。所以Dima需要写下这样的n对整数(l[i],r[i])(1&lt;=l[i]&lt;r[i]&lt;=p)，使得如果两个玩家都采取最优策略，先操作的玩家取得胜利。请计算Dima有多少种这样的方法。输出方案数模1000000007(10^9+7)后的值。<br />\n<br />\n　　如果这些数对被按照不同的顺序写了下来，则将其视作不同的方法。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含两个空格隔开的整数n,p。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行包含答案模1000000007(10^9+7)后的值。</div><div class='pdsec'>样例输入</div><div class='pddata'>2 2</div><div class='pdsec'>样例输出</div><div class='pddata'>0</div><div class='pdsec'>样例输入</div><div class='pddata'>4 4</div><div class='pdsec'>样例输出</div><div class='pddata'>520</div><div class='pdsec'>样例输入</div><div class='pddata'>100 1000</div><div class='pdsec'>样例输出</div><div class='pddata'>269568947</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于20%的数据，1&lt;=n&lt;=10,1&lt;=p&lt;=10；<br />\n　　对于100%的数据，1&lt;=n&lt;=1000,1&lt;=p&lt;=10^9。</div>\n","gpid":"T638","lanqiaotitle":"Dima and Game","memorylimit":"256.0MB","tid":"ALGO-252","timelimit":"1.0s","title":"算法训练 Dima and Game","src":"Codeforces 273E"},{"checkpoint":"","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　众所周知，我们生活在黑客帝国的母体里很久了。现在由海狸来统治第七母体。<br />\n　　尼尔是一只海狸。当尼尔能看到他即将去的或者已经去过的地方所发生的事情，他会说\"WOW\"。具体地：<br />\n　　尼尔的城市可以用一个n个点m条边的有向图来描述，没有两条边连接了同一对点（另外，不会同时有A-&gt;B的边和B-&gt;A的边，也没有自环）。尼尔经过一条边的时候，尼尔会看到一些点的编号。无论他经过同一条边多少次，这些编号都是同样的、并按照同样顺序给出的。<br />\n　　一条路径能让尼尔说\"WOW\"，当且仅当，这条路径上的点构成的序列，和这条路径上的边上的编号构成的序列完全一样。<br />\n　　要求统计长度为1,2,...,2*n的能让尼尔说\"WOW\"的路径的个数。答案关于10^9+7取模输出</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行两个正整数n,m<br />\n<br />\n　　之后m行每行一开始有3个数x,y,len，表示有一条x-&gt;y的写了len个点编号的边，之后len个正整数描述这些编号</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　共2n行，第i行一个正整数表示长度为i的合法路径的个数</div><div class='pdsec'>样例输入</div><div class='pddata'>6 6<br />\n1 2 2 1 2<br />\n2 3 1 3<br />\n3 4 2 4 5<br />\n4 5 0<br />\n5 3 1 3<br />\n6 1 1 6</div><div class='pdsec'>样例输出</div><div class='pddata'>1<br />\n2<br />\n1<br />\n1<br />\n2<br />\n1<br />\n1<br />\n2<br />\n1<br />\n1<br />\n2<br />\n1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=50<br />\n<br />\n　　m&lt;=n*(n-1)/2<br />\n<br />\n　　边上写的数字的总个数&lt;=10^5</div>\n","gpid":"T637","lanqiaotitle":"Deja Vu","memorylimit":"256.0MB","tid":"ALGO-251","timelimit":"1.0s","title":"算法训练 Deja Vu","src":"CF 331E2"},{"checkpoint":"概率 期望 数学","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　大街上建好了一排摩天大楼。摩天大楼的数量是在 2 到 314!（314的阶乘，一个非常大的数）中均匀随机选择的。每座摩天大楼的高度（即楼层数）是被独立地随机选择的：对于每个正整数 i，楼层数为 i 的概率为 2<sup>-i</sup>。如果一座摩天大楼有 i 层，那么它的楼层被编号为 0 到 i - 1。<br />\n　　为了加快中转运输的效率，摩天大楼间修建了一些滑索。一座摩天大楼的第 i 层和另一座摩天大楼的第 i 层之间有滑索当且仅当两楼之间没有摩天大楼有第 i 层。<br />\n　　Alice和Bob想数一数有多少座摩天大楼。<br />\n　　Alice是个严谨认真的人，她想知道摩天大楼数量的准确值。于是她把计数器初始化为 1，从最左边的摩天大楼开始往右走，每次走到一个摩天大楼就把计数器加上 1，直到她到达最右边的摩天大楼。<br />\n　　Bob很没耐心，他想尽快完成任务。于是他把计数器初始化为 1，从最左边的摩天大楼开始利用滑索从一座摩天大楼滑到另一座。因为恐高，每次他会忽略那些高度（即所在楼层编号）大于 h 的滑索，然后在剩下的往右滑的滑索中选一个最高的。由于Bob使用滑索时滑得太快以至于他无法数清经过了多少座摩天大楼，所以他直接将计数器加上 2<sup>i</sup>，其中 i 是他当前所在的楼层编号。他会一直持续这个过程直到他到达最右边的摩天大楼。<br />\n　　考虑下面这个例子。这里有 6 栋楼，高度从左到右分别为 1, 4, 3, 4, 1, 2，并且 h = 2。Alice的计数器初始为 1 然后加了 5 次 1 得到结果是 6。Bob的计数器初始为 1 然后依次加上 1, 4, 4, 2 得到结果 12。注意Bob会忽略最高的那个滑索因为他恐高（h = 2）。<br />\n<img src=\"/RequireFile.do?fid=L4qBMrQ8\" width=\"416\" height=\"241\" /><br />\n　　Bob的计数器的值在这张图的最上面，Alice的计数器的值在这张图最下面。图中的横线是滑索，绿色虚线表示Bob的路线，粉色虚线表示Alice的路线。摩天大楼上的数字是楼层编号，Bob经过的滑索上的数字是他计数器在此处的增加量。<br />\n　　当Alice和Bob到达最右边的摩天大楼时，他们会比较计数器的值。现在给出Alice的计数器的值或者Bob的计数器的值，请你求出另一人的计数器的值的期望。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行是一个名字，为\"Alice\"或\"Bob\"。第二行包括两个整数 n 和 h （n ≥ 2, h ≥ 0）。如果名字是\"Alice\"，那么 n 表示Alice到达最右边的摩天大楼时她的计数器的值，否则 n 表示Bob到达最右边的摩天大楼时他的计数器的值。h 表示Bob愿意使用的滑索的最高楼层编号。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　如果给出的是Bob的计数器的值，输出一个实数表示Alice的计数器的期望值；如果给出的是Alice的计数器的值，输出一个实数表示Bob的计数器的期望值。<br />\n　　你的答案被认为是正确的当且仅当你的答案与标准答案的绝对误差或相对误差不超过 10<sup>-9</sup>。</div><div class='pdsec'>样例输入一</div><div class='pdcont'>　　Alice<br />\n　　3 1</div><div class='pdsec'>样例输出一</div><div class='pdcont'>　　3.500000000</div><div class='pdsec'>对于样例一的解释</div><div class='pdcont'>　　Bob的计数器有 62.5% 的概率是 3, 有 25% 的概率是 4, 有 12.5% 的概率是 5。</div><div class='pdsec'>样例输入二</div><div class='pdcont'>　　Bob<br />\n　　2 30</div><div class='pdsec'>样例输出二</div><div class='pdcont'>　　2.000000000</div><div class='pdsec'>样例输入三</div><div class='pdcont'>　　Alice<br />\n　　2572 10</div><div class='pdsec'>样例输出三</div><div class='pdcont'>　　3439.031415943</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'><table cellspacing=0 cellpadding=2px style='border-collapse:collapse;' class='table table-striped table-horver'><tbody><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>#</td><td style='border:solid 1.0pt'>who</td><td style='border:solid 1.0pt'>n</td><td style='border:solid 1.0pt'>h</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>1</td><td rowspan=\"10\" style='border:solid 1.0pt'>Alice</td><td style='border:solid 1.0pt'>≤ 30000</td><td style='border:solid 1.0pt'>= 0</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>2</td><td rowspan=\"2\" style='border:solid 1.0pt'>≤ 15</td><td rowspan=\"2\" style='border:solid 1.0pt'>= 1</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>3</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>4</td><td style='border:solid 1.0pt'>≤ 50</td><td style='border:solid 1.0pt'>≤ 30</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>5</td><td style='border:solid 1.0pt'>≤ 100</td><td style='border:solid 1.0pt'>≤ 30</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>6</td><td rowspan=\"2\" style='border:solid 1.0pt'>≤ 1000</td><td rowspan=\"2\" style='border:solid 1.0pt'>≤ 30</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>7</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>8</td><td rowspan=\"3\" style='border:solid 1.0pt'>≤ 30000</td><td rowspan=\"3\" style='border:solid 1.0pt'>≤ 30</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>9</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>10</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>11</td><td rowspan=\"10\" style='border:solid 1.0pt'>Bob</td><td style='border:solid 1.0pt'>≤ 30000</td><td style='border:solid 1.0pt'>= 0</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>12</td><td rowspan=\"2\" style='border:solid 1.0pt'>≤ 15</td><td rowspan=\"2\" style='border:solid 1.0pt'>= 1</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>13</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>14</td><td style='border:solid 1.0pt'>≤ 50</td><td style='border:solid 1.0pt'>≤ 30</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>15</td><td style='border:solid 1.0pt'>≤ 100</td><td style='border:solid 1.0pt'>≤ 30</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>16</td><td rowspan=\"2\" style='border:solid 1.0pt'>≤ 1000</td><td rowspan=\"2\" style='border:solid 1.0pt'>≤ 30</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>17</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>18</td><td rowspan=\"3\" style='border:solid 1.0pt'>≤ 30000</td><td rowspan=\"3\" style='border:solid 1.0pt'>≤ 30</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>19</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>20</td></tr></tbody></table></div>\n","gpid":"T636","lanqiaotitle":"Counting Skyscrapers","memorylimit":"256.0MB","tid":"ALGO-250","timelimit":"1.0s","title":"算法训练 Counting Skyscrapers","src":"Codeforces， MemSQL start[c]up Round 2 - online version"},{"checkpoint":"","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Ciel有一个n行n列的板子，每个格子上有一个数字。<br />\n　　大家都知道n是一个奇数，不妨设x=(n+1)/2。Ciel可以选择一个x行x列的子矩阵，并将其中的所有元素乘-1。他可以使用这个操作任意多次。<br />\n　　Ciel的目标是最大化板子上的数字和。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个正整数n(1&lt;=n&lt;=33,n是奇数)表示板子大小。<br />\n　　接下来n行每行n个数代表板子上的数，每个数字的绝对值不超过1000。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出可能达到的最大数字和。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n-1 -1 1<br />\n-1 1 -1<br />\n1 -1 -1</div><div class='pdsec'>样例输出</div><div class='pddata'>9</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于5%的数据n=1。<br />\n　　对于35%的数据n&lt;=5。<br />\n　　对于50%的数据n&lt;=11。<br />\n　　对于75%的数据n&lt;=15。<br />\n　　对于100%的数据n&lt;=33。</div>\n","gpid":"T635","lanqiaotitle":"Ciel and Flipboard","memorylimit":"256.0MB","tid":"ALGO-249","timelimit":"1.0s","title":"算法训练 Ciel and Flipboard","src":"Codeforces #321 D"},{"checkpoint":"贪心","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　经营一家糖果店是非常困难的，你需要优化各种各样的东西。最近你在销售一种非常时髦的糖果，叫做Whizboppers。这种糖果变质非常迅速，所以：<br />\n　　·你必须每天早上从供应商买来新的Whizboppers。<br />\n　　·你必须用当天早上从供应商买来的盒子装着糖果出售。<br />\n<br />\n　　你可以从你的供应商处买来装有任意整数克糖果的盒子。<br />\n　　每天有至多k位顾客到你的店里来。从第1个人开始，每个人会选择花费整数分的钱来买Whizboppers，钱数在1分到C分之间（包含1分和C分）。你打算以1分钱每克的价格出售；所以如果一个人想要花4分钱，你会给他恰好4克糖果。你可以给他1个4克的盒子，也可能是1个2克的盒子和2个1克的盒子。<br />\n　　你最少需要买几个盒子才能保证，不管每个人想花多少钱买糖，你总是可以给他们对应质量的糖果？<br />\n<br />\n　　注意：当一个人选择自己想买多少糖果后，你知道之前的人已经买了多少糖，但不能预知之后的人打算买多少糖。<br />\n　　举个例子，如果每天至多有2位顾客到你的店里，每个人至多花2分钱(k=2,C=2)，你可以从你的供应商买4个1克的盒子。但是你可以做的更好：只要买2个1克的盒子和1个2克的盒子，就可以满足你的顾客。如下所示：<br />\n<br />\n<table cellspacing=0 cellpadding=2px style='border-collapse:collapse;' class='table table-striped table-horver'><tbody><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>第一个人</td><td style='border:solid 1.0pt'>给第一个人的盒子 </td><td style='border:solid 1.0pt'>第二个人</td><td style='border:solid 1.0pt'>给第二个人的盒子</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>2分</td><td style='border:solid 1.0pt'>1 个 2克</td><td style='border:solid 1.0pt'>2分<br />\n1分<br />\n</td><td style='border:solid 1.0pt'>2 个 1克<br />\n1 个 1克<br />\n</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>1分</td><td style='border:solid 1.0pt'>1 个 1克</td><td style='border:solid 1.0pt'>2分<br />\n1分<br />\n</td><td style='border:solid 1.0pt'>1 个 2克<br />\n1 个 1克<br />\n</td></tr></tbody></table><br />\n　　不论第一个人怎么买，你都可以给他对应质量的盒子，同时保证第二个人也能拿到正确质量的糖果。所以对于k=2,C=2，你用3个盒子就可以满足任意的顾客需求。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个整数T，表示询问数量。<br />\n　　接下来T行，每行包含两个整数k和C，分别表示最大人数和每个人花费的最多钱数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每一个询问，输出一行包含\"Case #x: y\"，x是询问编号（从1开始标号），y是你每天最少需要的盒子数量。</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\n1 5<br />\n2 2<br />\n10 3<br />\n2 50</div><div class='pdsec'>样例输出</div><div class='pddata'>Case #1: 3<br />\nCase #2: 3<br />\nCase #3: 19<br />\nCase #4: 11</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于25%的数据，k&lt;=20,C&lt;=3；<br />\n　　对于另外20%的数据， k&lt;=1000,C&lt;=10；<br />\n　　对于另外5%的数据，k=1；<br />\n　　对于100%的数据，1 &lt;= T &lt;= 100，1 &lt;= k &lt;= 1000，1 &lt;= C &lt;= 10^12。</div>\n","gpid":"T634","lanqiaotitle":"Candy Store","memorylimit":"256.0MB","tid":"ALGO-248","timelimit":"1.0s","title":"算法训练 Candy Store","src":"GCJ 2010 Final C"},{"checkpoint":"函数","updatetime":"2020-03-06","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编写函数求某年某月某日（****  **  **）是这一年的第几天 。提示：要考虑闰年，闰年的2月是29天（闰年的条件：是4的倍数但不是100的倍数，或者是400的倍数）。编写主函数，输入年月日，测试该函数并输出结果。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　按“yyyy mm dd\"的格式输入年月日</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个整数形式的计算结果</div><div class='pdsec'>样例输入</div><div class='pddata'>1990 5 10</div><div class='pdsec'>样例输出</div><div class='pddata'>130</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　根据实际输入合法的日期</div>\n","gpid":"T604","lanqiaotitle":"天数计算","memorylimit":"256.0MB","tid":"ALGO-240","timelimit":"1.0s","title":"算法训练 天数计算","src":""},{"checkpoint":"函数重载","updatetime":"2020-03-06","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　请用函数重载实现整型和浮点习型的两个数的平方和计算</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　测试数据的输入一定会满足的格式。<br />\n　　2 2（2行2列，第1行整型，第2行浮点型）</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　要求用户的输出满足的格式。<br />\n　　2 1（2行1列，第1行整型，第2行浮点型）</div><div class='pdsec'>样例输入</div><div class='pddata'>一个满足题目要求的输入范例。<br />\n例：<br />\n2 2<br />\n3 4<br />\n3.1 4.1</div><div class='pdsec'>样例输出</div><div class='pddata'>与上面的样例输入对应的输出。<br />\n例：<br />\n25<br />\n26.42</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入数据中每一个数的范围。<br />\n　　例：0&lt;n,m&lt;100, 0&lt;=矩阵中的每个数&lt;=1000。</div>\n","gpid":"T603","lanqiaotitle":"求平方和","memorylimit":"256.0MB","tid":"ALGO-239","timelimit":"1.0s","title":"算法训练 求平方和","src":""},{"checkpoint":"函数调用","updatetime":"2020-02-28","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　从键盘输入10个浮点数，求出它们的和以及平均值，要求用函数实现</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　测试数据的输入一定会满足的格式。<br />\n　　1 10 （1行10列的向量）</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　要求用户的输出满足的格式。<br />\n　　2  1 （2行1列的矩阵）</div><div class='pdsec'>样例输入</div><div class='pddata'>一个满足题目要求的输入范例。<br />\n例：<br />\n1.2 2.2 3.2 4.2 5.2 6.2 7.2 8.2 9.2 10.2</div><div class='pdsec'>样例输出</div><div class='pddata'>与上面的样例输入对应的输出。<br />\n例：<br />\n57<br />\n5.7</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入数据中每一个数的范围。<br />\n　　例：0&lt;n,m&lt;100, 0&lt;=矩阵中的每个数&lt;=1000。</div>\n","gpid":"T598","lanqiaotitle":"求和求平均值","memorylimit":"256.0MB","tid":"ALGO-238","timelimit":"1.0s","title":"算法训练 求和求平均值","src":""},{"checkpoint":"字符串函数","updatetime":"2020-02-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输入一个字符串，输出其长度。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入一个字符串</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出字符串长度</div><div class='pdsec'>样例输入</div><div class='pddata'>一个满足题目要求的输入范例。<br />\nHelloWorld</div><div class='pdsec'>样例输出</div><div class='pddata'>10</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入的字符串的长度0&lt;N&lt;100</div>\n","gpid":"T592","lanqiaotitle":"字符串长度","memorylimit":"256.0MB","tid":"ALGO-235","timelimit":"1.0s","title":"算法训练 字符串长度","src":""},{"checkpoint":"排序算法","updatetime":"2020-02-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输入一个小写字符串，按从小到大的顺序输出。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　bcaed</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　abcde<br />\n　　顶格输出，中间没有空格</div><div class='pdsec'>样例输入</div><div class='pddata'>一个满足题目要求的输入范例。<br />\n例：<br />\nbcaed</div><div class='pdsec'>样例输出</div><div class='pddata'>与上面的样例输入对应的输出。<br />\n例：<br />\nabcde</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入数据中每一个数的范围。<br />\n　　例：0&lt;n,m&lt;100, 0&lt;=矩阵中的每个数&lt;=1000。</div>\n","gpid":"T591","lanqiaotitle":"第五次作业：字符串排序","memorylimit":"256.0MB","tid":"ALGO-234","timelimit":"1.0s","title":"算法训练 第五次作业：字符串排序","src":""},{"checkpoint":"贪心","updatetime":"2020-02-14","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有n个人正在饭堂排队买海北鸡饭。每份海北鸡饭要25元。奇怪的是，每个人手里只有一张钞票（每张钞票的面值为25、50、100元），而且饭堂阿姨一开始没有任何零钱。请问饭堂阿姨能否给所有人找零（假设饭堂阿姨足够聪明）</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个整数n，表示排队的人数。<br />\n<br />\n　　接下来n个整数a[1],a[2],...,a[n]。a[i]表示第i位学生手里钞票的价值（i越小，在队伍里越靠前）</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出YES或者NO</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\n25 25 50 50</div><div class='pdsec'>样例输出</div><div class='pddata'>YES</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n25 100</div><div class='pdsec'>样例输出</div><div class='pddata'>NO</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\n25 25 50 100</div><div class='pdsec'>样例输出</div><div class='pddata'>YES</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n不超过1000000</div>\n","gpid":"T586","lanqiaotitle":"找零钱","memorylimit":"256.0MB","tid":"ALGO-232","timelimit":"1.0s","title":"算法训练 找零钱","src":""},{"checkpoint":"循环、阶乘、高精度","updatetime":"2020-02-14","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　我们知道，阶乘n!表示n*(n-1)*(n-2)*......*2*1, 类似的，可以定义多阶乘计算，例如：5！！=5*3*1,依次可以有n!...!(k个‘！’，可以简单表示为n(k)!)=n*(n-k)*(n-2k)*....（直到最后一个数&lt;=0）。<br />\n　　现给定一组数据n、k、m,当m=1时，计算并输出n(1)!+n(2)!+......+n(k)!的值，m=2时计算并输出n(1)!+n(2)!+......+n(k)!的各个位上的数字之和。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　两行，第一行为n和k，第二行为m。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行,为n(1)!+n(2)!+......+n(k)!的值或n(1)!+n(2)!+......+n(k)!的各个位上的数字之和。</div><div class='pdsec'>样例输入</div><div class='pddata'>5 1<br />\n2</div><div class='pdsec'>样例输出</div><div class='pddata'>3</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　0 &lt; k &lt; n &lt;= 20</div>\n","gpid":"T585","lanqiaotitle":"多阶乘计算","memorylimit":"256.0MB","tid":"ALGO-231","timelimit":"1.0s","title":"算法训练 多阶乘计算","src":"自编"},{"checkpoint":"搜索","updatetime":"2020-02-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个1～N的排列a[i]，每次将相邻两个数相加，得到新序列，再对新序列重复这样的操作，显然每次得到的序列都比上一次的序列长度少1，最终只剩一个数字。<br />\n　　例如:<br />\n　　3 1 2 4<br />\n　　4 3 6<br />\n　　7 9<br />\n　　16<br />\n　　现在如果知道N和最后得到的数字sum，请求出最初序列a[i]，为1～N的一个排列。若有多种答案，则输出字典序最小的那一个。数据保证有解。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第1行为两个正整数n，sum</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个1～N的一个排列</div><div class='pdsec'>样例输入</div><div class='pddata'>4 16</div><div class='pdsec'>样例输出</div><div class='pddata'>3 1 2 4</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　0&lt;n&lt;=10</div>\n","gpid":"T580","lanqiaotitle":"数字游戏","memorylimit":"256.0MB","tid":"ALGO-228","timelimit":"1.0s","title":"算法训练 数字游戏","src":"NOIP模拟"},{"checkpoint":"","updatetime":"2020-02-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给你一个非零整数，让你求这个数的n次方，每次相乘的结果可以在后面使用，求至少需要多少次乘。如2<sup>4</sup>：2*2=2<sup>2</sup>（第一次乘），2<sup>2</sup>*2<sup>2</sup>=2<sup>4</sup>（第二次乘），所以最少共2次；</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行m表示有m(1&lt;=m&lt;=100)组测试数据；<br />\n　　每一组测试数据有一整数n（0&lt;n&lt;=100000000）;</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出每组测试数据所需次数s;</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n2<br />\n3<br />\n4</div><div class='pdsec'>样例输出</div><div class='pddata'>1<br />\n2<br />\n2</div>\n","gpid":"T579","lanqiaotitle":"乘法次数","memorylimit":"999.4MB","tid":"ALGO-227","timelimit":"1.0s","title":"算法训练 乘法次数","src":"nyoj"},{"checkpoint":"数组","updatetime":"2020-01-15","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Chakra是一位年轻有为的企业家，最近他在进军餐饮行业。他在各地开拓市场，共买下了N个饭店。在初期的市场调研中，他将一天划分为M个时间段，并且知道第i个饭店在第j个时间段内，会有Aij位服务员当值和Bij位客户光临。他还分析了不同饭店不同时间段客户的需求，得到第i个饭店在第j个时间段内，平均每位客户消费Cij元。为了创设品牌形象，Chakra决定每个饭店每天只选择一个时间段营业，每个服务员至多接待一位顾客（若顾客数多于服务员数，超过部分的顾客当天就无法在该店消费了）。<br />\n　　企业家的目的终究还是获利。请你安排营业时间，并告诉Chakra每天消费总额最多为多少。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行两个整数，N、M。<br />\n　　第二行开始依次给出三个矩阵A(N*M)、B(N*M)、C(N*M)。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行一个整数，最大消费总额。</div><div class='pdsec'>样例输入</div><div class='pddata'>2 3<br />\n1 2 3<br />\n3 2 1<br />\n3 2 1<br />\n1 2 3<br />\n4 5 2<br />\n3 1 6</div><div class='pdsec'>样例输出</div><div class='pddata'>16</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1 &lt;= M,N &lt;= 100<br />\n　　1 &lt;= Aij, Bij &lt;= 5000<br />\n　　0 &lt;= Cij &lt;= 10^9</div>\n","gpid":"T574","lanqiaotitle":"最大获利","memorylimit":"256.0MB","tid":"ALGO-226","timelimit":"1.0s","title":"算法训练 最大获利","src":""},{"checkpoint":"贪心","updatetime":"2020-01-15","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　石子游戏的规则如下：<br />\n　　地上有n堆石子，每次操作可选取两堆石子（石子个数分别为x和y）并将它们合并，操作的得分记为(x+1)×(y+1)，对地上的石子堆进行操作直到只剩下一堆石子时停止游戏。<br />\n　　请问在整个游戏过程中操作的总得分的最大值是多少？</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入数据的第一行为整数n，表示地上的石子堆数；第二行至第n+1行是每堆石子的个数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　程序输出一行，为游戏总得分的最大值。</div><div class='pdsec'>样例输入</div><div class='pddata'>10<br />\n5105<br />\n19400<br />\n27309<br />\n19892<br />\n27814<br />\n25129<br />\n19272<br />\n12517<br />\n25419<br />\n4053</div><div class='pdsec'>样例输出</div><div class='pddata'>15212676150</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1≤n≤1000，1≤一堆中石子数≤50000</div>\n","gpid":"T573","lanqiaotitle":"石子游戏","memorylimit":"256.0MB","tid":"ALGO-225","timelimit":"1.0s","title":"算法训练 石子游戏","src":""},{"checkpoint":"strncmp函数","updatetime":"2020-01-08","content":"<div class='pdcont'><b>问题描述</b><br />\n　　strncmp函数的原型为：int strncmp(char *s, char *t, int n);，其功能是比较字符串s和t的前n个字符。如果s&lt;t，返回-1；如果s=t，返回0；如果s&gt;t，返回1。请自己编程实现该函数，并编写一个程序来测试其正确性。<br />\n　　输入格式：输入有三行，第一行为字符串s，第二行为字符串t，第三行为整数n。<br />\n　　输出格式：输出只有一个整数，即比较结果。<br />\n<b>输入输出样例</b></div><div class='pdsec'>样例输入</div><div class='pddata'>world<br />\nword<br />\n4</div><div class='pdsec'>样例输出</div><div class='pddata'>1</div>\n","gpid":"T568","lanqiaotitle":"字符串比较","memorylimit":"256.0MB","tid":"ALGO-223","timelimit":"1.0s","title":"算法训练 字符串比较","src":"谌卫军程序设计基础课程"},{"checkpoint":"排序","updatetime":"2020-01-08","content":"<div class='pdcont'><b>问题描述</b><br />\n　　编写一个程序，读入一组整数（不超过20个），并把它们保存在一个整型数组中。当用户输入0时，表示输入结束。然后程序将把这个数组中的值按逆序重新存放，并打印出来。要求：(1)只能定义一个数组；(2)在交换两个数组元素的值时，必须使用单独定义的一个函数swap。例如：假设用户输入了一组数据：7 19 -5 6 2 0，那么程序将会把前五个有效数据保存在一个数组中，即7 19 -5 6 2，然后把这个数组中的值按逆序重新存放，即变成了2 6 -5 19 7，然后把它们打印出来。<br />\n　　输入格式：输入只有一行，包括若干个整数，最后一个整数是0。<br />\n　　输出格式：输出只有一行，包括若干个整数，即逆序排列后的结果。<br />\n<b>输入输出样例</b></div><div class='pdsec'>样例输入</div><div class='pddata'>7 19 -5 6 2 0</div><div class='pdsec'>样例输出</div><div class='pddata'>2 6 -5 19 7</div>\n","gpid":"T567","lanqiaotitle":"数组逆序排列","memorylimit":"256.0MB","tid":"ALGO-222","timelimit":"1.0s","title":"算法训练 数组逆序排列","src":"谌卫军程序设计基础课程"},{"checkpoint":"双向链表","updatetime":"2019-12-31","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有n辆自行车依次来到停车棚，除了第一辆自行车外，每辆自行车都会恰好停放在已经在停车棚里的某辆自行车的左边或右边。(e.g.停车棚里已经有3辆自行车，从左到右编号为：3,5,1。现在编号为2的第4辆自行车要停在5号自行车的左边，所以现在停车棚里的自行车编号是：3,2,5,1)。给定n辆自行车的停放情况，按顺序输出最后停车棚里的自行车编号。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个整数n。<br />\n　　第二行一个整数x。表示第一辆自行车的编号。<br />\n　　以下n-1行，每行3个整数x,y,z。<br />\n　　z=0时，表示编号为x的自行车恰停放在编号为y的自行车的左边<br />\n　　z=1时，表示编号为x的自行车恰停放在编号为y的自行车的右边</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　从左到右输出停车棚里的自行车编号</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\n3<br />\n1 3 1<br />\n2 1 0<br />\n5 2 1</div><div class='pdsec'>样例输出</div><div class='pddata'>3 2 5 1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=100000<br />\n　　自行车编号为不超过100000的正整数。</div>\n","gpid":"T562","lanqiaotitle":"自行车停放","memorylimit":"256.0MB","tid":"ALGO-219","timelimit":"1.0s","title":"算法训练 自行车停放","src":""},{"checkpoint":"","updatetime":"2019-12-31","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　将一个字符串的奇数位（首位为第0位）取出，将其顺序弄反，再放回原字符串的原位置上。<br />\n　　如字符串\"abcdefg\"，奇数位为\"bdf\"，顺序弄反后为\"fdb\"，最后得到字符串\"afcdebg\"。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入共一行，为一个字符串，字符串中无空格。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出共一行，为一个字符串，即最后得到的字符串。</div><div class='pdsec'>样例输入</div><div class='pddata'>abcdefg</div><div class='pdsec'>样例输出</div><div class='pddata'>afcdebg</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　字符串长度不超过255.</div>\n","gpid":"T561","lanqiaotitle":"奇变的字符串","memorylimit":"256.0MB","tid":"ALGO-218","timelimit":"1.0s","title":"算法训练 奇变的字符串","src":""},{"checkpoint":"分支","updatetime":"2019-12-24","content":"<div class='pdcont'><b>【问题描述】</b><b></b><br />\n　　从键盘输入一个英文字母，要求按字母的顺序打印出3个相邻的字母，指定的字母在中间。若指定的字母为Z，则打印YZA，若为A则打印ZAB。注意：需要区分大小写。<b></b><br />\n<b> </b><br />\n<b>【输入格式】</b><b></b><br />\n　　一行，仅包含一个英文字母。<br />\n<br />\n<b>【输出格式】</b><b></b><br />\n　　一行，包含三个字母。<br />\n<b> </b><br />\n<b>【样例输入</b><b>1</b><b>】</b><b></b><br />\n　　a<br />\n<br />\n<b>【样例输出</b><b>1</b><b>】</b><b></b><br />\n　　zab<br />\n<br />\n<b>【样例输入</b><b>2</b><b>】</b><b></b><br />\n　　B<br />\n<br />\n<b>【样例输出</b><b>2</b><b>】</b><b></b><br />\n　　ABC</div>\n","gpid":"T556","lanqiaotitle":"相邻字母","memorylimit":"256.0MB","tid":"ALGO-216","timelimit":"1.0s","title":"算法训练 相邻字母","src":"Midterm2013"},{"checkpoint":"比较网络","updatetime":"2019-12-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　无聊的教授最近在做一项关于比较网络的实验。一个比较网络由若干个含两个输入端和两个输出端的比较器组成。如下图，一个比较器将会比较它的两个输入端的值i1和i2，把它们防止在输出端o1和o2上使得o1&lt;=o2。<br />\n<img src=\"/RequireFile.do?fid=dyrJyBtG\" width=\"338\" height=\"105\" /><br />\n　　一个比较网络有n个输入端a1,a2,..,an和n个输出端b1,b2,..,bn。对于每个比较器，它的输入端要么直接连在比较网络的输入端上，要么连在另一个个比较器的输出端上。这样的关系组成的有向图是无环的。下图给出了一个拥有4个输入端、4个输出端、5个比较器的比较网络。<br />\n<img src=\"/RequireFile.do?fid=j5H5aarf\" width=\"697\" height=\"216\" /><br />\n　　在比较网络运行时，值从输入端输入，然后比较器开始工作。当然，一个比较器仅当它的所有输入值已经被算出来后才能开始工作。假设一个比较器需要1单位时间来工作。那么，上面的例子中的比较网络需要3单位时间来计算输出值。图中的comp-1和comp-2是并行工作的，comp-3和comp-4也是，comp-5只有等comp-3和comp-4完成后才能工作。<br />\n　　无聊的教授现在需要帮助确定那些比较网络是排序网络，并且它们需要多长时间来计算输出值。一个排序网络是一个比较网络，并且无论输入如何，它的输出都单调增。上面的例子也是一个比较网络。因为对于每一种可能的输入，输出值都存在关系b1&lt;=b2&lt;=b3&lt;=b4。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行两个整数n,k，分别表示输入值的个数和比较器的个数。<br />\n　　它们满足1&lt;=n&lt;=12，0&lt;=k&lt;=150。<br />\n　　之后<b>从左到右</b>依次给出每个比较器的信息<br />\n　　之后每行两个整数x,y表示第i个比较器将ax,ay做了比较，把其中较小的数放回ax,较大的数放回ay。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第一行输出YES或NO表示该比较网络是否是排序网络<br />\n　　第二行输出一个整数表示该比较网络的运行时间。</div><div class='pdsec'>样例输入</div><div class='pddata'>样例1：<br />\n4 5<br />\n1 2<br />\n3 4<br />\n1 3<br />\n2 4<br />\n2 3<br />\n样例2：<br />\n8 0<br />\n样例3：<br />\n3 3<br />\n1 2<br />\n2 3<br />\n1 2</div><div class='pdsec'>样例输出</div><div class='pddata'>样例1：<br />\nYES<br />\n3<br />\n样例2：<br />\nNO<br />\n0<br />\n样例3：<br />\nYES<br />\n3</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　样例1即图片上所给的比较网络。</div>\n","gpid":"T555","lanqiaotitle":"Professor Monotonic's Network","memorylimit":"256.0MB","tid":"ALGO-215","timelimit":"1.0s","title":"算法训练 Professor Monotonic's Network","src":"ACM/ICPC World Finals 2001 H"},{"checkpoint":"结构","updatetime":"2019-12-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　空间中有n个球，这些球不相交也不相切。有m个可以视为质点的小生物，可能在某些球内，也可能在所有球之外，但不会在球面上。问这些生物从原来的地方逃逸到所有球外面的空间，至少要经过多少层球面。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行两个数n、m：表示球的数量和小生物的数量；<br />\n　　接下来n行每行四个整数Xi、Yi、Zi和Ri：表示一个球的三维坐标和半径；<br />\n　　接下来m行每行三个整数Xi、Yi、Zi：表示一个生物的坐标。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行m个数：表示每个小生物逃逸时至少经过的球面数。</div><div class='pdsec'>样例输入</div><div class='pddata'>2 2<br />\n0 0 0 2<br />\n0 0 0 4<br />\n0 0 1<br />\n0 0 3</div><div class='pdsec'>样例输出</div><div class='pddata'>2 1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=n、m&lt;=100，|Xi|、|Yi|、|Zi|&lt;=10000，1&lt;=Ri&lt;=10000；<br />\n　　数据保证所有球严格不接触，小生物都不在球面上。</div>\n","gpid":"T550","lanqiaotitle":"小生物的逃逸","memorylimit":"256.0MB","tid":"ALGO-212","timelimit":"1.0s","title":"算法训练 小生物的逃逸","src":""},{"checkpoint":"计算几何","updatetime":"2019-12-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Stephen Stepper的杂货店出售各种类型的瓶塞。瓶塞的形状是两个高1.5cm的同心圆柱叠在一起。<br />\n<img width=\"260\" height=\"99\" src=\"/RequireFile.do?fid=6ayHJtMR\" /><br />\n　　当Stephen邮寄顾客打包货物的时候，他尽量地节约空间。因为瓶塞是他店里最小的货物，所以他会最后打包。他发现每次都是将一些瓶塞放进包裹顶部的一个三角形空隙。瓶塞只能选择图1中两种放置方法之一。三角形空间只有3cm深，所以不能在一个瓶塞上再放一个。当然，两个瓶塞可以想图1和图2所示的叠在一起。你要做的就是帮Stephen判断能不能将塞子放进三角形空间里。<br />\n　　例如，假设一个三角形空间边长分别为8,7,10，我们要放3个瓶塞外部/内部直径分别为2cm/3cm，1.5cm/3cm和1cm/3cm。像图2的方式可以将它们放进空间里。(虚线表示一个塞子在下面的比较小的圆柱。)Stephen只会考虑3个瓶塞都接触两条边且没有两个不同的瓶塞接触到相同的两条边。<br />\n<img width=\"260\" height=\"151\" src=\"/RequireFile.do?fid=menRahR5\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含一行数。<br />\n　　3个正整数表示三角形三边长，3对共6个正实数表示3个瓶塞的规格。对于每对实数，前一个表示较小的圆柱直径，后一个表示较大的圆柱直径。输入最后一行所有数据都是0。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行表示数据组数。<br />\n　　接着一行表示是否可以满足要求。<br />\n　　每组数据输出后打印一个空行。<br />\n　　最后一组数据输出后不打印空行。</div><div class='pdsec'>样例输入</div><div class='pddata'>6 6 6 0.5 1.0 0.3 2.0 0.4 1.0<br />\n10 10 10 2.0 3.0 1.0 2.0 1.5 3.5<br />\n20 6 20 3.0 4.5 0.5 1.0 4.0 5.0<br />\n8 7 10 2.0 3.0 1.5 3.0 1.0 3.0<br />\n8 7 10 2.0 3.0 2.5 3.0 2.0 3.0<br />\n0 0 0 0.0 0.0 0.0 0.0 0.0 0.0</div><div class='pdsec'>样例输出</div><div class='pddata'>Triangle number 1:<br />\nAll three stoppers will fit in the triangular space<br />\nTriangle number 2:<br />\nAll three stoppers will fit in the triangular space<br />\nTriangle number 3:<br />\nStoppers will not fit in the triangular space<br />\nTriangle number 4:<br />\nAll three stoppers will fit in the triangular space<br />\nTriangle number 5:<br />\nStoppers will not fit in the triangular space</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　我也不是很清楚，反正都在实数范围，数据范围没啥意义</div>\n","gpid":"T549","lanqiaotitle":"Stopper Stumper","memorylimit":"256.0MB","tid":"ALGO-211","timelimit":"1.0s","title":"算法训练 Stopper Stumper","src":"ACM/ICPC World Finals 2000 H"},{"checkpoint":"逻辑判断 枚举","updatetime":"2019-12-10","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　ABCDE中num个人做了好事，truth个人说真话。<br />\n　　A说：“我和X中有且只有一个做了好事”<br />\n　　B说：“C和E中有人做了好事”<br />\n　　C说：“我和D和A中有人做了好事”<br />\n　　D说：“B和C都没有做好事”<br />\n　　E说：“我没有做好事”<br />\n　　请问有哪些人做了好事？<br />\n<br />\n　　多组方案请一行一个输出。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　仅一行，先是一个整数num，接着是一个A~E的字符X，最后是一个整数truth。意义见题面。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　每行输出一组方案，方案中按 字母序 输出做好事的人的代号（A~E），不要空格隔开。<br />\n<br />\n　　如果没有合法方案，输出一行一个0即可。</div><div class='pdsec'>样例输入</div><div class='pddata'>1 E 2</div><div class='pdsec'>样例输出</div><div class='pddata'>0</div><div class='pdsec'>样例输入</div><div class='pddata'>2 E 2</div><div class='pdsec'>样例输出</div><div class='pddata'>BD<br />\nBE</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　规定，1 &lt;= num &lt;= 2。</div>\n","gpid":"T544","lanqiaotitle":"谁干的好事？","memorylimit":"256.0MB","tid":"ALGO-208","timelimit":"1.0s","title":"算法训练 谁干的好事？","src":"程序设计基础 2013年秋 期中考试"},{"checkpoint":"数学 DP ","updatetime":"2019-12-10","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　对于古代居民来说，魔法是一种借助神力的技术。在一个有名的故事里魔杖，一<br />\n　　群男巫把他们的魔杖扔在地上，这些魔杖神奇地变成了活生生的蛇。然而，另一<br />\n　　个人将他的魔杖扔在地上时，它变成的蛇则吃掉了男巫们的蛇！<br />\n　　男巫们为了对付这个蛋疼的事情，需要解决以下问题：你有一根魔棒，它是一条<br />\n　　由若干条给定长度的线段组成的折线，折线的所有顶点都可以任意折叠。这条折<br />\n　　线通过折叠可以围成若干个多边形。你需要最大化这些多边形的面积之和，注意<br />\n　　，折线上的每一条线段都至多被用于一个多边形。线段只能在它们的端点上相交<br />\n　　。<br />\n　　左图的折线由五条线段和四个可折叠的轴组成，它可以被折叠成右图那样的多边<br />\n　　形。<br />\n<img src=\"/RequireFile.do?fid=27G6NJeD\" width=\"826\" height=\"99\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行一个整数n，表示这条折线包含的线段数。<br />\n　　下一行共n个数，顺次给出每条线段的长度s1,s2,...,sn</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个实数表示多边形的最大面积和</div><div class='pdsec'>样例输入</div><div class='pddata'>样例1：<br />\n4<br />\n1 2 3 4<br />\n样例2：<br />\n8<br />\n3 4 5 33 3 4 3 5</div><div class='pdsec'>样例输出</div><div class='pddata'>样例1：4.898979<br />\n样例2：19.311</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　3&lt;=n&lt;=500, 1&lt;=si&lt;=1000</div>\n","gpid":"T543","lanqiaotitle":"magicsticks","memorylimit":"256.0MB","tid":"ALGO-207","timelimit":"1.0s","title":"算法训练 magicsticks","src":"ACM/ICPC World Finals 2011 G"},{"checkpoint":"","updatetime":"2019-12-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　你已经被雇佣来 使用现有的旧管道组件以建设一个在旧厂房两点间运水的系统。旧管道系统由管道和管道接口器组成。原有管道在接口器处相交。有的旧管道已经被移除，只在接口器上留下了洞——他们本来是连在洞上的。如果水流入某个接口器，它将流出整个洞并逐渐充满整个大楼——这显然不能让人接受。<br />\n　　你可以通过在一些开孔间加入新管道，或者塞子关闭其他开孔来挽回这种状况。当你用一条新的管道连接两个洞时（必须位于两个不同的节点上），这两个洞不再开放并且水可以流经个新的管道。加入一条新的管道的花费等同于两个节点中心的距离。购买塞子塞住一个洞的花费是0.5。你不需要考虑那些永远不会有水到达的节点上的洞。<br />\n　　有两个结点是特殊的。一个叫做源，是水流入新系统的点。另一个叫做汇，是水需要到达的地方。在所有新的塞子和管道被加入系统后，水将被以一个足够达到指定高度的压力注入源点（当然是在没有渗漏的情况下）。你可以选择任意的压力。而且可以放心，在系统工作时压力不会改变。当然，压力应该足够达到源点和汇点。你的任务是找到让水从源流到汇的最小费用，同时保证水不会渗入大楼。<br />\n　　下面的图中。黑点代表开着的洞，节点1是源点，节点7是汇点。黑点在圆上的位置没有意义，仅作说明用途）。<br />\n<img src=\"/RequireFile.do?fid=BH3A7g4r\" width=\"330\" height=\"209\" /><br />\n　　水依照物理原理流过这个系统。如果压力足够让一个节点灌满水，那这些节点将始终充满了水。如果管道横向延伸或者从一个节点向下延伸，那么水也会从那些管道流过。水也会沿着管道向上，直到达到压力高度的限制。<br />\n　　当然，如果水达到了一个接口器上的洞，它将会流出并充满整个大楼。<br />\n　　在第一个样例中，你可以连接接口1和5<br />\n　　当然，如果水流到一个节点中的开孔，那它将会流出洞并且充满整个大楼。<br />\n　　在第一个样例中，你可以花费代价3连接节点1,5，塞上2的开孔。并且让水压恰好到达接口7。水将充满接口器1、2、5、6和7，不会流得更高了。一个不同的方案（花费更多）是塞住所有的开孔（花费5），并且让水流经所有的洞。通过连接1、6并塞住2、5的开孔不能解决问题，因此接口器6不可以连接管道。<br />\n　　注：假设现有的管道和任何新的管道出了那些他们被连接的节点外，彼此不相交也没有其他接口。就是说，即使一条从A到B的直线经过了C，任何A到B的管道也不会碰到C。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　每个测试点的第一行包含两个正整数N和M。N (2 ≤ N ≤ 400)表示大楼中接口的数量，M(0 ≤ M ≤ 50 000)表示现有可用管道的数量。接下来的N行每行包含四个正整数xi,yi,zi和ki （&minus;10 000 ≤ xi, yi, zi ≤ 10 000，0 ≤ ki ≤ 400， i = 1, 2, ...,N）。第i行描述了结点i：(xi, yi, zi)是地i个结点在三维坐标系中的位置。Ki表示交界处洞的个数。接下来M行的每一行包含两个整数aj和bj（1 ≤ aj &lt; bj ≤ N）。表示第j条原有管道连接了aj和bj两个节点。每对点之间最多有一条管道。并且没有两个节点位于同一个坐标。源是节点1，汇是节点N。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每个测试点，打出测试点编号。之后，若它存在一些新的管道和塞子可以用来建设所需的系统，打印出连接源节点带汇节点的最小代价（精确到小数点后四位）。如果不可能连接源汇，则打印出单词impossible。<br />\n<br />\n　　【样例输入】<b> </b><br />\n　　7 6<br />\n　　2 0 1 1<br />\n　　0 0 0 2<br />\n　　1 0 4 3<br />\n　　3 0 4 3<br />\n　　5 0 1 1<br />\n　　3 0 2 0<br />\n　　5 0 3 0<br />\n　　1 2<br />\n　　1 3<br />\n　　3 4<br />\n　　4 7<br />\n　　5 7<br />\n　　6 7<br />\n　　4 1<br />\n　　2 0 0 0<br />\n　　3 0 1 0<br />\n　　4 1 0 1<br />\n　　5 1 1 1<br />\n　　1 2<br />\n　　【样例输出】<b> </b><br />\n　　Case 1: 4.0000<br />\n　　Case 2: impossible</div>\n","gpid":"T538","lanqiaotitle":"Minimum Cost Flow","memorylimit":"256.0MB","tid":"ALGO-204","timelimit":"3.0s","title":"算法训练 Minimum Cost Flow","src":"ACM/ICPC World Finals 2012 A"},{"checkpoint":"计算几何","updatetime":"2019-12-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　你现在是一个丘陵地区公路赛的主设计师。赛道由N段直道连接而成。第K段的结尾与第K+1段的开头相连。现在计划让这N段赛道都在一个平面上，所以可以在二维的笛卡尔坐标系确定端点。第一段直道从原点开始。图一表示了一个有六条直道的赛道。<br />\n<img src=\"/RequireFile.do?fid=r6bhHRLM\" width=\"476\" height=\"265\" /><br />\n　　图一<br />\n　　真实的比赛是在一座山上进行。简单起见，我们认为山坡和水平面夹角为&theta;。如图二所示。<br />\n　　山坡的平面和水平面相交在y轴。每一个二维坐标(xi, yi)对应一个三维坐标(xi', yi', zi')。其中zi’表示第i条直线终点的高度。<br />\n<img src=\"/RequireFile.do?fid=eJt9byfQ\" width=\"496\" height=\"414\" /><br />\n　　图二<br />\n　　原点的高度为0。<br />\n　　举办这次特别的公路赛的目的是为了让新手司机练习，所以我们规定：一个合乎要求的赛道不包含任何下山的直道。也就是说，如果第k段直道的终点是zk’，那么对于所有第k段以后的直道终点高度，一定不小于zk’。也可以记作当m≥k，zk’≤zm’。<br />\n　　如果一个已设计好的赛道包含了下山的直道，它也许可以通过在平面上以原点为旋转中心旋转一定角度，被转化为一个没有下山直道的赛道，但并没有改变相邻两条直道直间的夹角。然而，也有可能存在设计好的赛道不论怎么旋转都无法成为合法赛道的情况。<br />\n<br />\n　　在这道题中，你必须确定一个被设计了的赛道是否合法（也就是说，它不包含任意的下山直道）。如果不合法，你必须找出旋转赛道来使它合法的最小角度，或者发现它不可能有解。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入数据包括多组测试数据。每个数据点描述了一个赛道和该山坡的坡度。每个测试点的第一行包含两个正整数N(1 ≤ N ≤ 10000)和&theta;(0&ordm; ≤ &theta; ≤ 45&ordm;)。N表示直道的个数，&theta;表示山坡和水平面的夹角，接下来N行每行包含一对整数(xi, yi)，表示第i条直道的重点。第一条直道的起点就是原点，第k+1条直道的起点就是第k条直道的终点。没有直道的长度为0。<br />\n　　最后一个测试点后接一行，包含两个整数0。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每个测试点，先输出一行表示测试点编号（从1开始）。<br />\n　　如果原方案不经旋转就可以符合要求，则输出“Acceptable as proposed”。<br />\n　　如果原方案不符合要求，但是可以由原点旋转而变得合法，则输出“Acceptable after clockwise rotation of X degrees”或“Acceptable after counterclockwise rotation of X degrees”。注意X&gt;0。（我们认为，一个顺时针方向的旋转将把y轴正方向向着x轴正方向旋转）。如果顺时针和逆时针旋转都存在合法的方案，那么挑选旋转角度小的作为答案。如果两种旋转角度相等，那么任何一种答案都将被接受。答案保留两位小数。<br />\n　　如果原方案如何旋转都无法变为合法解，就输出“Unacceptable”<br />\n　　每个数据输出后打印一个空行。</div><div class='pdsec'>样例输入</div><div class='pddata'>2 45<br />\n10 10<br />\n0 1<br />\n2 0<br />\n1 1<br />\n2 0<br />\n3 45<br />\n10 10<br />\n1 10<br />\n5 6<br />\n0 0</div><div class='pdsec'>样例输出</div><div class='pddata'>Case 1: Acceptable after clockwise rotation of 131.99 degrees<br />\n<br />\nCase 2: Acceptable as proposed<br />\n<br />\nCase 3: Unacceptable</div>\n","gpid":"T537","lanqiaotitle":"Grand Prix","memorylimit":"256.0MB","tid":"ALGO-203","timelimit":"1.0s","title":"算法训练 Grand Prix","src":"ACM/ICPC World Finals 2007 C"},{"checkpoint":"判断","updatetime":"2019-11-21","content":"<div class='pdcont'><b>问题描述：</b><br />\n　　生理卫生老师在课堂上娓娓道来：<br />\n　　你能看见你未来的样子吗？显然不能。但你能预测自己成年后的身高，有公式：<br />\n　　男孩成人后身高=（父亲身高+母亲身高）/2*1.08<br />\n　　女孩成人后身高=(父亲身高*0.923+母亲身高）/2<br />\n　　数学老师听见了，回头说：这是大样本统计拟合公式，准确性不错。<br />\n　　生物老师听见了，回头说：结果不是绝对的，影响身高的因素很多，比如营养、疾病、体育锻炼、睡眠、情绪、环境因素等。<br />\n　　老师们齐回头，看见同学们都正在预测自己的身高。<br />\n　　毛老师见此情形，推推眼镜说：何必手算，编程又快又简单......<br />\n　　约定：<br />\n　　身高的单位用米表示，所以自然是会有小数的。<br />\n　　男性用整数1表示，女性用整数0表示。<br />\n　　预测的身高保留三位小数</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　用空格分开的三个数，整数 小数 小数<br />\n　　分别表示：性别 父亲身高 母亲身高</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个小数，表示根据上述表示预测的身高（保留三位小数）</div><div class='pdsec'>样例输入</div><div class='pddata'>1 1.91 1.70</div><div class='pdsec'>样例输出</div><div class='pddata'>1.949</div><div class='pdsec'>样例输入</div><div class='pddata'>0  1.00  2.077</div><div class='pdsec'>样例输出</div><div class='pddata'>1.500</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　父母身高范围（0，3]<br />\n　　时间限制1.0秒</div>\n","gpid":"T525","lanqiaotitle":"预测身高","memorylimit":"256.0MB","tid":"ALGO-200","timelimit":"1.0s","title":"算法训练 预测身高","src":"原创"},{"checkpoint":"矩阵 快速幂","updatetime":"2019-11-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　在一个奇怪的星球上驻扎着两个虫群A和B，它们用奇怪的方式繁殖着，在t+1时刻A虫群的数量等于t时刻A虫群和B虫群数量之和，t+1时刻B虫群的数量等于t时刻A虫群的数量。由于星际空间的时间维度很广阔，所以t可能很大。OverMind 想知道在t时刻A虫群的数量对 p = 1,000,000,007.取余数的结果。当t=1时 A种群和B种群的数量均为1。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　测试数据包含一个整数t，代表繁殖的时间。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行，包含一个整数，表示对p取余数的结果</div><div class='pdsec'>样例输入</div><div class='pddata'>10</div><div class='pdsec'>样例输出</div><div class='pddata'>89</div><div class='pdsec'>样例输入</div><div class='pddata'>65536</div><div class='pdsec'>样例输出</div><div class='pddata'>462302286</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于50%的数据 t&lt;=10^9<br />\n　　对于70%的数据 t&lt;=10^15<br />\n　　对于100%的数据 t&lt;=10^18</div>\n","gpid":"T524","lanqiaotitle":"奇异的虫群","memorylimit":"256.0MB","tid":"ALGO-199","timelimit":"1.0s","title":"算法训练 奇异的虫群","src":""},{"checkpoint":"函数","updatetime":"2019-02-13","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　令二元函数f(x,y)=ax+by，a和b为整数，求一个表达式S的值。<br />\n　　只有满足以下要求的表达式才是合法的：<br />\n　　1.任意整数x是一个合法的表达式；<br />\n　　2.如果A和B都是合法的表达式，则f(A,B)也是一个合法的表达式。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行两个数a和b；<br />\n　　第二行一个字符串S表示要求的表达式。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行一个数表示表达式S的值。</div><div class='pdsec'>样例输入</div><div class='pddata'>1 2<br />\nf(1,f(1,-1))</div><div class='pdsec'>样例输出</div><div class='pddata'>-1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　S的长度不超过50，运算过程中所有变量不会超出int的范围。</div>\n","gpid":"T517","lanqiaotitle":"二元函数","memorylimit":"256.0MB","tid":"ALGO-192","timelimit":"1.0s","title":"算法训练 二元函数","src":""},{"checkpoint":"积分 二分","updatetime":"2019-02-13","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Jill在骑车周游Warsaw时，偶然发现一家销售有趣的玻璃瓶的商店。她认为用这些瓶子测量液体可能是一个有趣的计划，但是这需要在瓶子上做一些标记来指示各个体积。这些标记应该如何标在哪里呢？<br />\n　　Jill将问题正式化如下。假设瓶子是由一条从X=Xlow到X=Xhigh的多项式曲线绕X轴旋转一周构成。因此，X轴与一条穿过瓶子底面中心的垂线重合。瓶底在X=Xlow由一个实心圆构成，瓶口在X=Xhigh，瓶口是敞开的。<br />\n　　第一个样例表示瓶子由从Xlow=0到Xhigh=12的多项式4-0.25X构成。瓶子的底部是一个半径为4的圆，瓶口是一个半径为1的圆。瓶子的高度是12。体积每增加25做一次增量标记。<br />\n　　给定多项式P，Xlow，Xhigh，并给定瓶子上连续的两个标记间的体积增量，计算标记与Xlow之间的距离。标记不能被标在瓶口以上的位置，标记的数量不能超过8个。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行1个整数n，表示多项式的次数。<br />\n　　第二行n+1个数，表示a0,a1,a2…an，为多项式P的实数系数，它们决定了瓶子的形状。 a0为常数项，a1为1次项系数……an为n次项系数。<br />\n　　第三行3个数，Xlow，Xhigh两个实数表示瓶底位置和瓶口位置。inc，一个整数表示每连续两个标记间体积的增量是多少。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第一行输出整个瓶子的体积。第二行输出一个长度不超过8的递增序列，依次表示从瓶底开始（不含瓶底）的连续标记距离瓶底的距离。体积和所有标记的距离精确到小数点后两位。如果没有标记，输出” insufficient volume”（不含引号）。</div><div class='pdsec'>样例输入</div><div class='pddata'>1<br />\n4.0 -0.25<br />\n0.0 12.0 25</div><div class='pdsec'>样例输出</div><div class='pddata'>263.89<br />\n0.51 1.06 1.66 2.31 3.02 3.83 4.75 5.87</div><div class='pdsec'>样例输入</div><div class='pddata'>1<br />\n4.0 -0.25<br />\n0.0 12.0 300</div><div class='pdsec'>样例输出</div><div class='pddata'>263.89<br />\ninsufficient volume</div><div class='pdsec'>样例输入</div><div class='pddata'>0<br />\n1.7841241161782<br />\n5.0 10.0 20</div><div class='pdsec'>样例输出</div><div class='pddata'>50.00<br />\n2.00 4.00</div><div class='pdsec'>样例输入</div><div class='pddata'>0<br />\n1.0<br />\n0.0 10.0 10</div><div class='pdsec'>样例输出</div><div class='pddata'>31.42<br />\n3.18 6.37 9.55</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　0&lt;=n&lt;=10，-100&lt;=ai&lt;=100，an不等于0，-100&lt;=Xlow&lt;Xhigh&lt;=100，Xhigh-Xlow&gt;0.1，1&lt;=inc&lt;=500，输入保证所有标记与瓶子顶部的距离不会小于0.01，瓶子的体积不超过1000，四舍五入后任意两个标记间的距离至少为0.05，对于任意X满足Xlow&lt;=X&lt;=Xhigh，P(X)&gt;0。</div>\n","gpid":"T515","lanqiaotitle":"Curvy Little Bottles","memorylimit":"128.0MB","tid":"ALGO-191","timelimit":"1.0s","title":"算法训练 Curvy Little Bottles","src":"ACM/ICPC World Finals 2012 B"},{"checkpoint":"Anagrams问题","updatetime":"2019-01-29","content":"<div class='pdcont'>　　Anagrams指的是具有如下特性的两个单词：在这两个单词当中，每一个英文字母（不区分大小写）所出现的次数都是相同的。例如，Unclear和Nuclear、Rimon和MinOR都是Anagrams。编写一个程序，输入两个单词（只包含英文字母），然后判断一下，这两个单词是否是Anagrams。每一个单词的长度不会超过80个字符，而且是大小写无关的。<br />\n　　Input:长度不超过80个字符的两个单词，<b>用空格隔开</b>，不考虑字母大小写 （大小写无关）<br />\n　　Output: yes或者no<br />\n<b>输入:</b><br />\n　　Rimon MinOR<br />\n<b>输出:</b><br />\n　　yes</div>\n","gpid":"T511","lanqiaotitle":"P0504","memorylimit":"256.0MB","tid":"ALGO-188","timelimit":"1.0s","title":"算法训练 P0504","src":""},{"checkpoint":"元素统计","updatetime":"2019-01-29","content":"<div class='pdcont'>　　编写一个程序，读入一组整数，这组整数是按照从小到大的顺序排列的，它们的个数N也是由用户输入的，最多不会超过20。然后程序将对这个数组进行统计，把出现次数最多的那个数组元素值打印出来。如果有两个元素值出现的次数相同，即并列第一，那么只打印较小的那个值。例如，假设用户输入的是“100 150 150 200 250”，则输出为150。<br />\n<b>输入:</b><br />\n　　6<br />\n　　100 150 150 200 200 250<br />\n<b>输出:</b><br />\n　　150</div>\n","gpid":"T510","lanqiaotitle":"P0502","memorylimit":"256.0MB","tid":"ALGO-187","timelimit":"1.0s","title":"算法训练 P0502","src":""},{"checkpoint":"整数乘法","updatetime":"2019-01-29","content":"<div class='pdcont'>　　输入两个无符号整数x, y, 用位操作实现无符号整数的乘法运算。不用考虑整数的溢出。<br />\n<b>输入：</b><b></b><br />\n　　235 657<br />\n<b>输出：</b><b></b><br />\n　　154395</div>\n","gpid":"T509","lanqiaotitle":"P0501","memorylimit":"256.0MB","tid":"ALGO-186","timelimit":"1.0s","title":"算法训练 P0501","src":""},{"checkpoint":"计算几何","updatetime":"2018-10-22","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Allied Chute公司是一个建造垃圾管道的公司。垃圾管道建造在楼房中，垃圾从顶部进入，顺着管道与地下室连接。建造垃圾管道是一个高水平的工作。根据人们丢入不同种类的垃圾，垃圾管道需要有一个适当的尺寸。并且由于制作垃圾管道的费用正比于它的尺寸，公司总是想要建造尽可能的管道，尽管确定合适的尺寸十分困难。<br />\n　　为了简化这个问题，我们考虑一个二维的空间。垃圾管道是一个有着固定宽度、垂直下降的槽。物体可以看作一个多边形的模型。在物体落入管道之前它可以旋转来达到和管道最佳拟合。当它下落时，它会垂直落下并且不再旋转。下图展示了一个垃圾是怎样旋转来符合管道的。<img src=\"/RequireFile.do?fid=7hHnDLTd\" /><br />\n<br />\n　　你的任务是计算让一个给定的多边形物体通过的最小管道宽度。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含多组数据。每组数据开始于一个数字n,代表垃圾的模型—一个多边形的顶点数。<br />\n　　接下来n行每行一对整数xi和yi，按顺序给出多边形的顶点。<br />\n　　最后以一个0表示结束</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组测试数据，输出数据编号以 及物体能够穿过垃圾管道并落下的最小宽度。输出的最小宽度并 向上舍入到最接近1/100倍数的数 ，你的答案与标准答案误差不能超过1/100。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n0 0<br />\n3 0<br />\n0 4<br />\n4<br />\n0 10<br />\n10 0<br />\n20 10<br />\n10 20<br />\n0</div><div class='pdsec'>样例输出</div><div class='pddata'>Case 1: 2.40<br />\nCase 2: 14.15</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　30%的数据3&lt;=n&lt;=15<br />\n　　100%的数据3&lt;=n&lt;=100<br />\n　　0&lt;=xi,yi&lt;=10^4<br />\n　　保证在一组数据中的所有的点互不不同，并且多边形的边不会相交（技术上，两条相邻的边不可避免的会有一个公共顶点，当然，这种情况我们不认为是相交）。</div>\n","gpid":"T499","lanqiaotitle":"Trash Removal","memorylimit":"256.0MB","tid":"ALGO-185","timelimit":"1.0s","title":"算法训练 Trash Removal","src":"ACM/ICPC World Finals 2011 K"},{"checkpoint":"模拟，floodfill","updatetime":"2018-03-09","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　一个矩形的划分是指把一个矩形分成若干个较小的、不重叠的子矩形。图一展示了几个划分的例子。<br />\n<br />\n<img src=\"/RequireFile.do?fid=Le9L444m\" width=\"319\" height=\"93\" /><br />\n　　图二展示了被划分成子矩形的三个相同大小的矩形。B是A通过划分A的两个子矩形得来的。通常的，如果B是A通过划分它的一个或多个子矩形得来，那么我们说B比A更精细，或者说A比B更粗糙。这一关系是偏序的：例如C不比A,B中的任意一个精细或粗糙。<br />\n<img src=\"/RequireFile.do?fid=y3y2fyfj\" width=\"319\" height=\"97\" /><br />\n　　给定同一矩形的两种划分D和E，存在无穷多的比D和E都要精细。在图三中F和G都比D和E要精细。在比D和E精细的划分中，存在唯一的一种最粗糙的划分。这种划分被称为D和E的下确界。在图三中，F是D和E的下确界。<br />\n<br />\n<img src=\"/RequireFile.do?fid=Rq9yJJ2h\" width=\"382\" height=\"94\" /><br />\n　　在图四中H和J都比D和E粗糙。J是比D和E都粗糙的所有划分中最精细的，所以称J为D和E的上确界。<br />\n<img src=\"/RequireFile.do?fid=52534AN6\" width=\"382\" height=\"93\" /><br />\n　　写一个程序，给出两种对于相同矩形的划分，求出它们的下确界和上确界。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入文件包括一个或多个测试数据。每个数据第一行给出矩形的宽度h和高度w(0&lt;w,h&lt;21)。接下来h+1如样例所示给出两种划分。每行包括4*w+3个字符。其中前2*w+1个字符属于第一种划分；最后2*w+1个字符属于第二种划分。一个空格分开两种划分，水平线条用下划线“_”表示，垂直线条用“|”。<br />\n<br />\n　　输入以两个0结束。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于输入文件每个数据，输出包括单独一行数据编号(格式如样例所示)，其次是两种划分的下确界和上确界，使用和输入数据相同个格式。<br />\n　　每组数据后输出一个空行。</div><div class='pdsec'>样例输入</div><div class='pddata'><img src=\"/RequireFile.do?fid=ebhbGtNb\" width=\"182\" height=\"248\" /></div><div class='pdsec'>样例输出</div><div class='pddata'><img src=\"/RequireFile.do?fid=hDfJ9Ed5\" width=\"197\" height=\"266\" /></div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于30%的数据，w,h&lt;=3<br />\n　　对于40%的数据，w,h&lt;=4<br />\n　　对于90%的数据，w,h&lt;=10<br />\n<br />\n　　对于100%的数据，w,h&lt;=20,数据组数不超过6。</div>\n","gpid":"T491","lanqiaotitle":"Partitions","memorylimit":"256.0MB","tid":"ALGO-182","timelimit":"1.0s","title":"算法训练 Partitions","src":"ACM/ICPC World Finals 2002 G"},{"checkpoint":"枚举 表达式计算","updatetime":"2018-02-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　计算器和计算机的大量普及也有其弊端。即便是受过专业技术训练的学生们也很可能缺乏计算能力。由于电脑的大量使用，很多人无法心算出7*8这样的算式，甚至是用纸和笔也算不出13*17。不过谁在意呢？<br />\n　　Bartjens教授十分在意——因为他比较传统。他决定给学生布置一些计算作业，并且不能使用电子设备。为了批改方便，他决定使得几乎所有题答案都是2000，不过不全是，否则会被学生发现然后就不仔细计算了。<br />\n　　不幸的是，Bartjens教授的打印机实在是太旧了，不能和新的打印机兼容。打印出了题目后，教授发现所有的符号都丢失了！例如2100-100=，被打印成了2100100=。不过，数字和等号被正确的打印了。<br />\n　　更糟糕的是，教授的试题原稿不见了。因此，他需要恢复出这些题原来的样子。如果答案是2000，那么2100100=可能是：<br />\n　　2100-100=<br />\n　　2*100*10+0=<br />\n　　2*100*10-0=<br />\n　　2*10*0100=<br />\n　　2*-100*-10+0=<br />\n　　Bartjen教授记得几点：<br />\n　　1.他写的数字没有前导零。例如2*10*0100=就是不可行的。<br />\n　　2.他写0的时候不会写多个0。例如2*1000+000=就是不可行的。<br />\n　　3.他只用二元运算符，不用取负。所以2*-100*-10+0=也不合法。<br />\n　　4.他只用+、-、*，不用/和括号。<br />\n　　5.这些算式按照正常的优先级顺序计算。<br />\n　　你需要帮助barjen教授恢复这些题目。你需要在算式中插入至少一个运算符，使得答案是2000。有多少种可能的算式呢？</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含一组数据。这组数据有n个数字（1&lt;=n&lt;=9），后面跟着一个=号。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出包含若干行，每一行是一个可行的解，具体格式见样例。按字典序从小到大输出这些字符串。如果无解，输出一行IMPOSSIBLE。</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n2100100=\n<span style=\"font-family: Arial, Verdana, sans-serif;\"> 【样例输出】 </span>\n2*100*10+0=<br />2*100*10-0=<br />2100-100=\n</pre>\n<div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=n&lt;=9</div>\n","gpid":"T489","lanqiaotitle":"According to Bartjens","memorylimit":"512.0MB","tid":"ALGO-181","timelimit":"1.0s","title":"算法训练 According to Bartjens","src":"ACM/ICPC World Finals 2000 B"},{"checkpoint":"动态规划","updatetime":"2018-02-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　如果你有足够的石块，那么建一座金字塔绝不算难事。举个例子，在一块平地上，我们铺一个10*10的矩形，然后在10*10的矩形上面铺一个9*9的，然后8*8的……以此类推，直到顶上1*1。这个金字塔有10层，我们称这类金字塔为“高金字塔”。<br />\n　　如果你认为这样的金字塔太陡了，那么我们有办法让他看上去坡度平缓一些。比如，在10*10的矩形上，我们铺一个8*8的矩形，然后是6*6的……这样的金字塔只有5层了，大约为底座边长的一半。我们称之为“矮金字塔”。<br />\n　　很久以前，一位法老从父亲那儿继承了一大堆用于搭建金字塔的石块。他决定用这些石块搭建一座金字塔——每个石块都必须用上。建筑师告诉他，这样的要求不一定能实现。例如，如果你有10块石头，那么可以搭一个底座为3的矮金字塔；如果有5块石头，那么就搭一个底座为2的高金字塔。如果你有7块石头呢？不幸的是，确实找不出一种搭金字塔的方案了。<br />\n　　思考再三后，法老决定放低要求——搭不止一座金字塔。但是仍然要满足如下几个条件：<br />\n　　1.所有石块都必须用上；<br />\n　　2.金字塔数要尽可能少；<br />\n　　3.所有金字塔两两不同；<br />\n　　4.金字塔至少包含两层，即底座为1的金字塔和底座为2的矮金字塔是不允许的；<br />\n　　5.满足以上4点的基础上，最大的金字塔要尽可能大（大定义为用的石块数多）；<br />\n　　6.满足以上5点的基础上，次大的金字塔要尽可能大；<br />\n　　7.以此类推。。<br />\n　　你能求出最好的搭金字塔方案么？或者告诉法老这是做不到的。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入仅包含一行，一个正整数N（N&lt;=10^6），表示你拥有的石块数量。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出需要给出具体的方案，或者告诉法老不可能办到。具体的，如果不能办到，输出impossible；否则输出每个金字塔如何搭建，格式是“底座长度+H/L”，H表示这是一座高金字塔，L表示矮金字塔。多座金字塔按从大到小排序输出，如果大小一样，先输出“高金字塔”。两座金字塔间用恰好一个空格隔开。</div><div class='pdsec'>样例输入</div><div class='pddata'>29</div><div class='pdsec'>样例输出</div><div class='pddata'>3H 3L 2H</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于20%的数据，N&lt;=20<br />\n<br />\n　　对于50%的数据，N&lt;=1000<br />\n<br />\n　　对于100%的数据，N&lt;=1000000</div>\n","gpid":"T488","lanqiaotitle":"Pyramids","memorylimit":"512.0MB","tid":"ALGO-180","timelimit":"7.0s","title":"算法训练 Pyramids","src":"ACM/ICPC World Finals 2011 J"},{"checkpoint":"模拟","updatetime":"2018-02-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　在西方音乐中，用大写字母A到G来表示在乐谱中被使用的12个音符，它们后面可能连有升调符号“#”和降调符号“b”，而且如下面展示的那样循环排列。斜杠用来描述相同音符。<br />\n　　C/B# C#/Db D D#/Eb E/Fb F/E# F#/Gb G G#/Ab A A#/Bb B/Cb C/B# …<br />\n　　上表中任意两个相邻音符构成一个半音。恰被一个音符隔开的两个音符构成一个全音。一个大调音阶由八个音符组成。它由上述之一的音符开始并且紧跟着连续的“全音-全音-半音-全音-全音-全音-半音”。分别由C和Db开始的两个大调音阶，将由下面的音符组成：<br />\n　　C D E F G A B C<br />\n　　Db Eb F Gb Ab Bb C Db<br />\n　　下面的规则同样适用于大调音阶：<br />\n　　1.       A到G的每个字母将在音阶中出现恰好一次，同时第一个字母将例外地在音阶最后重复出现一次。<br />\n　　2.       音阶当中不允许同时出现升调或降调记号。<br />\n<br />\n　　大调音阶的首个音符被认为是这个音阶的曲调。比方说，上面的两个音阶分别是C和Db大调音阶。更换两个音阶的音符就是交换对应位置的音符那么简单。举个例子，C大调音阶中的F会和Db大调音阶中的Gb交换因为它们在各自音阶中的位置相同。<br />\n　　你需要写一个程序，在不同音阶中交换音符。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含多组数据，每行一组。每行开头是一个源曲调，紧跟着一个目标曲调，接下来是一串需要从源曲调大调音阶交换至目标曲调大调音阶的音符。每行由单个星号结束。每行中的音符和星号都由单个空格隔开。<br />\n　　输入的最后一行只包含一个星号，并不作为测试数据。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　每组测试数据可能对应一行或多行输出。如果源调和目标调都是有效的，那么输出的第一行应该是“Transposing from X to Y:”，X代表源调，Y代表目标调。假如源调或者目标调中有一个是无效的，那么输出“Key of X/Y is not a valid major key”，X/Y表示无效的曲调，改行剩下的输入将被忽略。假如两者皆无效，只需输出源调。<br />\n　　对于包含了有效的源调和目标调的数据，在第一行的输出后，每个被交换的音符都对应一行输出。假如输入的音符在源调的大调音阶中是个有效音符，那么输出“M transposes to N”，M表示源调中的音符，N是目标调中对应位置的音符。假如输入的音符在源大调音阶中无效，那么输出“M is not a valid note in the X major scale”，M代表输入音符，X代表源音调。不管是有效还是无效音符，都要保持一致的缩进格式。<br />\n　　各组数据的输出之间应该用一个空行隔开。你的输出格式应该要和下面的标准输出相同。<br />\n<br />\n　　输入和输出的标准格式请参考未格式化的试题。</div><div class='pdsec'>样例输入</div><pre class='pddata'>\nC Db F *\n<br type=\"_moz\" />\n</pre>\n<pre class='pddata'>\nDb C Gb *\n<br type=\"_moz\" />\n</pre>\n<pre class='pddata'>\nC B# A B *\n<br type=\"_moz\" />\n</pre>\n<pre class='pddata'>\nC D A A# B Bb C *\n<br type=\"_moz\" />\n</pre>\n<pre class='pddata'>\nA# Bb C *\n<br type=\"_moz\" />\n</pre>\n<pre class='pddata'>\n*\n</pre>\n<div class='pdsec'>样例输出</div><pre class='pddata'>\nTransposing from C to Db:\nF transposes to Gb\nTransposing from Db to C:\nGb transposes to F\nKey of B# is not a valid major key\nTransposing from C to D:\nA transposes to B\nA# is not a valid note in the C major scale\nB transposes to C#\nBb is not a valid note in the C major scale\nC transposes to D\nKey of A# is not a valid major key\n</pre>\n<div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　数据组数不超过100组并且保证输入音符合法。</div>\n","gpid":"T487","lanqiaotitle":"A Major Problem","memorylimit":"256.0MB","tid":"ALGO-179","timelimit":"1.0s","title":"算法训练 A Major Problem","src":"ACM/ICPC World Finals 2001 F"},{"checkpoint":"树形动态规划 贪心","updatetime":"2018-01-10","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　战争在世界历史中扮演了重要角色。与现代战争不同，中世纪的军队主要忙于夺取和控制贵族的私有设防住宅——城堡。一个进攻军队的规模是军队夺取和控制这些建筑杰作的能力的重要影响因素。<br />\n<img src=\"/RequireFile.do?fid=hJat33dE\" width=\"327\" height=\"195\" /><br />\n　　夺取城堡会使用最少需要的士兵数量。一些士兵在进攻中会死去。夺取城堡后，一些士兵被要求留在城堡里防卫其他军队的进攻。当然，留守的士兵数量根据不同的城堡而不同。军队指挥官有义务来考虑进攻成功需要的士兵数量。例如，图中有5个城堡，右下角的城堡需要至少20个士兵才能进攻成功，没有人在进攻中会死去，军队前进后10个士兵必须留在城堡里。<br />\n　　你需要确定一个军队夺取和控制一个特定地区的所有城堡所需要的最小规模。出于安全因素，该地区的任意一对城堡之间有且仅有一条路径。移动到相邻的未夺取城堡就会发动对该城堡的进攻。任何城堡都可以作为第一个被进攻的城堡，不用管军队是怎么到那里的。一旦某个城堡被夺取，要求的士兵数量被留在城堡里保卫它，若还有未夺取城堡，则军队剩余的人继续前进夺取其他城堡。军队可以安全到达已被夺取的城堡的相邻城堡。但由于被进攻的潜在可能，军队在同一方向上经过同一条路最多一次。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含一个整数n，表示该地区的城堡数。<br />\n　　接下来n行每行包含三个整数a_i, m_i和g_i，表示成功夺取城堡i需要的最少士兵数量，在进攻中会死去的士兵数量和必须留守的士兵数量。<br />\n　　接下来n - 1行每行包含两个整数x_i和y_i，表示一条直接连接城堡x_i和城堡y_i的道路。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行包含一个整数，表示夺取和控制该地区的所有城堡所需要的最少士兵数量。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n5 5 5<br />\n10 5 5<br />\n5 1 1<br />\n1 3<br />\n2 3</div><div class='pdsec'>样例输出</div><div class='pddata'>22</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n10 5 10<br />\n20 10 5<br />\n10 10 5<br />\n5 5 5<br />\n20 0 10<br />\n1 2<br />\n1 3<br />\n1 4<br />\n3 5</div><div class='pdsec'>样例输出</div><div class='pddata'>65</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于30%的数据，1 &lt;= n &lt;= 10。<br />\n　　对于100%的数据，1 &lt;= n &lt;= 100，1 &lt;= a_i &lt;= 1000，0 &lt;= m_i &lt;= a_i，1 &lt;= g_i &lt;= 1000。</div>\n","gpid":"T481","lanqiaotitle":"Castles","memorylimit":"256.0MB","tid":"ALGO-175","timelimit":"1.0s","title":"算法训练 Castles","src":"ACM/ICPC World Finals 2010 D"},{"checkpoint":"枚举、字符串匹配","updatetime":"2018-01-10","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　对于一个多边形，如果可以通过它本身复制多次来不重不漏地覆盖一个无限的二维平面，我们就称这个多边形能铺满平面。图1展示了一个L型的多边形，图2展示了它如何不重不漏地铺满平面。你需要写一个程序来判断给出的多边形是否能铺满平面。<br />\n<img src=\"/RequireFile.do?fid=7yjaMe4d\" width=\"773\" height=\"424\" /><br />\n　　每组测试数据由一个闭合的多边形组成，这个多边形所有的角均为直角，每条边的长度均为单位长度的整数倍。你可以随意地复制这个多边形，也可以在平面上随意移动它们，但不能旋转或翻转任意一个多边形。<br />\n<br />\n　　以下是一些可能有用的信息：<br />\n　　只有两种本质不同的铺满平面的情况：使用正四边形铺满平面（棋盘覆盖），或使用正六边形铺满平面（蜂巢覆盖）。一个多边形当且仅当满足以下两个条件中至少一个时可以铺满平面：<br />\n　　1.         在多边形边界上顺次存在四个点A,B,C,D（不一定要是多边形的顶点），使得A到B的边界与D到C的边界重合，B到C的边界与A到D的边界重合。这表明这个多边形可以用棋盘覆盖的方式铺满平面。<br />\n　　2.         在多边形边界上顺次存在六个点A,B,C,D,E,F（不一定要是多边形的顶点），使得A到B的边界与E到D的边界重合，B到C的边界与F到E的边界重合，C到D的边界与A到F的边界重合。这表明这个多边形可以用蜂巢覆盖的方式铺满平面。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含对多个多边形的描述，每一行表示一个询问的多边形。<br />\n　　每一行以一个整数n开始，表示多边形的边数。接下来按逆时针顺序描述每一条边，每一个描述都是一个字母后跟一个数字，字母是“N”、“E”、“S”或“W”，表示线段的方向分别为北、东、南或西，数字表示该线段长度是多少个单位。保证多边形不与自身连接或相交。<br />\n　　输入以单独一行“0”结束。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每个多边形，输出一行。<br />\n　　首先输出多边形的编号，接下来如果该多边形能铺满平面，则输出“Possible”，如果该多边形不能铺满平面，则输出“Impossible”。具体见样例输出的格式。</div><div class='pdsec'>样例输入</div><div class='pddata'>6 N 3 W 1 S 4 E 4 N 1 W 3<br />\n8 E 5 N 1 W 3 N 3 E 2 N 1 W 4 S 5<br />\n0</div><div class='pdsec'>样例输出</div><div class='pddata'>Polygon 1: Possible<br />\nPolygon 2: Impossible</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　30%的数据，n ≤ 20，多边形周长 ≤ 20<br />\n　　100%的数据，n ≤ 50，多边形周长 ≤ 50，每个测试数据中不超过50个多边形。</div>\n","gpid":"T480","lanqiaotitle":"Tiling the Plane","memorylimit":"256.0MB","tid":"ALGO-174","timelimit":"1.0s","title":"算法训练 Tiling the Plane","src":"ACM/ICPC World Finals 2005 G"},{"checkpoint":"数学","updatetime":"2018-01-10","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　工业计算机处理器公司为顾客量身定做了非常快速、用于专门目的的处理单元。a-C-m系列的处理器（比如1-C-2和5-C-3）的指令集只有两种操作：<br />\n　　&bull;\tA 数值加a<br />\n　　&bull;\tM 数值乘m<br />\n　　处理器接收一个整数，执行一个A和M的指令序列（即程序）来修改输入，然后输出结果。举个例子，1-C-2处理器执行程序AAAM处理输入2返回输出10（计算过程是2→3→4→5→10）,然而5-C-3处理器用相同的程序和输入返回51（2→7→12→17→51）。<br />\n　　你是一个被指定做一个顶级秘密项目的a-C-m程序员。这意味着你不会被告知你的程序执行的精确输入。但会得到四个特别的值p，q，r，s，以及下列条件<br />\n　　1、输入保证是一个在p、q之间的数<br />\n　　2、输出必须是一个在r，s之间的数。<br />\n　　给你一个a-C-m处理器和p，q，r，s这四个数。你的工作是构想最短的a-C-m程序，使得任意任意x保证p≤x≤q，返回一个输出y使得r≤y≤s。如果有多个最短的程序，选择字典序最小的，而一个程序即是由A和M组成的字符串。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含多组数据。每组数据在一行中给你6个整数a，m，p，q，r，s，每个就像上面描述的一样。<br />\n　　末行输入6个0作为结束。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组数据，在你的程序前输出数据的编号，程序即像上面描述的一样。输出单词“empty”，如果最好的程序没有操作。输出单词“impossible”如果没有程序满足具体要求。<br />\n　　输出一个用空格分隔的字符串序列，任两个相邻的字符串形式分别为“nA”和“nM”，n&gt;0。前者表示n个连续的操作A，后者表示n个连续的操作M。</div><div class='pdsec'>样例输入</div><div class='pddata'>1 2 2 3 10 20<br />\n1 3 2 3 22 33<br />\n3 2 2 3 4 5<br />\n5 3 2 3 2 3<br />\n0 0 0 0 0 0</div><div class='pdsec'>样例输出</div><div class='pddata'>Case 1: 1A 2M<br />\nCase 2: 1M 2A 1M<br />\nCase 3: impossible<br />\nCase 4: empty</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　每个输入文件至多包含15个测试数据。<br />\n　　对于15%的数据，a,m,p,q,r,s∈[1,50]。<br />\n　　所有的的a,m,p,q,r,s∈[1,1000000000]，且p≤q,r≤s。</div>\n","gpid":"T478","lanqiaotitle":"To Add or to Multiply","memorylimit":"256.0MB","tid":"ALGO-173","timelimit":"1.0s","title":"算法训练 To Add or to Multiply","src":"ACM/ICPC World Finals 2011 A"},{"checkpoint":"BFS","updatetime":"2018-01-05","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　图1中3*3的网格是一个骰子地图。 一个标准的六面骰子需要在地图上移动（图2是一个标准六面骰子的展开图）。 每张地图有一个规定的初始位置和一个初始的骰子放置方式。在图1中，初始位置是第一行第二列——写着“2”的位置。假设你从地图的底边上观察，骰子的初始放置方式是底面（贴在地图上的那一面）是”2”，顶面（与底面相对的那一面）是“5”，”1”面向你。<br />\n<img src=\"/RequireFile.do?fid=EdNgNjNJ\" width=\"550\" height=\"241\" /><br />\n<br />\n　　你可以通过沿着骰子的一条边转动来将它移动到地图上水平或是竖直方向上相邻的格子上。假设当前骰子顶面的数字为x，那么你只能将它移动到写着x的格子上，或者画着星星图案的格子上。我们的最终目标是找到一条路径，使得骰子能从起点出发，最后又回到起点。<br />\n　　举个例子，在图1所示的地图中，一开始你有两种可行的移动方式——向下或者向左。由于此时骰子顶面所示的数字为”5”，当前格子下方的格子上写的数字也是”5”，因此向下移动骰子是可行的；因为当前位置左边的格子画着星星图案，因此向左移动是可行的。如果第一步选择向下移动，那么骰子朝上一面的图案会变成”6”，此时你可以向右或者向下移动骰子。如果第一步选择向左移动，那么骰子顶面的数字会变成3，这种情况下，任何移动方式都是不可行的。<br />\n　　我们用 (行号, 列号) 的方式来标记格子。行号从1开始，从上向下递增；列号从1开始，从左向右递增。这样，在上述例子中一个可行的解可以表示为：(1,2), (2,2), (2,3), (3,3), (3,2), (3,1), (2,1), (1,1), (1,2)。图3中展示了一个更加困难的例子。<br />\n<img src=\"/RequireFile.do?fid=Y5MHE3AA\" width=\"474\" height=\"300\" /><br />\n<br />\n<br />\n　　在本题中，你需要编写程序对输入中给定的地图进行求解。每张地图可能存在一个唯一的解或者无解。也就是说，对于某一张地图，如果有解，你可以认为它只有一个解。对于每张地图，你需要输出一解或者一个信息表示无解。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含6个用空格分隔的整数R, C, x0, y0, T, F，分别表示地图的行数、列数、初始位置行号、初始位置列号、初始状态下顶面的数字、初始状态下面向你的数字。<br />\n　　接下来的R行，每行包含C个空格分隔的整数，定义了这个地图。如果某个数是0，则表示对应的格子为空（不可以被走到）；如果某个数是-1，则表示对应单元格是画着星星图案的单元格；其余情况下，这个数表示对应格子上写的数字。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　若该地图无解，则输出一行“No Solution Possible” (不包含引号)。否则，你应该输出一个逗号分隔的位置序列，表示骰子依次经过的位置。注意你输出的第一个位置和最后一个位置应该是相同的（起始位置已在输入中规定），位置的格式如上文所示。除了最后一行外，每行应该包含九个位置。另外你的输出中不应包含空格。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 3 1 2 5 1<br />\n-1 2 4<br />\n5 5 6<br />\n6 -1 -1</div><div class='pdsec'>样例输出</div><div class='pddata'>(1,2),(2,2),(2,3),(3,3),(3,2),(3,1),(2,1),(1,1),(1,2)</div><div class='pdsec'>样例输入</div><div class='pddata'>4 7 2 6 3 6<br />\n6 4 6 0 2 6 4<br />\n1 2 -1 5 3 6 1<br />\n5 3 4 5 6 4 2<br />\n4 1 2 0 3 -1 6</div><div class='pdsec'>样例输出</div><div class='pddata'>(2,6),(2,5),(2,4),(2,3),(2,2),(3,2),(4,2),(4,1),(3,1),<br />\n(2,1),(2,2),(2,3),(2,4),(2,5),(1,5),(1,6),(1,7),(2,7),<br />\n(3,7),(4,7),(4,6),(3,6),(2,6)</div><div class='pdsec'>样例输入</div><div class='pddata'>3 3 1 1 2 4<br />\n2 2 3<br />\n4 5 6<br />\n-1 -1 -1</div><div class='pdsec'>样例输出</div><div class='pddata'>No Solution Possible</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　20%的数据，R*C≤30<br />\n　　100%的数据，R,C≤10，保证初始状态合法。</div>\n","gpid":"T475","lanqiaotitle":"A Dicey Problem","memorylimit":"256.0MB","tid":"ALGO-172","timelimit":"1.0s","title":"算法训练 A Dicey Problem","src":"ACM/ICPC World Finals 1999 C"},{"checkpoint":"2-SAT","updatetime":"2018-01-05","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　在一个名为 Stanistan 的遥远国度，大臣们在做决策时遇到了很严重的问题。几周前的一次新的议案投票进程引发了这个问题，这个进程的每次会议中，有若干议案被投票。每个大臣会对某些议案投票表示赞成或反对。由于票数统计等一系列技术方案在设计上局限性，每个大臣只能对最多四个不相同的议案投票（但这几乎不成问题，因为大多数大臣只对少数议题感兴趣）。得到了这些投票之后，议案将被决定是否通过，使得每个大臣有大于一半的建议被满足。<br />\n<br />\n　　许多聪明的读者也许已经发现，这个进程导致了各种问题。比方说，可能有多个方案符合要求，或者说没有一种方案符合要求，就算只有一种方案，又该怎样得到这个方案。<br />\n<br />\n　　你的任务就是写一个程序来帮助大臣们解决这些问题。给出每个大臣的投票，你的程序需要指出是否每个大臣都能被满足，如果是，请指出哪些议案只能被通过或否决。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入第一行两个数 n,m，分别表示议案个数和大臣人数。<br />\n<br />\n　　接下来 m 行给出大臣们的投票，每行第一个数 k (1 ≤ k ≤ 4)，表示这个大臣投的票数。接下来是 k 个投票，每个投票都是  &lt;bill&gt; &lt;vote&gt; 的格式，其中 &lt;bill&gt; 是一个 1 到 n 的整数表示被投票的议案编号，&lt;vote&gt; 是 y 或 n，表示大臣的意见是通过还是否决。数据保证没有大臣会对同一个议案投票多次。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行。如果不可能满足所有大臣，那么输出 impossible。否则输出一个长度为 n 的字符串，如果编号为 i 的议案一定要通过，那么字符串的第 i 位为 y，如果一定不能通过则为 n，否则为 ?。</div><div class='pdsec'>样例输入</div><div class='pddata'>5 2<br />\n4 2 y 5 n 3 n 4 n<br />\n4 4 y 3 y 5 n 2 y</div><div class='pdsec'>样例输出</div><div class='pddata'>?y??n</div><div class='pdsec'>样例输入</div><div class='pddata'>4 2<br />\n4 1 y 2 y 3 y 4 y<br />\n3 1 n 2 n 3 n</div><div class='pdsec'>样例输出</div><div class='pddata'>impossible</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　30%的数据 n ≤ 16。<br />\n<br />\n　　另 30%的数据 m ≤ 8。<br />\n<br />\n　　100%的数据 1 ≤ n ≤ 100,1 ≤ m ≤ 500。</div>\n","gpid":"T474","lanqiaotitle":"The Ministers' Major Mess","memorylimit":"256.0MB","tid":"ALGO-171","timelimit":"1.0s","title":"算法训练 The Ministers' Major Mess","src":"ACM/ICPC World Finals 2009 H"},{"checkpoint":"搜索","updatetime":"2017-12-29","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　你是一个Air Conditioning Machinery公司（ACM）的技术人员（就是装空调的）。不幸的是，当你到一个客户那里去装空调管道的时候，你发现你的管道不够了。你只剩6条管道，他们都是同一型号的弯管。<br />\n　　你必须在指定的空间内装一个管道。空间是一个长方体，所有的边的都是单位长度的整倍数，可以想象为一个空间堆满了单位正方体。每个弯管占用恰好4个单位的正方体，如下图1所示。两个弯管不能重合在同一个单位正方体上。每个弯管只有2个口，它们在图形1中以灰色显示。你可以把2个弯管接成一根长的管子，但是它们不得超过给定的空间。图2表示了其中一种对接方式。你的任务是接通入口和出口。入口和出口在给定空间的外表面上，和单位正方体对齐，如图3所示。为了减少开支，你必须用最少的弯管解决这个问题。<br />\n<img width=\"651\" height=\"219\" src=\"/RequireFile.do?fid=y89FgaYr\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入有多个case，每个case 1行包含11个用空格隔开的值。<br />\n　　前3个是整数(x<sub>max</sub>,y<sub>max</sub>,z<sub>max</sub>)表示给定长方体的长宽高。长方体内的每个单位正方体用坐标(x,y,z)表示，其中1≤x≤x<sub>max</sub>, 1≤y≤y<sub>max</sub>, 1≤z≤z<sub>max</sub>。x<sub>max</sub>,y<sub>max</sub>,z<sub>max</sub>均为正且不大于20。<br />\n　　接下来3个整数，表示入口所在单位立方体的坐标。<br />\n　　接下来是2个字符构成的字符串，表示进入的朝向。可能为以下的一种：+x,-x,+y,-y,+z,-z。举例来说，如果为+y，代表进入的方向为y轴正方向，所以入口面向y轴负方向。<br />\n　　接下来3个整数，表示出口所在单位立方体的坐标。<br />\n　　最后是2个字符构成的字符串，表示流出的朝向。可能为以下的一种：+x,-x,+y,-y,+z,-z。举例来说，如果为+y，代表出去的方向为y轴正方向，所以出口面向y轴正方向。(注意与上面的不同之处。)<br />\n　　输入文件的最后一行有1个0，表示输入文件的结束。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每个case，输出case编号（从1开始），并输出接通管道，并且不超过指定空间，最少需要的弯管数。如果不可能用6个弯管完成，则输出Impossible。详见样例。</div><div class='pdsec'>样例输入</div><div class='pddata'>5 4 3 3 1 1 +z 5 4 3 +x<br />\n5 4 3 3 1 1 +z 1 2 3 -x<br />\n0</div><div class='pdsec'>样例输出</div><div class='pddata'>Case 1: 2<br />\nCase 2: Impossible</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　每组数据case数不超过10，其余见输入格式。</div>\n","gpid":"T467","lanqiaotitle":"Air Conditioning Machinery","memorylimit":"256.0MB","tid":"ALGO-169","timelimit":"1.0s","title":"算法训练 Air Conditioning Machinery","src":"ACM/ICPC World Finals 2008 A"},{"checkpoint":"数论 图论","updatetime":"2017-12-20","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　在这个问题中，你需要计算出你为了徒步穿越沙漠而需要购买的食物量。<br />\n　　在你的出发地你可以在商店里购买食物而且你可以收集到无限的免费的水。沙漠中间可能存在一些绿洲。在每个绿洲你同样可以收集无限的水和储存食物，但是你没法再绿洲购买新的食物，同样的你在出发地也可以储存食物。你会得到起点、所有绿洲和终点的二维坐标，这些地方都可以视为平面直角坐标系上的点，在坐标系上每走过一单位相当于实际走一英里。<br />\n　　你每走一英里，你就需要消耗一单位食物和一单位水。我们假设这消耗是持续进行的，即你走了x英里就消耗了x单位食物和水。你只有当食物和水足够时才能前进，而当你在绿洲休息时则不会消耗食物和水。当然你也有你可以携带的食物和水的上限，而这上限就是你能携带的食物和水的单位和的最大值，任何时候你都不能携带超过上限的食物和水。<br />\n　　你需要确定到达终点所需要购买的最少食物量，你不需要在到达终点时还有食物和水盈余。由于商店只能整单位售卖食物且只有一百万单位的存货，你的答案必须是大于0小于等于一百万的整数。<br />\n<br />\n　　请注意样例！</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含两个整数n和tot，表示有意义的位置的坐标个数和能携带的单位数量上限。接下来n行每行两个整数x和y，其中第一个坐标表示起点，最后一个坐标表示终点，中间其他的坐标都是绿洲。你不必经过所有绿洲，也不必按特定的顺序经过绿洲。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　有解时，输出你需要的最小食物量，无解时，输出Impossible。具体格式见样例。</div><div class='pdsec'>样例输入</div><div class='pddata'>样例1：<br />\n4 100<br />\n10 -20<br />\n-10 5<br />\n30 15<br />\n15 35<br />\n样例2：<br />\n2 100<br />\n0 0<br />\n100 100<br />\n样例3：<br />\n2 100<br />\n0 0<br />\n0 1</div><div class='pdsec'>样例输出</div><div class='pddata'>样例1：<br />\n136 units of food<br />\n样例2：<br />\nImpossible<br />\n样例3：<br />\n1 unit of food</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=20。</div>\n","gpid":"T464","lanqiaotitle":"Crossing the Desert","memorylimit":"256.0MB","tid":"ALGO-168","timelimit":"1.0s","title":"算法训练 Crossing the Desert","src":"ACM/ICPC World Finals 2002 C"},{"checkpoint":"枚举","updatetime":"2017-12-20","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　每个人的血型都有两个标记，这两个标记被叫做ABO血型系统的等位基因，每个标记都代表了ABO三个字母之一，因此我们有6种可能的基因组合，而每一种组合都表示了一个特定的ABO血型。<br />\n　　组合     ABO血型<br />\n　　AA       A<br />\n　　AB       AB<br />\n　　AO       A<br />\n　　BB       B<br />\n　　BO       B<br />\n　　OO       O<br />\n　　与之相对应的，每个人同样有两个Rh血型系统的等位基因，而这两个等位基因的标记是+或-。某个人如果是Rh+血型则至少含有一个+基因，而如果是Rh-血型则一定含有两个-基因。<br />\n　　所以一个人的血型是ABO血型系统和Rh血型系统的组合，血型的书写方式是先写ABO血型后写Rh血型。例如A+、AB-、O-。<br />\n　　血型是可以继承的：父母分别贡献一个ABO血型基因和一个Rh血型基因（随机从两个中选择）给他们的孩子。因此父母的2个ABO血型基因和Rh血型基因决定了孩子的血型。比如父母都是A-，则他们的孩子会是A-或O-；而父母是A+和B+时，孩子可以是任意血型。<br />\n　　在本题中，你会得到父母和孩子三者中两者的基因，你需要确定剩下的那个人所有可能的血型组合。<br />\n　　注：我们用大写字母和+-号表示血型，而不是数字。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含若干组数据，每组数据占一行，先是父亲的基因，接着是母亲的基因，最后是孩子的基因，其中一个人的基因用问号代替。输入中空格会在任何地方出现，除了在一个血型中间。<br />\n　　最后一行包含三个用空格隔开的字符E、N、D。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组数据，输出其编号，并按顺序输出父母和孩子的血型。如果没有可行的方案，输出IMPOSSIBLE；如果有多种方案，输出所有可行的方案，方案之间用逗号分隔，并用大括号围住（只有一种方案时不加大括号和逗号）。方案顺序随意。<br />\n　　样例包含多组数据和多种方案，你的输出格式需要与之类似，注意空格出现的位置和字母大小写。</div><div class='pdsec'>样例输入</div><div class='pddata'>O+ O- ?<br />\nO+ ? O-<br />\nAB- AB+ ?<br />\nAB+ ? O+<br />\nO- O- ?<br />\nE N D</div><div class='pdsec'>样例输出</div><div class='pddata'>Case 1: O+ O- {O+, O-}<br />\nCase 2: O+ {A+, A-, B+, B-, O+, O-} O-<br />\nCase 3: AB- AB+ {A+, A-, B+, B-, AB+, AB-}<br />\nCase 4: AB+ IMPOSSIBLE O+<br />\nCase 5: O- O- O-</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　数据组数≤10。</div>\n","gpid":"T463","lanqiaotitle":"Consanguine Calculations","memorylimit":"256.0MB","tid":"ALGO-167","timelimit":"1.0s","title":"算法训练 Consanguine Calculations","src":"ACM/ICPC World Finals 2007 A"},{"checkpoint":"枚举 图论","updatetime":"2017-12-20","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　早上好，特工W-12，你需要完成的以下的任务。<br />\n　　我们已经渗透到一个叫混乱与祸害的组织中，希望能掌握该组织的管理权。不幸的是，它们似乎已经准备好应对这样的事件了，它们使用了一个很复杂的设计分配管理权力，这使得我们的渗透工作非常艰难。<br />\n　　那家组织的管理系统被分成若干个单位，对于任意两个单位A和B，要么A管理B要么B管理A，同时这个管理关系可以形成环，因此可以出现A管理B、B管理C、C管理A的情况。<br />\n　　我们可以安排特工去渗透到任意一个单位，那将使得我们控制该单位和那个单位直接管理的单位，但是不包括间接管理的单位。比如之前的样例，渗透到A单位会让我们控制A和B，但不能控制C。<br />\n　　对于一个成功的渗透工作来说，我们必须要控制所有的单位才行，否则其他单位会发现我们，同时破坏我们的计划。而你也知道，我们现在从更高的部门那里拿到的经费十分紧缺，我们必须最高效地完成任务。你的任务就是要找出控制单位最少的可行方案。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含一个整数n，表示该组织的单位数。接下来n行每行n个二进制位。在其中的第i行第j列位置，若为1表示i单位控制j单位，否则j单位控制i单位。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　共一行，第一个整数ans表示最少的控制单位数量，接下来ans个整数表示任意一组可行的方案。</div><div class='pdsec'>样例输入</div><div class='pddata'>样例1：<br />\n2<br />\n00<br />\n10<br />\n样例2：<br />\n3<br />\n010<br />\n001<br />\n100<br />\n样例3：<br />\n5<br />\n01000<br />\n00011<br />\n11001<br />\n10100<br />\n10010</div><div class='pdsec'>样例输出</div><div class='pddata'>样例1：<br />\n1 2<br />\n样例2：<br />\n2 1 2<br />\n样例3：<br />\n2 2 3</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　30%的数据n&lt;=10。<br />\n　　50%的数据n&lt;=30。<br />\n　　100%的数据n&lt;=75。<br />\n　　保证n*n的01矩阵中所有的i行i列位置为0，i行j列和j行i列两个位置恰好一个为1一个为0（i≠j）。</div>\n","gpid":"T462","lanqiaotitle":"infiltration","memorylimit":"256.0MB","tid":"ALGO-166","timelimit":"1.0s","title":"算法训练 infiltration","src":"ACM/ICPC World Finals 2012 E"},{"checkpoint":"动态规划","updatetime":"2017-12-15","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　俄罗斯套娃是一些从外到里大小递减的传统的俄罗斯木头玩偶组成的。当你打开一个俄罗斯套娃时，里面就会露出一个同样的俄罗斯套娃，再打开，就会再露出一个，不断重复。<br />\n<br />\n　　俄罗斯的俄罗斯套娃博物馆最近收藏了一些外形相似的俄罗斯套娃集,只是里面嵌套的玩偶数量不相等。不幸的是，有一群过分热情的（和明显无人监督的）孩子们拆了他们，并放在一行上。有n个玩偶在一上，每个都有一个整数的大小，你需要重新组装套娃集，你既不知道套娃集的数量，也不知道某个套娃集内玩偶的数量，你只知道一个完好的套娃集内的玩偶大小是从1到某个数字m<br />\n<br />\n　　在组装套娃集时，你必须遵守下列规则：<br />\n　　1.你只能将一个玩偶或者套娃集放入一个更大的玩偶中<br />\n　　2.你只能把相邻两个俄罗斯套娃组合在一起<br />\n　　3.已经被合并的玩偶是不能再重新拆出来的。<br />\n　　你的时间很宝贵，你只想尽快的组装好。唯一需要耗时的部分为打开一个玩偶并马上关上它。所以你要尽可能少的做这种操作。比如说：合并[1,2,6]与[4]，你需要将大小为4和6的两个玩偶拆开。合并[1,2,5]与[3,4]代价为3。<br />\n　　求将n个玩偶重新拼成一些完好的俄罗斯套娃的最小代价。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个数n，第二行包含n个数，依次表示每个玩偶的大小。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　如果答案存在，输出一个数表示将n个玩偶重新拼成一些完好的俄罗斯套娃的最小代价。否则输出“Impossible”</div><div class='pdsec'>样例输入</div><div class='pddata'>7<br />\n1 2 1 2 4 3 3</div><div class='pdsec'>样例输出</div><div class='pddata'>Impossible</div><div class='pdsec'>样例输入</div><div class='pddata'>7<br />\n1 2 3 2 4 1 3</div><div class='pdsec'>样例输出</div><div class='pddata'>7</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=n&lt;=500  ,  1&lt;=玩偶大小&lt;=500</div>\n","gpid":"T436","lanqiaotitle":"Матрёшка","memorylimit":"256.0MB","tid":"ALGO-163","timelimit":"1.0s","title":"算法训练 Матрёшка","src":"ACM/ICPC World Finals 2013 H"},{"checkpoint":"求方程的实数根","updatetime":"2017-12-07","content":"<div class='pdcont'>　　﻿<br />\n　　求方程ax<sup>2</sup>+bx+c=0的实数根。a, b, c由键盘输入, a!=0。若只有一个实数根（b<sup>2</sup>-4ac=0）则只输出x1，若无实数根（b<sup>2</sup>-4ac&lt;0）则输出Error。<br />\n<b>输入</b><br />\n　　2.5 7.5 1.0<br />\n<b>输出</b><br />\n<b>（注意等号前面后面都有一个空格）</b><br />\n　　x1 = -0.139853<br />\n　　x2 = -2.860147</div>\n","gpid":"T429","lanqiaotitle":"P0104","memorylimit":"256.0MB","tid":"ALGO-160","timelimit":"1.0s","title":"算法训练 P0104","src":""},{"checkpoint":"if分支","updatetime":"2017-11-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定实数x，输出sign(x)的值。<br />\n<br />\n　　sign(x)是符号函数，如果x&gt;0，则返回1；如果x=0，则返回0；如果x&lt;0，则返回-1。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一行一个实数x。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行一个整数表示答案。</div><div class='pdsec'>样例输入</div><div class='pddata'>-0.0001</div><div class='pdsec'>样例输出</div><div class='pddata'>-1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　|x|&lt;=10000，输入数据精度最多达到4位小数。</div><div class='pdsec'>提示</div><div class='pdcont'>　　判断实数x是否等于零时，由于计算机实数运算误差，应当引入极小量eps，核心代码如下：<br />\n　　其中fabs为cmath中的绝对值函数。<br />\n　　const double eps=1e-6;<br />\n<br />\n　　if (fabs(x) &lt;= eps) {<br />\n　　//x是零<br />\n　　}</div>\n","gpid":"T423","lanqiaotitle":"sign函数","memorylimit":"256.0MB","tid":"ALGO-158","timelimit":"1.0s","title":"算法训练 sign函数","src":"程序设计基础"},{"checkpoint":"循环","updatetime":"2017-11-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定n和len，输出n!末尾len位。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一行两个正整数n和len。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行一个字符串，表示答案。长度不足用前置零补全。</div><div class='pdsec'>样例输入</div><div class='pddata'>6 5</div><div class='pdsec'>样例输出</div><div class='pddata'>00720</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=30, len&lt;=10。</div>\n","gpid":"T421","lanqiaotitle":"阶乘末尾","memorylimit":"256.0MB","tid":"ALGO-157","timelimit":"1.0s","title":"算法训练 阶乘末尾","src":"程序设计基础"},{"checkpoint":"","updatetime":"2016-11-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　如果一个自然数的所有小于自身的因子之和等于该数，则称为完数。设计算法，打印1-9999之间的所有完数。</div><div class='pdsec'>样例输出</div><div class='pddata'>与上面的样例输入对应的输出。<br />\n例：<img src=\"/RequireFile.do?fid=FLN9Qfht\" width=\"292\" height=\"92\" /></div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1-9999</div>\n","gpid":"T404","lanqiaotitle":"8-2求完数","memorylimit":"256.0MB","tid":"ALGO-152","timelimit":"50.0s","title":"算法训练 8-2求完数","src":""},{"checkpoint":"","updatetime":"2016-11-09","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个十进制整数，返回其对应的二进制数的位数。例如，输入十进制数9，其对应的二进制数是1001，因此位数是4。</div><div class='pdsec'>样例输入</div><div class='pddata'>一个满足题目要求的输入范例。<br />\n9</div><div class='pdsec'>样例输出</div><div class='pddata'>与上面的样例输入对应的输出。<br />\n<img src=\"/RequireFile.do?fid=FYHjne5L\" width=\"654\" height=\"53\" /></div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入数据中每一个数的范围。<br />\n　　例：输入在int表示范围内。</div>\n","gpid":"T400","lanqiaotitle":"6-2递归求二进制表示位数","memorylimit":"256.0MB","tid":"ALGO-151","timelimit":"10.0s","title":"算法训练 6-2递归求二进制表示位数","src":""},{"checkpoint":"","updatetime":"2016-11-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　已知n和m，打印n^1，n^2，...，n^m。要求用静态变量实现。n^m表示n的m次方。已知n和m，打印n^1，n^2，...，n^m。要求用静态变量实现。n^m表示n的m次方。（每行显示5个数，每个数宽为12，右对齐）</div><div class='pdsec'>样例输入</div><div class='pddata'>一个满足题目要求的输入范例。<br />\n例：<br />\n3 8</div><div class='pdsec'>样例输出</div><div class='pddata'>与上面的样例输入对应的输出。<br />\n例：<br />\n<img src=\"/RequireFile.do?fid=ngb56FND\" width=\"647\" height=\"76\" /></div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入数据中每一个数的范围。<br />\n　　例：n^m小于int 的表示范围。</div>\n","gpid":"T393","lanqiaotitle":"5-2求指数","memorylimit":"256.0MB","tid":"ALGO-149","timelimit":"1.0s","title":"算法训练 5-2求指数","src":""},{"checkpoint":"","updatetime":"2016-10-25","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　打印所有100至999之间的水仙花数。所谓水仙花数是指满足其各位数字立方和为该数字本身的整数，例如 153=1^3+5^3+3^3。</div><div class='pdsec'>样例输入</div><div class='pddata'>一个满足题目要求的输入范例。<br />\n例：<br />\n无</div><div class='pdsec'>样例输出</div><div class='pddata'>153<br />\nxxx<br />\nxxx</div>\n","gpid":"T391","lanqiaotitle":"4-3水仙花数","memorylimit":"256.0MB","tid":"ALGO-147","timelimit":"1.0s","title":"算法训练 4-3水仙花数","src":""},{"checkpoint":"","updatetime":"2016-10-25","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　这里写问题描述。<br />\n　　打印出1-1000所有11和17的公倍数。</div><div class='pdsec'>样例输入</div><div class='pddata'>一个满足题目要求的输入范例。<br />\n例：<br />\n无</div><div class='pdsec'>样例输出</div><div class='pddata'>与上面的样例输入对应的输出。<br />\n例：<br />\n<img src=\"/RequireFile.do?fid=n3ErgNfM\" width=\"664\" height=\"123\" /></div>\n","gpid":"T390","lanqiaotitle":"4-2找公倍数","memorylimit":"256.0MB","tid":"ALGO-146","timelimit":"1.0s","title":"算法训练 4-2找公倍数","src":""},{"checkpoint":"","updatetime":"2016-05-09","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　使用循环结构打印下述图形，打印行数n由用户输入。打印空格时使用\"%s\"格式，向printf函数传递只包含一个或多个空格的字符串\" \",下同。<br />\n<img src=\"/RequireFile.do?fid=2MA7nYja\" width=\"88\" height=\"80\" /></div><div class='pdsec'>样例输入</div><div class='pddata'>一个满足题目要求的输入范例。<br />\n例：<br />\n<br />\n5</div><div class='pdsec'>样例输出</div><div class='pddata'>与上面的样例输入对应的输出。<br />\n例：<br />\n<img src=\"/RequireFile.do?fid=nqm2RGNT\" width=\"627\" height=\"155\" /></div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入数据中每一个数的范围。<br />\n　　例：0&lt;n&lt;20。</div>\n","gpid":"T389","lanqiaotitle":"4-1打印下述图形","memorylimit":"256.0MB","tid":"ALGO-145","timelimit":"1.0s","title":"算法训练 4-1打印下述图形","src":""},{"checkpoint":"字符串","updatetime":"2016-05-09","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　相信经过这个学期的编程训练，大家对于字符串的操作已经掌握的相当熟练了。今天，徐老师想测试一下大家对于字符串操作的掌握情况。徐老师自己定义了1,2,3,4,5这5个参数分别指代不同的5种字符串操作，你需要根据传入的参数，按照徐老师的规定，对输入字符串进行格式转化。<br />\n　　徐老师指定的操作如下：<br />\n　　1 表示全部转化为大写字母输出，如abC 变成 ABC<br />\n　　2 表示全部转换为小写字母输出，如abC变成abc<br />\n　　3 表示将字符串整个逆序输出，如 abc 变成 cba<br />\n　　4 表示将字符串中对应的大写字母转换为小写字母，而将其中的小写字母转化为大写字母输出，如 abC变成ABc<br />\n　　5表示将全部转换为小写字母，并将其中所有的连续子串转换为对应的缩写形式输出，比如abcD 转换为a-d，其次，-至少代表1个字母，既如果是ab，则不需要转换为缩写形式。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一共一行，分别是指代对应操作的数字和字符串，两者以空格分隔，字符串全部由英文字母组成</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出根据上述规则转换后对应的字符串</div><div class='pdsec'>样例输入</div><div class='pddata'>5 ABcdEE</div><div class='pdsec'>样例输出</div><div class='pddata'>a-ee</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入字符串长度最长为200。</div>\n","gpid":"T379","lanqiaotitle":"字符串变换","memorylimit":"256.0MB","tid":"ALGO-143","timelimit":"1.0s","title":"算法训练 字符串变换","src":""},{"checkpoint":"学生信息","updatetime":"2016-01-28","content":"<div class='pdcont'>　　定义一个学生结构体类型student，包括4个字段，姓名、性别、年龄和成绩。然后在主函数中定义一个结构体数组（长度不超过1000），并输入每个元素的值，程序使用冒泡排序法将学生按照成绩从小到大的顺序排序，然后输出排序的结果。<br />\n　　输入格式：第一行是一个整数N（N&lt;1000），表示元素个数；接下来N行每行描述一个元素，姓名、性别都是长度不超过20的字符串，年龄和成绩都是整型。<br />\n　　输出格式：按成绩从小到大输出所有元素，若多个学生成绩相同则成绩相同的同学之间保留原来的输入顺序。<br />\n<b>输入：</b><br />\n　　3<br />\n　　Alice female 18 98<br />\n　　Bob male 19 90<br />\n　　Miller male 17 92<br />\n<br />\n<b>输出：</b><br />\n　　Bob male 19 90<br />\n　　Miller male 17 92<br />\n　　Alice female 18 98<br />\n<b> </b></div>\n","gpid":"T371","lanqiaotitle":"P1102","memorylimit":"256.0MB","tid":"ALGO-141","timelimit":"1.0s","title":"算法训练 P1102","src":""},{"checkpoint":"提货单","updatetime":"2016-01-28","content":"<div class='pdcont'>　　﻿<br />\n　　有一份提货单，其数据项目有：商品名（MC）、单价（DJ）、数量（SL）。定义一个结构体prut，其成员是上面的三项数据。在主函数中定义一个prut类型的结构体数组，输入每个元素的值，计算并输出提货单的总金额。<br />\n　　输入格式：第一行是数据项个数N(N&lt;100)，接下来每一行是一个数据项。商品名是长度不超过100的字符串，单价为double类型，数量为整型。<br />\n　　输出格式：double类型的总金额。<br />\n<b>输入：</b><br />\n　　4<br />\n　　book 12.5 3<br />\n　　pen 2.5 10<br />\n　　computer 3200 1<br />\n　　flower 47 5<br />\n<br />\n<b>输出：</b><br />\n　　3497.500000</div>\n","gpid":"T370","lanqiaotitle":"P1101","memorylimit":"256.0MB","tid":"ALGO-140","timelimit":"1.0s","title":"算法训练 P1101","src":""},{"checkpoint":"递归","updatetime":"2016-01-28","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　s01串初始为\"0\"<br />\n　　按以下方式变换<br />\n　　0变1，1变01</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　1个整数(0~19)</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　n次变换后s01串</div><div class='pdsec'>样例输入</div><div class='pddata'>3</div><div class='pdsec'>样例输出</div><div class='pddata'>101</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　0~19</div>\n","gpid":"T366","lanqiaotitle":"s01串","memorylimit":"256.0MB","tid":"ALGO-139","timelimit":"1.0s","title":"算法训练 s01串","src":""},{"checkpoint":"字典树 DP","updatetime":"2016-01-27","content":"<div class='pdcont'><b>【题目描述】</b><br />\n　　来自ABBYY的小明有一个与“细胞与遗传学研究所”的合作。最近，研究所用一个新的题目考验小明。题目如下。<br />\n　　有由n个细胞组成的一个集合（不一定不同）每个细胞是一个由小写拉丁字母组成的字符串。科学家给小明提出的问题是从给定集合中选出一个大小为k的子集，使得所选子集的代表值最大。<br />\n　　小明做了些研究并得出了一个结论，即一个蛋白质集合的代表制可以用一个方便计算的整数来表示。我们假设当前的集合为{<i>a</i><sub>1</sub>,&thinsp;...,&thinsp;<i>a<sub>k</sub></i>}，包含了k个用以表示蛋白质的字符串。那么蛋白质集合的代表值可以用如下的式子来表示：<br />\n<br />\n　　其中<i>f</i>(<i>x</i>,&thinsp;<i>y</i>)表示字符串<i>x</i>和<i>y</i>的最长公共前缀的长度，例如：<br />\n　　<i>f</i>(\"abc\", \"abd\")&thinsp;=&thinsp;2  ， <i>f</i>(\"ab\", \"bcd\")&thinsp;=&thinsp;0.<br />\n　　因此，蛋白质集合{\"abc\", \"abd\", \"abe\"}的代表值等于6，集合{\"aaa\", \"ba\", \"ba\"}的代表值等于2。<br />\n　　在发现了这个之后，小明要求赛事参与者写一个程序选出，给定蛋白质的集合中的大小为k的子集中，能获得最大可能代表性值得一个子集。帮助他解决这个问题吧！<br />\n<b>【输入格式】</b><br />\n　　输入数据第一行包含2个正整数n和k（1≤<i>k</i>≤<i>n</i>），由一个空格隔开。接下来的n行每一行都包含对蛋白质的描述。每个蛋白质都是一个仅有不超过500个小写拉丁字母组成的非空字符串。有些字符串可能是相等的。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个整数，表示给定蛋白质集合的大小为k的子集的代表值最大可能是多少。<br />\n<br />\n<b>【数据规模】</b><br />\n　　20%的数据保证：1&thinsp;≤&thinsp;<i>n</i>&thinsp;≤&thinsp;20<br />\n　　50%的数据保证：1&thinsp;≤&thinsp;<i>n</i>&thinsp;≤&thinsp;100<br />\n　　100%的数据保证：1&thinsp;≤&thinsp;<i>n</i>&thinsp;≤&thinsp;2000<br />\n<br />\n<b>【样例输入1】</b><br />\n　　3 2<br />\n　　aba<br />\n　　bzd<br />\n　　abq<br />\n<b>【样例输出1】</b><br />\n　　2<br />\n<br />\n<b>【样例输入2】</b><br />\n　　4 3<br />\n　　eee<br />\n　　rrr<br />\n　　ttt<br />\n　　qqq<br />\n<b>【样例输出2】</b><br />\n　　0<br />\n<b>【样例输入3】</b><br />\n　　4 3<br />\n　　aaa<br />\n　　abba<br />\n　　abbc<br />\n　　abbd<br />\n<b>【样例输出3】</b><br />\n　　9</div>\n","gpid":"T357","lanqiaotitle":"Representative Sampling (30_points)","memorylimit":"256.0MB","tid":"ALGO-138","timelimit":"2.0s","title":"算法训练 Representative Sampling (30_points)","src":"codeforces178F2"},{"checkpoint":"二分图匹配  最大流","updatetime":"2016-01-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定n个集合, 要求选出其中某些集合, 使得这些集合的并集的势, 等于选出的集合的数目.<br />\n　　对于任意的k(1&lt;=k&lt;=n), 满从中选出任意k个集合, 这k个集合的并集的势一定大于等于k.<br />\n　　每个集合有一个权值, 每个选择方案的代价是所选的集合的权值的和.<br />\n　　请输出代价最小的选择方案的代价.<br />\n　　当然, 不选择任何一个集合是一个可行的方案(权值和为0), 但不一定最优(权值和可以为负).</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个正整数n(1&lt;=n&lt;=300), 为集合个数.<br />\n　　在接下来n行中, 第i行描述第i个集合:<br />\n　　首先给出一个正整数m[i]为该集合的势, 显然1&lt;=m[i]&lt;=n.<br />\n　　接下来m[i]个在1到n之间的整数, 表示该集合中的元素.<br />\n　　最后一行n个整数, 为每个集合的权值, 绝对值不超过1e6.</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　仅一个整数, 为代价最小的选择方案的代价.</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n1 1<br />\n2 2 3<br />\n1 3<br />\n10 20 -3</div><div class='pdsec'>样例输出</div><div class='pddata'>-3</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n2 1 2<br />\n2 2 3<br />\n2 3 4<br />\n2 4 5<br />\n2 5 1<br />\n1 -1 1 -1 1</div><div class='pdsec'>样例输出</div><div class='pddata'>0</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n2 1 2<br />\n2 2 3<br />\n2 3 4<br />\n2 4 5<br />\n2 5 1<br />\n-1 1 -1 1 -1</div><div class='pdsec'>样例输出</div><div class='pddata'>-1</div>\n","gpid":"T355","lanqiaotitle":"Buying Sets","memorylimit":"256.0MB","tid":"ALGO-136","timelimit":"2.0s","title":"算法训练 Buying Sets","src":"CODEFORCES 103E"},{"checkpoint":"dp,hash","updatetime":"2016-01-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　这一天，有一列车子排起了一排长队，必经之路是一个被魔王笼罩的山洞。每辆车的司机害怕魔王程度不同，所以每个司机有一些要求。<br />\n　　车子有n台，排成一条长队，每辆车有4个属性:<br />\n　　V  ——这辆车的总价值，价值就是比如它其中的乘客和货物的价值<br />\n　　c  ——这辆车里面的人数量（司机表示自己也算一个乘客，司机和乘客不用区分开来）<br />\n　　l  ——在这辆车的前面需要总量正好为多少乘客的车（不多也不少），这车才敢开<br />\n　　r  ——在这辆车的后面需要总量正好为多少乘客的车（不多也不少），这车才敢开<br />\n　　“前面需要总量正好为多少乘客的车”指的是驶在这辆车前面所有的车的乘客总数。<br />\n　　“后面需要总量正好为多少乘客的车”指的是驶在这辆车后面所有的车的乘客总数。<br />\n　　你不能改变每辆车在车队的相对顺序，但你可以安排某些车退出车队，保证依然在车队的每辆车都敢开了，即满足上述条件，并且剩下车的v的总量最大。<br />\n　　-----------------------------<br />\n　　简单来说，给您按输入顺序排列的n辆车，您需要删去里面的一些车（剩下的车仍然按原相对顺序排列）。<br />\n　　使得对于每辆车，若它没被删去，设其为输入的第i辆车，<br />\n　　要满足<br />\n　　l[i]= sigma{c[j] | j&lt;i 且第j辆车没被删去}<br />\n　　r[i]= sigma{c[j] | j&gt;i 且第j辆车没被删去}<br />\n　　在满足这些条件前提下，要求sigma{V[i] | i没被删去} 最大，<br />\n　　请输出这个最大值，并且递增输出没有被删去的车的标号。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行为一个正整数n（1&lt;=n&lt;=10^5）——车的个数。<br />\n　　接下来n行，每行四个整数，第i行的数字: vi, ci,li ,r<sub>i</sub> ,（1&lt;=vi&lt;=10^4 , 1&lt;=ci&lt;=10^5,0&lt;=li,ri&lt;=10^5），车子们从1开始编号，从车队的最前头开始算起。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第一行输出一个数k：会继续在这车队里的车的总数（注意我们的目标是让价值最大）。<br />\n　　第二行k个数，递增输出继续在车队里的车的编号。<br />\n　　请留心你不允许改变车的次序。如果答案不唯一，输出任意一个。</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n1 1 0 3<br />\n1 1 1 2<br />\n1 1 2 1<br />\n1 1 3 0<br />\n2 1 3 0</div><div class='pdsec'>样例输出</div><div class='pddata'>4<br />\n1 2 3 5</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n1 1 0 3<br />\n10 1 2 1<br />\n2 2 1 1<br />\n10 1 1 2<br />\n3 1 3 0</div><div class='pdsec'>样例输出</div><div class='pddata'>3<br />\n1 3 5</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于20%的数据，n&lt;=100<br />\n　　对于50%的数据，n&lt;=1000<br />\n　　对于100%的数据，n&lt;=100000<br />\n　　对于100%的数据，1&lt;=vi&lt;=10^4 , 1&lt;=ci&lt;=10^5,0&lt;=li,ri&lt;=10^5</div>\n","gpid":"T346","lanqiaotitle":"Don't fear, DravDe is kind","memorylimit":"256.0MB","tid":"ALGO-134","timelimit":"2.0s","title":"算法训练 Don't fear, DravDe is kind","src":"codeforces 28D "},{"checkpoint":"树上统计","updatetime":"2016-01-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　一个含有n个点的迷宫是一棵树（一个任意两点之间都恰好有一条路径的无向图）。每个点都有一定的概率成为这个迷宫的入口和出口。<br />\n　　从这个迷宫走出去的方法是从入口开始进行深度优先搜索。如果当前有多个移动方案，那么等概率的选择移动方案中的一个。DFS的过程为以下的伪代码：<br />\n　　DFS(x)<br />\n　　if x == exit vertex then<br />\n　　finish search<br />\n　　flag[x] &lt;- TRUE<br />\n　　random shuffle the vertices' order in V(x) // here all permutations have equal probability to be chosen<br />\n　　for i &lt;- 1 to length[V] do<br />\n　　if flag[V[i]] = FALSE then<br />\n　　count++;<br />\n　　DFS(y);<br />\n　　count++;<br />\n　　V(x)是与x点相邻的点的序列。Flag数组初始时是全部为FALSE的。DFS 初始时从入口开始。当搜索结束时，变量count将会统计移动的次数。<br />\n　　你的任务是统计一个人从这个迷宫的入口走到出口步数的数学期望值。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个数n，表示这个图的节点数。。<br />\n　　下面n-1行，每行包括两个数ai,bi，表示一条连接ai和bi的边。<br />\n　　保证给出的图是一棵树。<br />\n　　下面n行，每行包括两个非负整数xi,yi，表示选择i为入口的可能性和出口的可能性。<br />\n<br />\n　　选择i为入口的概率和选择i为出口的概率分别为xi/sumx和yi/sumy，sumx表示x的总和，sumy表示y的总和。sumx以及sumy均为正数且不超过10^6。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出期望的步数，要求误差不超过10^-9。</div><div class='pdsec'>样例输入</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　2<br />\n　　1 2<br />\n　　0 1<br />\n　　1 0</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　3<br />\n　　1 2<br />\n　　1 3<br />\n　　1 0<br />\n　　0 2<br />\n　　0 3</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　7<br />\n　　1 2<br />\n　　1 3<br />\n　　2 4<br />\n　　2 5<br />\n　　3 6<br />\n　　3 7<br />\n　　1 1<br />\n　　1 1<br />\n　　1 1<br />\n　　1 1<br />\n　　1 1<br />\n　　1 1<br />\n　　1 1</div><div class='pdsec'>样例输出</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　1.00000000000000000000</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　2.00000000000000000000</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　4.04081632653</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　第一个样例中，入口总是1，出口总是2。<br />\n　　第二个样例的入口总是1且出口有2/5的概率是2，3/5的概率是3。对于出口为2和3的数学期望是相同的（对称的情况），第一步有0.5的概率直接到达出口，0.5的概率走错到另一个点（然后再走两步到终点）。所以数学期望等于2/5*(1*0.5+3*0.5)+3/5*(1*0.5+3*0.5) = 2。</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　20% 的数据n &lt;= 100<br />\n　　50% 的数据n &lt;= 1000<br />\n　　70% 的数据n &lt;= 10000<br />\n　　100%的数据n &lt;= 100000</div>\n","gpid":"T343","lanqiaotitle":"Maze","memorylimit":"256.0MB","tid":"ALGO-132","timelimit":"1.0s","title":"算法训练 Maze","src":"Codeforces 123E"},{"checkpoint":"模拟","updatetime":"2016-01-04","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　在此游戏中地图被分为了许多叫作Geo格的正方形方格，其中一些被涂上色，假设没有涂色的为透明色。<br />\n　　地图中还有些Geo符号，它们样子像不同颜色的金字塔（包括透明Geo符号）。每个Geo符号都坐落在Geo格上，每个Geo格上最多一个Geo符号。<br />\n　　Geo符号可以被消除。为了更好地理解Geo符号在消除时发生了什么，这里引入把刚消除的Geo符号放入的队列。<br />\n　　从队列中取出Geo符号，观察包含Geo符号的Geo格的颜色，如果它不是透明的且颜色不同于Geo符号，则把所有这个颜色的Geo格重新涂为Geo符号的颜色（透明的Geo符号则为透明色）。重涂色是在一个无限大的区域从那个有符号的Geo格子开始螺旋状进行的。<br />\n　　<img src=\"/RequireFile.do?fid=452n239E\" width=\"240\" height=\"240\" />.<br />\n　　换句话说，我们选择所有需要重涂色的方格找到它们在以有符号格为中心的无限螺旋表格中所对应的数字。此后按数字的增加顺序我们对其重染色。<br />\n　　如果在重染色时遇到一个格子包含另一个Geo符号的情况则将Geo符号移出并放置在队列尾部。<br />\n　　当重染色结束后Geo符号彻底消失，并且队列中下一个Geo符号（如果有）将取出，重复此操作直至队列为空。<br />\n　　为了更好地理解请看一个例子。<br />\n　　你知道所有格子的颜色、所有符号的位置。计算出队列里符号彻底消失时所造成的重染色次数。<br />\n　　推荐使用I64d输出。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含两个数n，m(1&lt;=n，m&lt;=300)—地图的高和宽。<br />\n　　接下来n行每行m个数—格子的颜色。<br />\n　　接下来n行每行m个数—对符号的描述，-1表示没有符号，否则数字代表符号的颜色。<br />\n　　所有颜色都是属于0到10^9的整数，0表示透明。<br />\n　　最后一行两个数x，y(1&lt;=x&lt;=n，1&lt;=y&lt;=m)—需要消除的Geo符号的行和列位置。行从上到下标记，列从左往右标记，从1开始。保证位置(x，y)包含一个符号。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行一个数—符号消除时重染色次数。</div><div class='pdsec'>样例输入</div><div class='pddata'>5 5<br />\n9 0 1 1 0<br />\n0 0 3 2 0<br />\n1 1 1 3 0<br />\n1 1 1 3 0<br />\n0 1 2 0 3<br />\n-1 1 -1 3 -1<br />\n-1 -1 -1 0 -1<br />\n-1 -1 -1 -1 -1<br />\n-1 2 3 -1 -1<br />\n-1 -1 -1 -1 2<br />\n4 2</div><div class='pdsec'>样例输出</div><div class='pddata'>35</div><div class='pdsec'>样例说明</div><div class='pdcont'><img src=\"/RequireFile.do?fid=nMytgBA9\" width=\"170\" height=\"220\" /></div>\n","gpid":"T339","lanqiaotitle":"Entertaining Geodetics","memorylimit":"256.0MB","tid":"ALGO-130","timelimit":"2.0s","title":"算法训练 Entertaining Geodetics","src":"CODEFORCES 105D"},{"checkpoint":"测试","updatetime":"2015-12-25","content":"<div class='pdcont'>　　特殊的数字四十</div><div class='pdsec'>问题描述</div><div class='pdcont'>　　1234是一个非常特殊的四位数，因为它的各位数之和为10，编程求所有这样的四位十进制数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　按从小到大的顺序输出满足条件的四位十进制数。每个数字占用一行。</div>\n","gpid":"T338","lanqiaotitle":"特殊的数字四十","memorylimit":"256.0MB","tid":"ALGO-129","timelimit":"1.0s","title":"算法训练 特殊的数字四十","src":""},{"checkpoint":"字符串处理  贪心","updatetime":"2015-12-25","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　C*++语言和C++语言非常相似，然而C*++的程序有时会出现意想不到的结果。比如像这样的算术表达式：<br />\n　　表达式=基本式 / 表达式+基本式 / 表达式-基本式<br />\n　　基本式=增量 / 系数*增量<br />\n　　增量=a++ / ++a<br />\n　　系数=0/1/2/……/1000<br />\n　　如“5*a++-3*++a+a++”是合法的C*++表达式。<br />\n　　计算这样的表达式的值的方法：首先是每个基本式进行计算，然后按照正常的算术运算法则计算。如果一个基本式包含“a++”，则先进行乘法运算再使变量a权值+1；如果一个基本式包含“++a”，则先使变量a权值+1再进行乘法运算。<br />\n　　然而基本式可以按任意顺序计算，这就是为什么计算结果是完全无法预料的。<br />\n　　你的任务就是去找到最大的可能结果。<br />\n<br />\n　　第一行，一个整数n，表示变量a的初始值。<br />\n　　第二行，一个合法的C*++表达式。<br />\n<br />\n　　共一行，一个整数ans，表示最大可能结果。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　input 1:<br />\n　　1<br />\n　　5*a++-3*++a+a++<br />\n　　input 2:<br />\n　　3<br />\n　　a+++++a</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　output 1:<br />\n　　11<br />\n　　output 2:<br />\n　　8</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于20%的数据，表达式长度&lt;=20。<br />\n　　另有20%的数据，满足n&gt;=0。<br />\n　　对于100%的数据，-1000&lt;=n&lt;=1000，表达式长度&lt;=10000。<br />\n　　注意表达式开头可能有负号！</div>\n","gpid":"T335","lanqiaotitle":"C*++ Calculations","memorylimit":"64.0MB","tid":"ALGO-127","timelimit":"2.0s","title":"算法训练 C*++ Calculations","src":"CF39A"},{"checkpoint":"判断 分支","updatetime":"2015-12-25","content":"<div class='pdcont'>　　水仙花数</div><div class='pdsec'>问题描述</div><div class='pdcont'>　　判断给定的<b>三位数</b>是否 水仙花 数。所谓 水仙花 数是指其值等于它本身 每位数字立方和的数。例 153 就是一个 水仙花  \t数。 153=1<sup>3</sup>+5<sup>3</sup>+3<sup>3</sup></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一个整数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　是水仙花数,输出\"YES\",否则输出\"NO\"(不包括引号)</div><div class='pdsec'>样例输入</div><div class='pddata'>123</div><div class='pdsec'>样例输出</div><div class='pddata'>NO</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　一个三位的整数,否则输出\"NO\"</div>\n","gpid":"T334","lanqiaotitle":"水仙花","memorylimit":"256.0MB","tid":"ALGO-126","timelimit":"1.0s","title":"算法训练 水仙花","src":"传统题"},{"checkpoint":"回溯 递归","updatetime":"2015-12-04","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　地球人都知道，在国际象棋中，后如同太阳，光芒四射，威风八面，它能控制横、坚、斜线位置。<br />\n　　看过清宫戏的中国人都知道，后宫乃步步惊心的险恶之地。各皇后都有自己的势力范围，但也总能找到相安无事的办法。<br />\n　　所有中国人都知道，皇权神圣，伴君如伴虎，触龙颜者死......<br />\n　　现在有一个n*n的皇宫，国王占据他所在位置及周围的共9个格子，这些格子皇后不能使用（如果国王在王宫的边上，占用的格子可能不到9个）。当然，皇后也不会攻击国王。<br />\n　　现在知道了国王的位置（x,y）（国王位于第x行第y列，x,y的起始行和列为1），请问，有多少种方案放置n个皇后，使她们不能互相攻击。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一行，三个整数，皇宫的规模及表示国王的位置</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个整数，表示放置n个皇后的方案数</div><div class='pdsec'>样例输入</div><div class='pddata'>8 2 2</div><div class='pdsec'>样例输出</div><div class='pddata'>10</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=12</div>\n","gpid":"T319","lanqiaotitle":"王、后传说","memorylimit":"256.0MB","tid":"ALGO-125","timelimit":"1.0s","title":"算法训练 王、后传说","src":""},{"checkpoint":"","updatetime":"2015-11-26","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Given two integers <i>A</i> and <i>B</i>, your task is to output their sum, <i>A</i>+<i>B</i>.</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　The input contains of only one line, consisting of two integers <i>A</i> and <i>B</i>. (0 ≤ A,B ≤ 1 000)</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　The output should contain only one number that is <i>A</i>+<i>B</i>.</div><div class='pdsec'>样例输入</div><div class='pddata'>1 1</div><div class='pdsec'>样例输出</div><div class='pddata'>2</div>\n","gpid":"T310","lanqiaotitle":"A+B problem","memorylimit":"1.0GB","tid":"ALGO-123","timelimit":"1.0s","title":"算法训练 A+B problem","src":""},{"checkpoint":"递推","updatetime":"2015-11-19","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　秋天到了，n只猴子采摘了一大堆苹果放到山洞里，约定第二天平分。这些猴子很崇拜猴王孙悟空，所以都想给他留一些苹果。第一只猴子悄悄来到山洞，把苹果平均分成n份，把剩下的m个苹果吃了,然后藏起来一份，最后把剩下的苹果重新合在一起。这些猴子依次悄悄来到山洞，都做同样的操作，恰好每次都剩下了m个苹果。第二天，这些猴子来到山洞，把剩下的苹果分成n分，巧了，还是剩下了m个。问，原来这些猴子至少采了多少个苹果。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　两个整数，n m</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个整数，表示原来苹果的数目</div><div class='pdsec'>样例输入</div><div class='pddata'>5 1</div><div class='pdsec'>样例输出</div><div class='pddata'>15621</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　0&lt;m&lt;n&lt;9</div>\n","gpid":"T302","lanqiaotitle":"猴子分苹果","memorylimit":"256.0MB","tid":"ALGO-121","timelimit":"1.0s","title":"算法训练 猴子分苹果","src":""},{"checkpoint":"循环","updatetime":"2015-11-16","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　涛涛立志要做新好青年，他最近在学做菜。由于技术还很生疏，他只会用鸡蛋，西红柿，鸡丁，辣酱这四种原料来做菜，我们给这四种原料标上字母A,B,C,D。<br />\n　　涛涛现在会做的菜有五种：<br />\n　　1、\t西红柿炒鸡蛋 \t 原料：AABDD<br />\n　　2、\t酸辣鸡丁         原料：ABCD<br />\n　　3、\t宫保鸡丁         原料：CCD<br />\n　　4、\t水煮西红柿       原料：BBB<br />\n　　5、\t怪味蛋           原料：AD<br />\n　　这天早上，开开去早市给涛涛买了一些原料回来。由于事先没有什么计划，涛涛决定，对于现存的原料，每次尽量做菜单上靠前（即编号小）的菜。<br />\n　　现在请你写一个程序，判断一下开开和涛涛中午能吃到哪些菜。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　共4个整数a,b,c,d。分别表示开开买的A,B,C,D这4种原料的数量。每种原料不会超过30份。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出5行。其中第i行表示涛涛做的第i种菜的数目。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n1<br />\n2<br />\n4</div><div class='pdsec'>样例输出</div><div class='pddata'>1<br />\n0<br />\n1<br />\n0<br />\n1</div>\n","gpid":"T299","lanqiaotitle":"学做菜","memorylimit":"256.0MB","tid":"ALGO-120","timelimit":"1.0s","title":"算法训练 学做菜","src":""},{"checkpoint":"循环 数学知识","updatetime":"2015-11-16","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　道德经曰：一生二，二生三，三生万物。<br />\n　　对于任意正整数n，我们定义d(n)的值为为n加上组成n的各个数字的和。例如，d(23)=23+2+3=28, d(1481)=1481+1+4+8+1=1495。<br />\n　　因此，给定了任意一个n作为起点，你可以构造如下一个递增序列：n,d(n),d(d(n)),d(d(d(n)))....例如，从33开始的递增序列为：<br />\n　　33, 39, 51, 57, 69, 84, 96, 111, 114, 120, 123, 129, 141, ...<br />\n　　我们把n叫做d(n)的生成元，在上面的数列中，33是39的生成元，39是51的生成元，等等。有一些数字甚至可以有两个生成元，比如101，可以由91和100生成。但也有一些数字没有任何生成元，如42。我们把这样的数字称为寂寞的数字。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一行，一个正整数n。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　按照升序输出小于n的所有寂寞的数字，每行一个。</div><div class='pdsec'>样例输入</div><div class='pddata'>40</div><div class='pdsec'>样例输出</div><div class='pddata'>1<br />\n3<br />\n5<br />\n7<br />\n9<br />\n20<br />\n31</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=10000</div>\n","gpid":"T298","lanqiaotitle":"寂寞的数","memorylimit":"256.0MB","tid":"ALGO-119","timelimit":"1.0s","title":"算法训练 寂寞的数","src":""},{"checkpoint":"枚举","updatetime":"2015-11-16","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　78这个数可以表示为连续正整数的和，1+2+3，18+19+20+21，25+26+27。<br />\n　　输入一个正整数 n(&lt;=10000)<br />\n　　输出 m 行(n有m种表示法)，每行是两个正整数a，b，表示a+(a+1)+...+b=n。<br />\n　　对于多种表示法，a小的方案先输出。</div><div class='pdsec'>样例输入</div><div class='pddata'>78</div><div class='pdsec'>样例输出</div><div class='pddata'>1 12<br />\n18 21<br />\n25 27</div>\n","gpid":"T296","lanqiaotitle":"连续正整数的和","memorylimit":"256.0MB","tid":"ALGO-118","timelimit":"1.0s","title":"算法训练 连续正整数的和","src":""},{"checkpoint":"函数","updatetime":"2015-11-16","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有两个整数，如果每个整数的约数和（除了它本身以外）等于对方，我们就称这对数是友好的。例如：<br />\n　　9的约数和有：1+3=4<br />\n　　4的约数和有：1+2=3<br />\n　　所以9和4不是友好的。<br />\n　　220的约数和有：1 2 4 5 10 11 20 22 44 55 110=284<br />\n　　284的约数和有：1 2 4 71 142=220<br />\n　　所以220和284是友好的。<br />\n　　编写程序，判断两个数是否是友好数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一行，两个整数，由空格分隔</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　如果是友好数，输出\"yes\"，否则输出\"no\"，注意不包含引号。</div><div class='pdsec'>样例输入</div><div class='pddata'>220 284</div><div class='pdsec'>样例输出</div><div class='pddata'>yes</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　两个整数都小于10000</div>\n","gpid":"T295","lanqiaotitle":"友好数","memorylimit":"256.0MB","tid":"ALGO-117","timelimit":"1.0s","title":"算法训练 友好数","src":""},{"checkpoint":"搜索, 第14周","updatetime":"2015-11-06","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　从一个大小为n的整数集中选取一些元素，使得它们的和等于给定的值T。每个元素限选一次，不能一个都不选。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个正整数n，表示整数集内元素的个数。<br />\n　　第二行n个整数，用空格隔开。<br />\n　　第三行一个整数T，表示要达到的和。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出有若干行，每行输出一组解，即所选取的数字，按照输入中的顺序排列。<br />\n　　若有多组解，优先输出不包含第n个整数的；若都包含或都不包含，优先输出不包含第n-1个整数的，依次类推。<br />\n　　最后一行输出总方案数。</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n-7 -3 -2 5 9<br />\n0</div><div class='pdsec'>样例输出</div><div class='pddata'>-3 -2 5<br />\n-7 -2 9<br />\n2</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=n&lt;=22<br />\n　　T&lt;=maxlongint<br />\n　　集合中任意元素的和都不超过long的范围</div>\n","gpid":"T290","lanqiaotitle":"和为T","memorylimit":"256.0MB","tid":"ALGO-115","timelimit":"1.0s","title":"算法训练 和为T","src":""},{"checkpoint":"","updatetime":"2015-04-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　某寝室的同学们在学术完之后准备玩一个游戏：游戏是这样的，每个人头上都被贴了一张白色或者黑色的纸，现在每个人都会说一句话“我看到x张白色纸条和y张黑色的纸条”，又已知每个头上贴着白色纸的人说的是真话、每个头上贴着黑色纸的人说的是谎话，现在要求你判断哪些人头上贴着的是白色的纸条，如果无解输出“NoSolution.”；如果有多组解，则把每个答案中贴白条的人的编号按照大小排列后组成一个数（比如第一个人和第三个人头上贴着的是白纸条，那么这个数就是13；如果第6、7、8个人都贴的是白纸条，那么这个数就是678）输出最小的那个数（如果全部都是黑纸条也满足情况的话，那么输出0）</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行为一个整数n，接下来n行中的第i行有两个整数x和y，分别表示第i个人说“我看到x张白色纸条和y张黑色的纸条”。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行。如果无解输出“NoSolution.”。否则输出答案中数值（具体见问题描述）最小的那个，如果全部都是黑纸条也满足情况的话，那么输出0</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n1 0<br />\n1 0</div><div class='pdsec'>样例输出</div><div class='pddata'>0</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n3 1<br />\n0 4<br />\n1 3<br />\n4 0<br />\n1 3</div><div class='pdsec'>样例输出</div><div class='pddata'>35</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=8</div>\n","gpid":"T281","lanqiaotitle":"黑白无常","memorylimit":"256.0MB","tid":"ALGO-114","timelimit":"1.0s","title":"算法训练 黑白无常","src":""},{"checkpoint":"","updatetime":"2015-03-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　在一个有限的正整数序列中，有些数会多次重复出现在这个序列中。<br />\n　　如序列：3，1，2，1，5，1，2。其中1就出现3次，2出现2次，3出现1 次，5出现1次。<br />\n　　你的任务是对于给定的正整数序列，从小到大依次输出序列中出现的数及出现的次数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行正整数n，表示给定序列中正整数的个数。<br />\n　　第二行是n 个用空格隔开的正整数x，代表给定的序列。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　若干行，每行两个用一个空格隔开的数，第一个是数列中出现的数，第二个是该数在序列中出现的次数。</div><div class='pdsec'>样例输入</div><div class='pddata'>12<br />\n8 2 8 2 2 11 1 1 8 1 13 13</div><div class='pdsec'>样例输出</div><div class='pddata'>1 3<br />\n2 3<br />\n8 3<br />\n11 1<br />\n13 2</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　数据：n&lt;=1000；0&lt;x&lt;=1000,000。</div>\n","gpid":"T278","lanqiaotitle":"数的统计","memorylimit":"256.0MB","tid":"ALGO-113","timelimit":"1.0s","title":"算法训练 数的统计","src":""},{"checkpoint":"二维数组","updatetime":"2015-03-23","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　同在一个高中，他却不敢去找她，虽然在别人看来，那是再简单不过的事。暗恋，是他唯一能做的事。他只能在每天课间操的时候，望望她的位置，看看她倾心的动作，就够了。操场上的彩砖啊，你们的位置，就是他们能够站立的地方，他俩的关系就像砖与砖之间一样固定，无法动摇。还记得当初铺砖的工人，将整个操场按正方形铺砖（整个操场可视为R行C列的矩阵，矩阵的每个元素为一块正方形砖块），正方形砖块有两种，一种为蓝色，另一种为红色。我们定义他和她之间的“爱情指标”为最大纯色正方形的面积，请你写一个程序求出“爱情指标”。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行两个正整数R和C。<br />\n　　接下来R行C列描述整个操场，红色砖块用1来表示，蓝色砖块用0来表示。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个数，表示他和她之间的“爱情指标”。</div><div class='pdsec'>样例输入</div><div class='pddata'>5 8<br />\n0 0 0 1 1 1 0 1<br />\n1 1 0 1 1 1 1 1<br />\n0 1 1 1 1 1 0 1<br />\n1 0 1 1 1 1 1 0<br />\n1 1 1 0 1 1 0 1</div><div class='pdsec'>样例输出</div><div class='pddata'>9</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　40%的数据R,C&lt;=10;<br />\n　　70%的数据R,C&lt;=50;<br />\n　　100%的数据R,C&lt;=200;</div>\n","gpid":"T276","lanqiaotitle":"暗恋","memorylimit":"256.0MB","tid":"ALGO-112","timelimit":"1.0s","title":"算法训练 暗恋","src":""},{"checkpoint":"NOIP2006 排序","updatetime":"2015-03-11","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤100），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入有2行，第1行为1个正整数，表示所生成的随机数的个数：<br />\n　　N<br />\n　　第2行有N个用空格隔开的正整数，为所产生的随机数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出也是2行，第1行为1个正整数M，表示不相同的随机数的个数。第2行为M个用空格隔开的正整数，为从小到大排好序的不相同的随机数。</div><div class='pdsec'>样例输入</div><div class='pddata'>10<br />\n20 40 32 67 40 20 89 300 400 15</div><div class='pdsec'>样例输出</div><div class='pddata'>8<br />\n15 20 32 40 67 89 300 400</div><div class='pdsec'>题目来源</div><div class='pdcont'>　　计13李震摘编自NOIP06PJ01</div>\n","gpid":"T271","lanqiaotitle":"明明的随机数","memorylimit":"256.0MB","tid":"ALGO-111","timelimit":"1.0s","title":"算法训练 明明的随机数","src":""},{"checkpoint":"字符串的处理 模拟","updatetime":"2015-02-04","content":"<div class='pdcont'>　　在初赛普及组的“阅读程序写结果”的问题中，我们曾给出一个字符串展开的例子：如果在输入的字符串中，含有类似于“d-h”或者“4-8”的字串，我们就把它当作一种简写，输出时，用连续递增的字母获数字串替代其中的减号，即，将上面两个子串分别输出为“defgh”和“45678”。在本题中，我们通过增加一些参数的设置，使字符串的展开更为灵活。具体约定如下：<br />\n　　(1) 遇到下面的情况需要做字符串的展开：在输入的字符串中，出现了减号“-”，减号两侧同为小写字母或同为数字，且按照ASCII码的顺序，减号右边的字符严格大于左边的字符。<br />\n　　(2) 参数p1：展开方式。p1=1时，对于字母子串，填充小写字母；p1=2时，对于字母子串，填充大写字母。这两种情况下数字子串的填充方式相同。p1=3时，不论是字母子串还是数字字串，都用与要填充的字母个数相同的星号“*”来填充。<br />\n　　(3) 参数p2：填充字符的重复个数。p2=k表示同一个字符要连续填充k个。例如，当p2=3时，子串“d-h”应扩展为“deeefffgggh”。减号两边的字符不变。<br />\n　　(4) 参数p3：是否改为逆序：p3=1表示维持原来顺序，p3=2表示采用逆序输出，注意这时候仍然不包括减号两端的字符。例如当p1=1、p2=2、p3=2时，子串“d-h”应扩展为“dggffeeh”。<br />\n　　(5) 如果减号右边的字符恰好是左边字符的后继，只删除中间的减号，例如：“d-e”应输出为“de”，“3-4”应输出为“34”。如果减号右边的字符按照ASCII码的顺序小于或等于左边字符，输出时，要保留中间的减号，例如：“d-d”应输出为“d-d”，“3-1”应输出为“3-1”。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包括两行：<br />\n　　第1行为用空格隔开的3个正整数，一次表示参数p1，p2，p3。<br />\n　　第2行为一行字符串，仅由数字、小写字母和减号“-”组成。行首和行末均无空格。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出只有一行，为展开后的字符串。</div><div class='pdsec'>输入输出样例1</div><div class='pdcont'><table cellspacing=0 cellpadding=2px style='border-collapse:collapse;' class='table table-striped table-horver'><tbody><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'><b>输入</b><br />\n</td><td valign=\"top\" style='border:solid 1.0pt'><b>输出</b><br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>1 2 1<br />\nabcs-w1234-9s-4zz<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>abcsttuuvvw1234556677889s-4zz<br />\n</td></tr></tbody></table></div><div class='pdsec'>输入输出样例2</div><div class='pdcont'><table cellspacing=0 cellpadding=2px style='border-collapse:collapse;' class='table table-striped table-horver'><tbody><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'><b>输入</b><br />\n</td><td valign=\"top\" style='border:solid 1.0pt'><b>输出</b><br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>2 3 2<br />\na-d-d<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>aCCCBBBd-d<br />\n</td></tr></tbody></table></div><div class='pdsec'>输入输出样例3</div><div class='pdcont'><table cellspacing=0 cellpadding=2px style='border-collapse:collapse;' class='table table-striped table-horver'><tbody><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'><b>输入</b><br />\n</td><td valign=\"top\" style='border:solid 1.0pt'><b>输出</b><br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>3 4 2<br />\ndi-jkstra2-6<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>dijkstra2************6<br />\n</td></tr></tbody></table></div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　40%的数据满足：字符串长度不超过5<br />\n　　100%的数据满足：1&lt;=p1&lt;=3，1&lt;=p2&lt;=8，1&lt;=p3&lt;=2。字符串长度不超过100</div>\n","gpid":"T266","lanqiaotitle":"字符串的展开","memorylimit":"256.0MB","tid":"ALGO-110","timelimit":"1.0s","title":"算法训练 字符串的展开","src":""},{"checkpoint":"g背包","updatetime":"2015-02-02","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　现在有a,b,c三种原料，如果他们按x:y:z混合，就能产生一种神奇的物品d。<br />\n　　当然不一定只产生一份d，但a,b,c的最简比一定是x:y:z<br />\n　　现在给你3种可供选择的物品:<br />\n　　每个物品都是由a,b,c以一定比例组合成的，求出最少的物品数，使得他们能凑出整数个d物品（这里的最少是指三者个数的总和最少）</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行三个整数，表示d的配比（x,y,z）<br />\n　　接下来三行，表示三种物品的配比，每行三个整数（&lt;=10000）。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　四个整数，分别表示在最少物品总数的前提下a,b,c,d的个数（d是由a,b,c配得的）<br />\n　　目标答案&lt;=10000<br />\n　　如果不存在满足条件的方案，输出NONE</div><div class='pdsec'>样例输入</div><div class='pddata'>3 4 5<br />\n1 2 3<br />\n3 7 1<br />\n2 1 2</div><div class='pdsec'>样例输出</div><div class='pddata'>8 1 5 7</div>\n","gpid":"T263","lanqiaotitle":"貌似化学","memorylimit":"256.0MB","tid":"ALGO-109","timelimit":"1.0s","title":"算法训练 貌似化学","src":""},{"checkpoint":"g背包","updatetime":"2015-01-29","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　每个物品有一定的体积（废话），不同的物品组合，装入背包会战用一定的总体积。假如每个物品有无限件可用，那么有些体积是永远也装不出来的。为了尽量装满背包，附中的OIER想要研究一下物品不能装出的最大体积。题目保证有解，如果是有限解，保证不超过2，000，000，000<br />\n　　如果是无限解，则输出0</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个整数n（n&lt;=10），表示物品的件数<br />\n　　第2行到N+1行: 每件物品的体积(1&lt;= &lt;=500)</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个整数ans，表示不能用这些物品得到的最大体积。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n3<br />\n6<br />\n10</div><div class='pdsec'>样例输出</div><div class='pddata'>17</div>\n","gpid":"T261","lanqiaotitle":"最大体积","memorylimit":"256.0MB","tid":"ALGO-108","timelimit":"1.0s","title":"算法训练 最大体积","src":""},{"checkpoint":"","updatetime":"2015-01-23","content":"<div class='pdcont'>　　读入10个复数，建立对应链表，然后求所有复数的和。</div><div class='pdsec'>样例输入</div><div class='pddata'>1 2<br />\n1 3<br />\n4 5<br />\n2 3<br />\n3 1<br />\n2 1<br />\n4 2<br />\n2 2<br />\n3 3<br />\n1 1</div><div class='pdsec'>样例输出</div><div class='pddata'>23+23i</div>\n","gpid":"T256","lanqiaotitle":"9-7链表数据求和操作","memorylimit":"512.0MB","tid":"ALGO-107","timelimit":"1.0s","title":"算法训练 9-7链表数据求和操作","src":""},{"checkpoint":"字符串操作","updatetime":"2015-01-21","content":"<div class='pdcont'>　　返回给定字符串s中元音字母的首次出现位置。英语元音字母只有‘a’、‘e’、‘i’、‘o’、‘u’五个。<br />\n　　若字符串中没有元音字母，则返回0。<br />\n　　只考虑小写的情况。</div><div class='pdsec'>样例输入</div><div class='pddata'>and</div><div class='pdsec'>样例输出</div><div class='pddata'>1</div>\n","gpid":"T253","lanqiaotitle":"6-3判定字符位置","memorylimit":"512.0MB","tid":"ALGO-106","timelimit":"1.0s","title":"算法训练 6-3判定字符位置","src":""},{"checkpoint":"逻辑判断 取余运算 循环语句","updatetime":"2015-01-20","content":"<div class='pdcont'><b> </b><br />\n<b>问题描述</b><br />\n　　有些西方人比较迷信，如果某个月的13号正好是星期五，他们就会觉得不太吉利，用古人的说法，就是“诸事不宜”。请你编写一个程序，统计出在某个特定的年份中，出现了多少次既是13号又是星期五的情形，以帮助你的迷信朋友解决难题。<br />\n　　说明：（1）一年有365天，闰年有366天，所谓闰年，即能被4整除且不能被100整除的年份，或是既能被100整除也能被400整除的年份；（2）已知1998年1月1日是星期四，用户输入的年份肯定大于或等于1998年。<br />\n　　输入格式：输入只有一行，即某个特定的年份（大于或等于1998年）。<br />\n　　输出格式：输出只有一行，即在这一年中，出现了多少次既是13号又是星期五的情形。<br />\n<b>输入输出样例</b></div><div class='pdsec'>样例输入</div><div class='pddata'>1998</div><div class='pdsec'>样例输出</div><div class='pddata'>3</div>\n","gpid":"T252","lanqiaotitle":"黑色星期五","memorylimit":"512.0MB","tid":"ALGO-105","timelimit":"1.0s","title":"算法训练 黑色星期五","src":"程序设计公共基础课(谌卫军)"},{"checkpoint":"字符操作 数学知识","updatetime":"2015-01-19","content":"<div class='pdcont'><b></b></div><div class='pdsec'>问题描述</div><div class='pdcont'>　　计算一个整数的阿尔法乘积。对于一个整数x来说，它的阿尔法乘积是这样来计算的：如果x是一个个位数，那么它的阿尔法乘积就是它本身；否则的话，x的阿尔法乘积就等于它的各位非0的数字相乘所得到的那个整数的阿尔法乘积。例如：4018224312的阿尔法乘积等于8，它是按照以下的步骤来计算的：<br />\n　　4018224312 → 4*1*8*2*2*4*3*1*2 → 3072 → 3*7*2 → 42 → 4*2 → 8<br />\n　　编写一个程序，输入一个正整数（该整数不会超过6,000,000），输出它的阿尔法乘积。<br />\n　　输入格式：输入只有一行，即一个正整数。<br />\n　　输出格式：输出相应的阿尔法乘积。<br />\n　　输入输出样例</div><div class='pdsec'>样例输入</div><div class='pddata'>4018224312</div><div class='pdsec'>样例输出</div><div class='pddata'>8</div>\n","gpid":"T251","lanqiaotitle":"阿尔法乘积","memorylimit":"512.0MB","tid":"ALGO-104","timelimit":"1.0s","title":"算法训练 阿尔法乘积","src":"程序设计公共基础课(谌卫军)"},{"checkpoint":"循环语句 数学知识","updatetime":"2015-01-15","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　一个数如果恰好等于它的因子之和，这个数就称为“完数”。例如，6的因子为1、2、3，而6＝1＋2＋3，因此6就是“完数”。又如，28的因子为1、2、4、7、14，而28＝1＋2＋4＋7＋14，因此28也是“完数”。编写一个程序，判断用户输入的一个数是否为“完数”。<br />\n　　输入格式：输入只有一行，即一个整数。<br />\n　　输出格式：输出只有一行，如果该数为完数，输出yes，否则输出no。<br />\n　　输入输出样例</div><div class='pdsec'>样例输入</div><div class='pddata'>6</div><div class='pdsec'>样例输出</div><div class='pddata'>yes</div>\n","gpid":"T249","lanqiaotitle":"完数","memorylimit":"512.0MB","tid":"ALGO-103","timelimit":"1.0s","title":"算法训练 完数","src":"程序设计公共基础课(谌卫军)"},{"checkpoint":"循环语句 数学知识","updatetime":"2015-01-14","content":"<div class='pdcont'><b></b><br />\n<br />\n<b>问题描述</b><br />\n　　编写一个程序，该程序从用户读入一个整数，然后列出所有的数对，每个数对的乘积即为该数。<br />\n　　输入格式：输入只有一行，即一个整数。<br />\n　　输出格式：输出有若干行，每一行是一个乘法式子。（注意：运算符号与数字之间有一个空格）<br />\n<b>输入输出样例</b></div><div class='pdsec'>样例输入</div><div class='pddata'>32</div><div class='pdsec'>样例输出</div><div class='pddata'>1 * 32 = 32<br />\n2 * 16 = 32<br />\n4 * 8 = 32<br />\n8 * 4 = 32<br />\n16 * 2 = 32<br />\n32 * 1 = 32</div>\n","gpid":"T248","lanqiaotitle":"数对","memorylimit":"512.0MB","tid":"ALGO-102","timelimit":"1.0s","title":"算法训练 数对","src":"程序设计公共基础课(谌卫军)"},{"checkpoint":"循环语句 数学知识","updatetime":"2015-01-13","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编写一个程序，输入三个正整数min、max和factor，然后对于min到max之间的每一个整数（包括min和max），如果它能被factor整除，就把它打印出来。<br />\n　　输入格式：输入只有一行，包括三个整数min、max和factor。<br />\n　　输出格式：输出只有一行，包括若干个整数。<br />\n　　输入输出样例</div><div class='pdsec'>样例输入</div><div class='pddata'>1 10 3</div><div class='pdsec'>样例输出</div><div class='pddata'>3 6 9</div>\n","gpid":"T246","lanqiaotitle":"整除问题","memorylimit":"512.0MB","tid":"ALGO-100","timelimit":"1.0s","title":"算法训练 整除问题","src":"程序设计公共基础课(谌卫军)"},{"checkpoint":"逻辑判断 数学知识","updatetime":"2015-01-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编写一个程序，计算员工的周薪。薪水的计算是以小时为单位，如果在一周的时间内，员工工作的时间不超过40 个小时，那么他/她的总收入等于工作时间乘以每小时的薪水。如果员工工作的时间在40 到50 个小时之间，那么对于前40 个小时，仍按常规方法计算；而对于剩余的超额部分，每小时的薪水按1.5 倍计算。如果员工工作的时间超过了50 个小时，那么对于前40 个小时，仍按常规方法计算；对于40～50 个小时之间的部分，每小时的薪水按1.5 倍计算；而对于超出50 个小时的部分，每小时的薪水按2 倍计算。请编写一个程序，输入员工的工作时间和每小时的薪水，然后计算并显示他/她应该得到的周薪。<br />\n　　输入格式：输入只有一行，包括一个整数和一个实数，分别表示工作时间和每小时薪水。<br />\n　　输出格式：输出只有一个实数，表示周薪，保留小数点后2位。<br />\n　　输入输出样例</div><div class='pdsec'>样例输入</div><div class='pddata'>40 50</div><div class='pdsec'>样例输出</div><div class='pddata'>2000.00</div>\n","gpid":"T245","lanqiaotitle":"薪水计算","memorylimit":"512.0MB","tid":"ALGO-99","timelimit":"1.0s","title":"算法训练 薪水计算","src":"程序设计公共基础课(谌卫军)"},{"checkpoint":"字符操作 循环语句","updatetime":"2015-01-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编写一个程序，输入一个1000 以内的正整数，然后把这个整数的每一位数字都分离出来，并逐一地显示。<br />\n　　输入格式：输入只有一行，即一个1000以内的正整数。<br />\n　　输出格式：输出只有一行，即该整数的每一位数字，之间用空格隔开。<br />\n　　输入输出样例</div><div class='pdsec'>样例输入</div><div class='pddata'>769</div><div class='pdsec'>样例输出</div><div class='pddata'>7 6 9</div>\n","gpid":"T244","lanqiaotitle":"数位分离","memorylimit":"512.0MB","tid":"ALGO-98","timelimit":"1.0s","title":"算法训练 数位分离","src":"程序设计公共基础课(谌卫军)"},{"checkpoint":"输出格式","updatetime":"2014-12-29","content":"<div class='pdsec'>描述</div><div class='pdcont'>　　本题定义本学期作业题的输出格式，请认真阅读。<br />\n　　如无特殊说明，开头无空格，间隔符为1个空格，答案最后必须输出换行符(\"\\n\")。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　无</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　Hello World!</div>\n","gpid":"T236","lanqiaotitle":"Hello World!","memorylimit":"512.0MB","tid":"ALGO-96","timelimit":"1.0s","title":"算法训练 Hello World!","src":""},{"checkpoint":"","updatetime":"2014-12-17","content":"<div class='pdcont'><b>问题描述</b><br />\n　　新生舞会开始了。n名新生每人有三个属性：姓名、学号、性别。其中，姓名用长度不超过20的仅由大小写字母构成的字符串表示，学号用长度不超过10的仅由数字构成的字符串表示，性别用一个大写字符‘F’或‘M’表示。任意两人的姓名、学号均互不相同。换言之，每个人可被其姓名或学号唯一确定。给出m对两人的信息（姓名或学号），判断他们是否能共舞。两人能共舞的充要条件为两人性别相异。<br />\n<br />\n<b>输入</b><br />\n　　第一行一个整数n（2&lt;=n&lt;=1000），表示学生人数。接下来的n行每行依次包含一名新生的姓名、学号、性别，分别用一个空格隔开。<br />\n　　之后的一行是一个整数m(1&lt;=m&lt;=1000)，表示询问的数目。接着的m行每行包含两个信息（姓名或学号），保证两个信息不属于同一人，中间用一个空格隔开。<br />\n<br />\n<b>输出</b><br />\n　　对于每个询问输出一行，如果两人可以共舞，输出一个大写字母‘Y’，否则输出一个大写字母‘N’。<br />\n<br />\n<br />\n<b>样例输入</b><br />\n　　4<br />\n　　John 10 M<br />\n　　Jack 11 M<br />\n　　Kate 20 F<br />\n　　Jim 21 M<br />\n　　3<br />\n　　John 11<br />\n　　20 Jack<br />\n　　Jim Jack<br />\n<br />\n<br />\n<b>样例输出</b><br />\n　　N<br />\n　　Y<br />\n　　N<br />\n<br />\n<b>提示</b><br />\n　　可以把名字和学号都当成字符串处理。可以按以下流程实现。<br />\n<br />\n　　#include&lt;iostream&gt;<br />\n　　#include&lt;cstring&gt;<br />\n　　using namespace std;<br />\n<br />\n　　struct tstudent<br />\n　　{<br />\n　　char name[21];<br />\n　　char num[21];<br />\n　　char sex;<br />\n　　};<br />\n<br />\n　　void readdata(tstudent student[], int n)<br />\n　　{<br />\n<b>输入N个学生的信息</b><br />\n　　}<br />\n<br />\n　　int findstudent(tstudent student[], int n, char* data)<br />\n　　{<br />\n　　if (data == NULL) return -1;<br />\n<br />\n<b>判断是否有某个学生的学号或名字等于data，如果有，函数返回该学生在student数组中的序号，否则返回-1</b><br />\n　　}<br />\n<br />\n　　void solve(tstudent student[], int n, int m)<br />\n　　{<br />\n　　char x[21], y[21];<br />\n　　for (int i=0; i&lt;m; i++) {<br />\n<b>输入两个人的信息X、Y。通过调用findstudent函数判断这两个人能否成为舞伴</b><br />\n　　}<br />\n　　}<br />\n<br />\n　　int main()<br />\n　　{<br />\n　　int n, m;<br />\n　　tstudent student[1010];<br />\n<br />\n　　cin&gt;&gt;n;<br />\n<br />\n　　readdata(student, n);<br />\n　　cin&gt;&gt;m;<br />\n　　solve(student, n, m);<br />\n　　}</div>\n","gpid":"T227","lanqiaotitle":"新生舞会","memorylimit":"512.0MB","tid":"ALGO-94","timelimit":"1.0s","title":"算法训练 新生舞会","src":""},{"checkpoint":"函数设计 字符操作","updatetime":"2014-12-16","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　一个整数的“反置数”指的是把该整数的每一位数字的顺序颠倒过来所得到的另一个整数。如果一个整数的末尾是以0结尾，那么在它的反置数当中，这些0就被省略掉了。比如说，1245的反置数是5421，而1200的反置数是21。请编写一个程序，输入两个整数，然后计算这两个整数的反置数之和sum，然后再把sum的反置数打印出来。要求：由于在本题中需要多次去计算一个整数的反置数，因此必须把这部分代码抽象为一个函数的形式。<br />\n　　输入格式：输入只有一行，包括两个整数，中间用空格隔开。<br />\n　　输出格式：输出只有一行，即相应的结果。<br />\n　　输入输出样例</div><div class='pdsec'>样例输入</div><div class='pddata'>435 754</div><div class='pdsec'>样例输出</div><div class='pddata'>199</div>\n","gpid":"T226","lanqiaotitle":"反置数","memorylimit":"512.0MB","tid":"ALGO-93","timelimit":"1.0s","title":"算法训练 反置数","src":"程序设计公共基础课(谌卫军)"},{"checkpoint":"数组运算","updatetime":"2014-11-26","content":"<div class='pdcont'><b> </b><br />\n<b>问题描述</b><br />\n　　编写一个程序，先输入一个字符串str（长度不超过20），再输入单独的一个字符ch，然后程序会把字符串str当中出现的所有的ch字符都删掉，从而得到一个新的字符串str2，然后把这个字符串打印出来。<br />\n　　输入格式：输入有两行，第一行是一个字符串（内部没有空格），第二行是一个字符。<br />\n　　输出格式：经过处理以后的字符串。<br />\n<b>输入输出样例</b></div><div class='pdsec'>样例输入</div><div class='pddata'>123-45-678<br />\n-</div><div class='pdsec'>样例输出</div><div class='pddata'>12345678</div>\n","gpid":"T221","lanqiaotitle":"字符删除","memorylimit":"512.0MB","tid":"ALGO-89","timelimit":"1.0s","title":"算法训练 字符删除","src":"程序设计公共基础课(谌卫军)"},{"checkpoint":"","updatetime":"2014-11-25","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个长度为n的字符串S，还有一个数字L，统计长度大于等于L的出现次数最多的子串（不同的出现可以相交），如果有多个，输出最长的，如果仍然有多个，输出第一次出现最早的。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个数字L。<br />\n　　第二行是字符串S。<br />\n　　L大于0，且不超过S的长度。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行，题目要求的字符串。<br />\n<br />\n　　输入样例1：<br />\n　　4<br />\n　　bbaabbaaaaa<br />\n<br />\n　　输出样例1：<br />\n　　bbaa<br />\n<br />\n　　输入样例2：<br />\n　　2<br />\n　　bbaabbaaaaa<br />\n<br />\n　　输出样例2：<br />\n　　aa</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=60<br />\n　　S中所有字符都是小写英文字母。</div><div class='pdsec'>提示</div><div class='pdcont'>　　枚举所有可能的子串，统计出现次数，找出符合条件的那个</div>\n","gpid":"T220","lanqiaotitle":"字串统计","memorylimit":"512.0MB","tid":"ALGO-88","timelimit":"1.0s","title":"算法训练 字串统计","src":""},{"checkpoint":"字符操作 数学知识","updatetime":"2014-11-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编写一个程序，输入一个二进制的字符串（长度不超过32），然后计算出相应的十进制整数，并把它打印出来。<br />\n　　输入格式：输入为一个字符串，每个字符都是’0’或’1’，字符串的长度不超过32。<br />\n　　输出格式：输出一个整数。<br />\n　　输入输出样例</div><div class='pdsec'>样例输入</div><div class='pddata'>1101</div><div class='pdsec'>样例输出</div><div class='pddata'>13</div>\n","gpid":"T217","lanqiaotitle":"进制转换","memorylimit":"512.0MB","tid":"ALGO-85","timelimit":"1.0s","title":"算法训练 进制转换","src":"程序设计公共基础课(谌卫军)"},{"checkpoint":"循环语句 数学知识","updatetime":"2014-11-20","content":"<div class='pdcont'><b>问题描述</b><br />\n　　一个整数n的阶乘可以写成n!，它表示从1到n这n个整数的乘积。阶乘的增长速度非常快，例如，13!就已经比较大了，已经无法存放在一个整型变量中；而35!就更大了，它已经无法存放在一个浮点型变量中。因此，当n比较大时，去计算n!是非常困难的。幸运的是，在本题中，我们的任务不是去计算n!，而是去计算n!最右边的那个非0的数字是多少。例如，5! = 1*2*3*4*5 = 120，因此5!最右边的那个非0的数字是2。再如：7! = 5040，因此7!最右边的那个非0的数字是4。请编写一个程序，输入一个整数n(n&lt;=100)，然后输出n! 最右边的那个非0的数字是多少。<br />\n　　输入格式：输入只有一个整数n。<br />\n　　输出格式：输出只有一个整数，即n! 最右边的那个非0的数字。<br />\n<b>输入输出样例</b></div><div class='pdsec'>样例输入</div><div class='pddata'>6</div><div class='pdsec'>样例输出</div><div class='pddata'>2</div>\n","gpid":"T213","lanqiaotitle":"阶乘","memorylimit":"512.0MB","tid":"ALGO-83","timelimit":"1.0s","title":"算法训练 阶乘","src":"程序设计公共基础课(谌卫军)"},{"checkpoint":"","updatetime":"2014-11-14","content":"<div class='pdcont'>　　根据输入的正整数n (1　　米字形由一个(2n-1)*(2n-1)的矩阵组成，矩阵包含从大写A开始的n个字母<br />\n　　例如:n=3时，包含A,B,C；n=4时，包含A,B,C,D。<br />\n　　矩阵的正中间为n个字母中字典序最大的那个，从这个字母开始，沿着西北、正北、东北、正西、正东、西南、正南、东南八个方向各有一条由大写字母组成的直线。并且直线上的字母按字典序依次减小，直到大写字母A。<br />\n　　矩阵的其它位置用英文句号．填充。<br />\n<br />\n　　样例输入一<br />\n　　3<br />\n<br />\n　　样例输出一<br />\n　　Ａ．Ａ．Ａ<br />\n　　．ＢＢＢ．<br />\n　　ＡＢＣＢＡ<br />\n　　．ＢＢＢ．<br />\n　　Ａ．Ａ．Ａ<br />\n<br />\n　　样例输入二<br />\n　　4<br />\n<br />\n　　样例输出二<br />\n　　Ａ．．Ａ．．Ａ<br />\n　　．Ｂ．Ｂ．Ｂ．<br />\n　　．．ＣＣＣ．．<br />\n　　ＡＢＣＤＣＢＡ<br />\n　　．．ＣＣＣ．．<br />\n　　．Ｂ．Ｂ．Ｂ．<br />\n　　Ａ．．Ａ．．Ａ</div>\n","gpid":"T208","lanqiaotitle":"输出米字形","memorylimit":"512.0MB","tid":"ALGO-82","timelimit":"1.0s","title":"算法训练 输出米字形","src":""},{"checkpoint":"","updatetime":"2014-11-11","content":"<pre class='pddata'>\n编写函数，求包含n个元素的整数数组中元素的平均值。要求在函数内部使用指针操纵数组元素，其中n个整数从键盘输入，输出为其平均值。\n</pre>\n<pre class='pddata'>\n样例输入: （输入格式说明：5为输入数据的个数，3 4 0 0 2 是以空格隔开的5个整数）<br />5 <br />3 4 0 0 2<br />样例输出:<br />1\n</pre>\n<pre class='pddata'>\n样例输入: <br />7<br />3 2 7 5 2 9 1<br />样例输出:<br />4\n</pre>\n\n","gpid":"T202","lanqiaotitle":"整数平均值","memorylimit":"512.0MB","tid":"ALGO-80","timelimit":"1.0s","title":"算法训练 整数平均值","src":""},{"checkpoint":"","updatetime":"2014-10-08","content":"<pre class='pddata'>\n输入一个字符串，编写程序输出该字符串中元音字母的首次出现位置，如果没有元音字母输出0。英语元音字母只有‘a’、‘e’、‘i’、‘o’、‘u’五个。\n</pre>\n<pre class='pddata'>\n样例输入: <br />hello<br />样例输出:<br />2\n</pre>\n<pre class='pddata'>\n样例输入: <br />apple<br />样例输出:<br />1\n</pre>\n<pre class='pddata'>\n样例输入: <br />pmp<br />样例输出:<br />0\n</pre>\n\n","gpid":"T200","lanqiaotitle":"确定元音字母位置","memorylimit":"512.0MB","tid":"ALGO-78","timelimit":"1.0s","title":"算法训练 确定元音字母位置","src":""},{"checkpoint":"","updatetime":"2014-06-30","content":"<div class='pdcont'>　　输入两个点的坐标，即p1 = (x1, y1)和p2=(x2, y2)，求过这两个点的直线的斜率。如果斜率为无穷大输出“INF”。</div><div class='pdsec'>样例输入</div><div class='pddata'>1 2<br />\n2 4</div><div class='pdsec'>样例输出</div><div class='pddata'>2</div><div class='pdsec'>样例输入</div><div class='pddata'>1 2<br />\n1 4</div><div class='pdsec'>样例输出</div><div class='pddata'>INF</div><div class='pdsec'>样例输入</div><div class='pddata'>1 2<br />\n3 2</div><div class='pdsec'>样例输出</div><div class='pddata'>0</div>\n","gpid":"T188","lanqiaotitle":"斜率计算","memorylimit":"512.0MB","tid":"ALGO-77","timelimit":"1.0s","title":"算法训练 斜率计算","src":""},{"checkpoint":"进制转换","updatetime":"2014-06-23","content":"<div class='pdcont'>　　编写函数把一个十进制数输出其对应的八进制数。</div><div class='pdsec'>样例输入</div><div class='pddata'>9274</div><div class='pdsec'>样例输出</div><div class='pddata'>22072</div>\n","gpid":"T187","lanqiaotitle":"十进制数转八进制数","memorylimit":"512.0MB","tid":"ALGO-76","timelimit":"1.0s","title":"算法训练 十进制数转八进制数","src":""},{"checkpoint":"算法 枚举、标记数组","updatetime":"2014-05-29","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有n个人围成一圈，顺序排号（编号为1到n）。从第1个人开始报数(从1到3报数)，凡报到3的人退出圈子。从下一个人开始继续报数，直到剩下最后一个人，游戏结束。<br />\n　　问最后留下的是原来第几号的那位。<br />\n　　举个例子，8个人围成一圈：<br />\n　　1 2 3 4 5 6 7 8<br />\n　　第1次报数之后，3退出，剩下：<br />\n　　1 2 4 5 6 7 8\t（现在从4开始报数）<br />\n　　第2次报数之后，6退出，剩下：<br />\n　　1 2 4 5 7 8\t\t（现在从7开始报数）<br />\n　　第3次报数之后，1退出，剩下：<br />\n　　2 4 5 7 8\t\t（现在从2开始报数）<br />\n　　第4次报数之后，5退出，剩下：<br />\n　　2 4 7 8\t\t\t（现在从7开始报数）<br />\n　　第5次报数之后，2退出，剩下：<br />\n　　4 7 8\t\t\t（现在从4开始报数）<br />\n　　第6次报数之后，8退出，剩下：<br />\n　　4 7\t\t\t\t（现在从4开始报数）<br />\n　　最后一次报数之后，4退出，剩下：<br />\n　　7.<br />\n　　所以，最后留下来的人编号是7。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一个正整数n，(1&lt;n&lt;10000)</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个正整数，最后留下来的那个人的编号。</div><div class='pdsec'>样例输入</div><div class='pddata'>8</div><div class='pdsec'>样例输出</div><div class='pddata'>7</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于100%的数据，1&lt;n&lt;10000。</div>\n","gpid":"T182","lanqiaotitle":"筛选号码","memorylimit":"512.0MB","tid":"ALGO-75","timelimit":"1.0s","title":"算法训练 筛选号码","src":""},{"checkpoint":"算法 字符串基本操作","updatetime":"2014-05-27","content":"<div class='pdcont'>　　编程将两个字符串连接起来。例如country与side相连接成为countryside。<br />\n　　输入两行，每行一个字符串（只包含小写字母，长度不超过100）；输出一行一个字符串。</div><div class='pdsec'>样例输入</div><div class='pddata'>country<br />\nside</div><div class='pdsec'>样例输出</div><div class='pddata'>countryside</div>\n","gpid":"T180","lanqiaotitle":"连接字符串","memorylimit":"512.0MB","tid":"ALGO-74","timelimit":"1.0s","title":"算法训练 连接字符串","src":""},{"checkpoint":"字符串 循环","updatetime":"2014-05-15","content":"<div class='pdcont'>　　输入一个字符串(长度在100以内)，统计其中数字字符出现的次数。</div><div class='pdsec'>样例输入</div><div class='pddata'>Ab100cd200</div><div class='pdsec'>样例输出</div><div class='pddata'>6</div>\n","gpid":"T174","lanqiaotitle":"统计字符次数","memorylimit":"512.0MB","tid":"ALGO-73","timelimit":"1.0s","title":"算法训练 统计字符次数","src":"程序设计公共基础课"},{"checkpoint":"分支结构","updatetime":"2014-05-14","content":"<div class='pdcont'>　　输入一个百分制的成绩t后，按下式输出它的等级。等级为：90~100为A，80~89为B，70~79为C，60~69为D，0~59为E。</div><div class='pdsec'>样例输入</div><div class='pddata'>98</div><div class='pdsec'>样例输出</div><div class='pddata'>A</div>\n","gpid":"T173","lanqiaotitle":"成绩的等级输出","memorylimit":"512.0MB","tid":"ALGO-72","timelimit":"1.0s","title":"算法训练 成绩的等级输出","src":"程序设计公共基础课"},{"checkpoint":"字符串","updatetime":"2014-05-09","content":"<div class='pdcont'>　　编程实现两个字符串s1和s2的字典序比较。（保证每一个字符串不是另一个的前缀，且长度在100以内）。若s1和s2相等，输出0；若它们不相等，则指出其第一个不同字符的ASCII码的差值：如果s1&gt;s2，则差值为正；如果s1&lt;s2，则差值为负。</div><div class='pdsec'>样例输入</div><div class='pddata'>java basic</div><div class='pdsec'>样例输出</div><div class='pddata'>8</div>\n","gpid":"T170","lanqiaotitle":"比较字符串","memorylimit":"512.0MB","tid":"ALGO-71","timelimit":"1.0s","title":"算法训练 比较字符串","src":"程序设计公共基础课"},{"checkpoint":"字符串 循环","updatetime":"2014-05-08","content":"<div class='pdcont'>　　求出5个字符串中最长的字符串。每个字符串长度在100以内，且全为小写字母。</div><div class='pdsec'>样例输入</div><div class='pddata'>one two three four five</div><div class='pdsec'>样例输出</div><div class='pddata'>three</div>\n","gpid":"T169","lanqiaotitle":"最长字符串","memorylimit":"512.0MB","tid":"ALGO-70","timelimit":"1.0s","title":"算法训练 最长字符串","src":"程序设计公共基础课"},{"checkpoint":"字符串","updatetime":"2014-05-07","content":"<div class='pdcont'>　　输入一个字符串，长度在100以内，按相反次序输出其中的所有字符。</div><div class='pdsec'>样例输入</div><div class='pddata'>tsinghua</div><div class='pdsec'>样例输出</div><div class='pddata'>auhgnist</div>\n","gpid":"T168","lanqiaotitle":"字符串逆序","memorylimit":"512.0MB","tid":"ALGO-69","timelimit":"1.0s","title":"算法训练 字符串逆序","src":"程序设计公共基础课"},{"checkpoint":"if-else结构，数据有效性检查","updatetime":"2014-04-30","content":"<div class='pdcont'>　　编写函数，判断某个给定字符是否为数字。</div><div class='pdsec'>样例输入</div><div class='pddata'>9</div><div class='pdsec'>样例输出</div><div class='pddata'>yes</div>\n","gpid":"T164","lanqiaotitle":"判定数字","memorylimit":"512.0MB","tid":"ALGO-68","timelimit":"1.0s","title":"算法训练 判定数字","src":"程序设计公共基础课"},{"checkpoint":"数组，逻辑表达式","updatetime":"2014-04-28","content":"<div class='pdcont'>　　输入11个整数，计算它们的最大值和最小值。</div><div class='pdsec'>样例输入</div><div class='pddata'>0 1 2 3 4 5 6 7 8 9 10</div><div class='pdsec'>样例输出</div><div class='pddata'>10 0</div>\n","gpid":"T161","lanqiaotitle":"最大值与最小值的计算","memorylimit":"512.0MB","tid":"ALGO-67","timelimit":"1.0s","title":"算法训练 最大值与最小值的计算","src":"程序设计公共基础课"},{"checkpoint":"","updatetime":"2014-04-28","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　从键盘输入一个字符串（长度&lt;=40个字符），并以字符 ’.’ 结束。编辑功能有：<br />\n　　1    D：删除一个字符，命令的方式为： D  a  其中a为被删除的字符，例如：D  s  表示删除字符 ’s’ ，若字符串中有多个 ‘s’，则删除第一次出现的。<br />\n　　2    I：插入一个字符，命令的格式为：I  a1  a2  其中a1表示插入到指定字符前面，a2表示将要插入的字符。例如：I  s  d  表示在指定字符 ’s’ 的前面插入字符 ‘d’ ，若原串中有多个 ‘s’ ，则插入在最后一个字符的前面。<br />\n　　3   R：替换一个字符，命令格式为：R  a1  a2  其中a1为被替换的字符，a2为替换的字符，若在原串中有多个a1则应全部替换。<br />\n　　在编辑过程中，若出现被改的字符不存在时，则给出提示信息。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入共两行，第一行为原串(以’.’结束)，第二行为命令（输入方式参见“问题描述” 。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出共一行，为修改后的字符串或输出指定字符不存在的提示信息。</div><div class='pdsec'>样例输入</div><div class='pddata'>This is a book.<br />\nD s</div><div class='pdsec'>样例输出</div><div class='pddata'>Thi is a book.</div><div class='pdsec'>输入输出样例解释</div><div class='pdcont'>　　命令为删去s，第一个在字符中出现的s在This中，即得到结果。</div>\n","gpid":"T160","lanqiaotitle":"字符串编辑","memorylimit":"512.0MB","tid":"ALGO-66","timelimit":"1.0s","title":"算法训练 字符串编辑","src":""},{"checkpoint":"","updatetime":"2014-04-25","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　设有有2 <sup>n</sup>（n&lt;=6）个球队进行单循环比赛，计划在2 <sup>n</sup> – 1天内完成，每个队每天进行一场比赛。设计一个比赛的安排，使在2 <sup>n</sup> – 1天内每个队都与不同的对手比赛。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入文件matchplan.in共一行，输入n的数值。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出文件matchplan.out共（2 n – 1）行，第i行输出第i天的比赛安排。<br />\n　　格式为：&lt;i&gt; A-B，C-D，……。其中i是天数，A，B分别为比赛双方的编号，每行共2 <sup>n-1</sup>个比赛场次。</div><div class='pdsec'>样例输入</div><div class='pddata'>2</div><div class='pdsec'>样例输出</div><div class='pddata'>&lt;1&gt;1-2,3-4<br />\n&lt;2&gt;1-3,2-4<br />\n&lt;3&gt;1-4,2-3</div>\n","gpid":"T159","lanqiaotitle":"比赛安排","memorylimit":"512.0MB","tid":"ALGO-65","timelimit":"1.0s","title":"算法训练 比赛安排","src":""},{"checkpoint":"","updatetime":"2014-04-22","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个英文字母判断这个字母是大写还是小写。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入只包含一个英文字母c。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　如果c是大写字母，输出“upper”，否则输出“lower”。</div><div class='pdsec'>样例输入</div><div class='pddata'>x</div><div class='pdsec'>样例输出</div><div class='pddata'>lower</div><div class='pdsec'>样例输入</div><div class='pddata'>B</div><div class='pdsec'>样例输出</div><div class='pddata'>upper</div>\n","gpid":"T153","lanqiaotitle":"大小写判断","memorylimit":"512.0MB","tid":"ALGO-64","timelimit":"1.0s","title":"算法训练 大小写判断","src":""},{"checkpoint":"","updatetime":"2014-04-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输出九九乘法表。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出格式见下面的样例。乘号用“*”表示。</div><div class='pdsec'>样例输出</div><div class='pddata'>下面给出输出的前几行：<br />\n1*1=1<br />\n2*1=2 2*2=4<br />\n3*1=3 3*2=6 3*3=9<br />\n4*1=4 4*2=8 4*3=12 4*4=16<br />\n……</div>\n","gpid":"T151","lanqiaotitle":"乘法表","memorylimit":"512.0MB","tid":"ALGO-63","timelimit":"1.0s","title":"算法训练 乘法表","src":""},{"checkpoint":"","updatetime":"2014-04-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输入正整数a, m，输出a^2%m，其中^表示乘方，即a^2表示a的平方，%表示取余。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含两个整数a, m，a不超过10000。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个整数，即a^2%m的值。</div><div class='pdsec'>样例输入</div><div class='pddata'>5 6</div><div class='pdsec'>样例输出</div><div class='pddata'>1</div>\n","gpid":"T150","lanqiaotitle":"平方计算","memorylimit":"512.0MB","tid":"ALGO-62","timelimit":"1.0s","title":"算法训练 平方计算","src":""},{"checkpoint":"","updatetime":"2014-04-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　能被2整除的数称为偶数，不能被2整除的数称为奇数。给一个整数x，判断x是奇数还是偶数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包括一个整数x，0&lt;=x&lt;=100000000。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　如果x是奇数，则输出“odd”，如果是偶数，则输出“even”。</div><div class='pdsec'>样例输入</div><div class='pddata'>10</div><div class='pdsec'>样例输出</div><div class='pddata'>even</div><div class='pdsec'>样例输入</div><div class='pddata'>2009</div><div class='pdsec'>样例输出</div><div class='pddata'>odd</div>\n","gpid":"T149","lanqiaotitle":"奇偶判断","memorylimit":"512.0MB","tid":"ALGO-61","timelimit":"1.0s","title":"算法训练 奇偶判断","src":""},{"checkpoint":"","updatetime":"2014-04-18","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个矩阵A,一个非负整数b和一个正整数m，求A的b次方除m的余数。<br />\n　　其中一个nxn的矩阵除m的余数得到的仍是一个nxn的矩阵，这个矩阵的每一个元素是原矩阵对应位置上的数除m的余数。<br />\n　　要计算这个问题，可以将A连乘b次，每次都对m求余，但这种方法特别慢，当b较大时无法使用。下面给出一种较快的算法(用A^b表示A的b次方)：<br />\n　　若b=0，则A^b%m=I%m。其中I表示单位矩阵。<br />\n　　若b为偶数，则A^b%m=(A^(b/2)%m)^2%m，即先把A乘b/2次方对m求余，然后再平方后对m求余。<br />\n　　若b为奇数，则A^b%m=(A^(b-1)%m)*a%m，即先求A乘b-1次方对m求余，然后再乘A后对m求余。<br />\n　　这种方法速度较快，请使用这种方法计算A^b%m，其中A是一个2x2的矩阵，m不大于10000。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入第一行包含两个整数b, m，第二行和第三行每行两个整数，为矩阵A。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出两行，每行两个整数，表示A^b%m的值。</div><div class='pdsec'>样例输入</div><div class='pddata'>2 2<br />\n1 1<br />\n0 1</div><div class='pdsec'>样例输出</div><div class='pddata'>1 0<br />\n0 1</div>\n","gpid":"T148","lanqiaotitle":"矩阵乘方","memorylimit":"512.0MB","tid":"ALGO-60","timelimit":"1.0s","title":"算法训练 矩阵乘方","src":""},{"checkpoint":"","updatetime":"2014-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　快速排序是最经常使用的一种排序方式，对于给定的n个数组成的一个数组，请使用快速排序对其进行排序。<br />\n　　现给定一序列，请用快速排序将其按升序排序并输出。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个数N。<br />\n　　第2~N+1行每行一个数，表示给定序列。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　共N行，每行一个数，表示所求序列。</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n1<br />\n4<br />\n2<br />\n3<br />\n4</div><div class='pdsec'>样例输出</div><div class='pddata'>1<br />\n2<br />\n3<br />\n4<br />\n4</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　共10组数据。<br />\n　　对100%的数据，N&lt;=10^5，所有数均为非负数且在int范围内。</div>\n","gpid":"T147","lanqiaotitle":"快速排序","memorylimit":"512.0MB","tid":"ALGO-59","timelimit":"1.0s","title":"算法训练 快速排序","src":""},{"checkpoint":"","updatetime":"2014-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个字符串，将这个串的所有字母逆序后输出。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含一个字符串，长度不超过100，字符串中不含空格。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出包含一个字符串，为上面字符串的逆序。</div><div class='pdsec'>样例输入</div><div class='pddata'>tsinsen</div><div class='pdsec'>样例输出</div><div class='pddata'>nesnist</div>\n","gpid":"T146","lanqiaotitle":"字串逆序","memorylimit":"512.0MB","tid":"ALGO-58","timelimit":"1.0s","title":"算法训练 字串逆序","src":""},{"checkpoint":"","updatetime":"2014-04-16","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　从键盘输入一个含有括号的四则运算表达式，要求去掉可能含有的多余的括号，结果要保持原表达式中变量和运算符的相对位置不变，且与原表达式等价,不要求化简。另外不考虑'+'　　'-'用作正负号的情况，即输入表达式不会出现(+a)或(-a)的情形。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　表达式字符串，长度不超过255,　　并且不含空格字符。表达式中的所有变量都是单个小写的英文字母, 运算符只有加+减-乘*除/等运算符号。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　去掉多余括号后的表达式</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n样例一：\na+(b+c)-d\n样例二：\na+b/(c+d)\n样例三：\n(a*b)+c/d\n样例四：\n((a+b)*f)-(i/j)\n</PRE></FONT>\n<P></P>\n<br /></p><p class=\"subtitle\">样例输出</p><p class=\"probcontent\">\n<P><FONT face=\"Times New Roman\" size=3><PRE>样例一：\na+b+c-d\n样例二：\na+b/(c+d)\n样例三：\na*b+c/d\n样例四：\n(a+b)*f-i/j\n</PRE></FONT>\n<P></P>\n<br />\n</pre>\n\n","gpid":"T144","lanqiaotitle":"删除多余括号","memorylimit":"512.0MB","tid":"ALGO-57","timelimit":"1.0s","title":"算法训练 删除多余括号","src":""},{"checkpoint":"","updatetime":"2014-04-14","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个信封，有N（1≤N≤100）个位置可以贴邮票，每个位置只能贴一张邮票。我们现在有M(M&lt;=100)种不同邮资的邮票，面值为X1,X2….Xm分（Xi是整数，1≤Xi≤255），每种都有N张。<br />\n<br />\n　　显然，信封上能贴的邮资最小值是min(X1, X2, …, Xm)，最大值是 N*max(X1, X2, …,　　Xm)。由所有贴法得到的邮资值可形成一个集合（集合中没有重复数值），要求求出这个集合中是否存在从1到某个值的连续邮资序列，输出这个序列的最大值。<br />\n<br />\n　　例如，N=4，M=2，面值分别为4分，1分，于是形成1，2，3，4，5，6，7，8，9，10，12，13，16的序列，而从1开始的连续邮资序列为1，2，3，4，5，6，7，8，9，10，所以连续邮资序列的最大值为10分。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行：最多允许粘贴的邮票张数N；第二行：邮票种数M；第三行：空格隔开的M个数字，表示邮票的面值Xi。注意：Xi序列不一定是大小有序的！</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　从1开始的连续邮资序列的最大值MAX。若不存在从1分开始的序列（即输入的邮票中没有1分面额的邮票），则输出0.</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n样例一：\n4\n2\n4 1\n样例二：\n10\n5\n2 4 6 8 10\n</PRE></FONT>\n<P></P>\n<br /></p><p class=\"subtitle\">样例输出</p><p class=\"probcontent\">\n<P><FONT face=\"Times New Roman\" size=3><PRE>样例一：\n10\n样例二：\n0</PRE></FONT>\n<P></P>\n<br />\n</pre>\n\n","gpid":"T141","lanqiaotitle":"邮票","memorylimit":"512.0MB","tid":"ALGO-56","timelimit":"1.0s","title":"算法训练 邮票","src":""},{"checkpoint":"","updatetime":"2014-04-11","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定两个N×M的矩阵，计算其和。其中：<br />\n　　N和M大于等于1且小于等于100，矩阵元素的绝对值不超过1000。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入数据的第一行包含两个整数N、M，表示需要相加的两个矩阵的行数和列数。接下来2*N行每行包含M个数，其中前N行表示第一个矩阵，后N行表示第二个矩阵。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　你的程序需要输出一个N*M的矩阵，表示两个矩阵相加的结果。注意，输出中每行的最后不应有多余的空格，否则你的程序有可能被系统认为是Presentation　　Error</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n2 2\n1 2\n3 4\n5 6\n7 8</PRE></FONT>\n<P></P>\n<br /></p><p class=\"subtitle\">样例输出</p><p class=\"probcontent\">\n<P><FONT face=\"Times New Roman\" size=3><PRE>6 8\n10 12</PRE></FONT>\n<P></P>\n<br />\n</pre>\n\n","gpid":"T139","lanqiaotitle":"矩阵加法","memorylimit":"512.0MB","tid":"ALGO-55","timelimit":"1.0s","title":"算法训练 矩阵加法","src":""},{"checkpoint":"","updatetime":"2014-04-11","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　首先给出简单加法算式的定义：<br />\n　　如果有一个算式(i)+(i+1)+(i+2),(i&gt;=0)，在计算的过程中，没有任何一个数位出现了进位，则称其为简单的加法算式。<br />\n　　例如：i=3时，3+4+5=12，有一个进位，因此3+4+5不是一个简单的加法算式；又如i=112时，112+113+114=339，没有在任意数位上产生进位，故112+113+114是一个简单的加法算式。<br />\n<br />\n　　问题：给定一个正整数n，问当i大于等于0且小于n时,有多少个算式(i)+(i+1)+(i+2)是简单加法算式。其中n&lt;10000。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一个整数，表示n</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个整数,表示简单加法算式的个数</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n4</PRE></FONT>\n<P></P>\n<br /></p><p class=\"subtitle\">样例输出</p><p class=\"probcontent\">\n<P><FONT face=\"Times New Roman\" size=3><PRE>3</PRE></FONT>\n<P></P>\n<br />\n</pre>\n\n","gpid":"T138","lanqiaotitle":"简单加法(基本型)","memorylimit":"512.0MB","tid":"ALGO-54","timelimit":"1.0s","title":"算法训练 简单加法(基本型)","src":""},{"checkpoint":"","updatetime":"2014-04-04","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　求一个0～N-1的排列（即每个数只能出现一次），给出限制条件（一张N*N的表，第i行第j列的1或0，表示为j-1这个数不能出现在i-1这个数后面，并保证第i行第i列为0），将这个排列看成一个自然数，求从小到大排序第K个排列。</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　N&lt;=10，K&lt;=500000</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行为N和K,接下来的N行，每行N个数，0表示不能，1表示能</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　所求的排列</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n3 2\n0 1 1\n1 0 0\n0 1 0\n</PRE></FONT>\n<P></P>\n<br /></p><p class=\"subtitle\">样例输出</p><p class=\"probcontent\">\n<P><FONT face=\"Times New Roman\" size=3><PRE>1 0 2\n解释：\n对于N=3的没有任何限制的情况\n第一：0 1 2\n第二：0 2 1\n第三：1 0 2\n第四：1 2 0\n第五：2 0 1\n第六：2 1 0\n根据题目所给的限制条件由于2不能出现在1后面，0不能出现在2后面\n第一：0 2 1\n第二：1 0 2\n第三：2 1 0\n</PRE></FONT>\n<P></P>\n<br />\n</pre>\n\n","gpid":"T131","lanqiaotitle":"排列问题","memorylimit":"512.0MB","tid":"ALGO-52","timelimit":"1.0s","title":"算法训练 排列问题","src":""},{"checkpoint":"","updatetime":"2014-04-02","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定某整数数组和某一整数b。要求删除数组中可以被b整除的所有元素，同时将该数组各元素按从小到大排序。如果数组元素数值在A到Z的ASCII之间，替换为对应字母。元素个数不超过100，b在1至100之间。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行为数组元素个数和整数b<br />\n　　第二行为数组各个元素</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　按照要求输出</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n7 2\n77 11 66 22 44 33 55</PRE></FONT>\n<P></P>\n<br /></p><p class=\"subtitle\">样例输出</p><p class=\"probcontent\">\n<P><FONT face=\"Times New Roman\" size=3><PRE>11 33  55 M</PRE></FONT>\n<P></P>\n<br />\n</pre>\n\n","gpid":"T128","lanqiaotitle":"数组查找及替换","memorylimit":"512.0MB","tid":"ALGO-50","timelimit":"1.0s","title":"算法训练 数组查找及替换","src":""},{"checkpoint":"","updatetime":"2014-03-19","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　“两只小蜜蜂呀，飞在花丛中呀……”<br />\n<br />\n　　话说这天天上飞舞着两只蜜蜂，它们在跳一种奇怪的舞蹈。用一个空间直角坐标系来描述这个世界，那么这两只蜜蜂初始坐标分别为(x1,y1,z1)，(x2,y2,z2)　　。在接下来它们将进行n次飞行，第i次飞行两只蜜蜂分别按照各自的速度向量飞行ti个单位时间。对于这一现象，玮玮已经观察了很久。他很想知道在蜜蜂飞舞结束时，两只蜜蜂的距离是多少。现在他就求教于你，请你写一个程序来帮他计算这个结果。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行有且仅有一个整数n，表示两只蜜蜂将进行n次飞行。<br />\n<br />\n　　接下来有n行。<br />\n<br />\n　　第i行有7个用空格分隔开的整数ai,bi,ci,di,ei,fi,ti　　，表示第一只蜜蜂单位时间的速度向量为(ai,bi,ci) ，第二只蜜蜂单位时间的速度向量为(di,ei,fi) ，它们飞行的时间为ti 。<br />\n<br />\n　　最后一行有6个用空格分隔开的整数x1,y1,z1,x2,y2,z2，如题所示表示两只蜜蜂的初始坐标。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出仅包含一行，表示最后两只蜜蜂之间的距离。保留4位小数位。</div><div class='pdsec'>样例输入</div><pre class='pddata'>\nSample 1\n1\n1 1 1 1 -1 1 2\n3 0 1 2 0 0\nSample 2\n3\n1 1 1 1 -1 1 2\n2 1 2 0 -1 -1 2\n2 0 0 -1 1 1 3\n3 0 1 2 0 0\n</PRE></FONT>\n<P></P>\n<br /></p><p class=\"subtitle\">样例输出</p><p class=\"probcontent\">\n<P><FONT face=\"Times New Roman\" size=3><PRE>Sample 1\n4.2426\nSample 2\n15.3948</PRE></FONT>\n<P></P>\n<br />\n</pre>\n\n","gpid":"T109","lanqiaotitle":"蜜蜂飞舞","memorylimit":"512.0MB","tid":"ALGO-47","timelimit":"1.0s","title":"算法训练 蜜蜂飞舞","src":""},{"checkpoint":"","updatetime":"2014-03-19","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　如果将课本上的Hanoi塔问题稍做修改：仍然是给定N只盘子，3根柱子，但是允许每次最多移动相邻的M只盘子（当然移动盘子的数目也可以小于M）,最少需要多少次？<br />\n　　例如N=5，M=2时，可以分别将最小的2个盘子、中间的2个盘子以及最大的一个盘子分别看作一个整体，这样可以转变为N=3，M=1的情况，共需要移动7次。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入数据仅有一行，包括两个数N和M（0&lt;=M&lt;=N&lt;=8）</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　仅输出一个数，表示需要移动的最少次数</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n5 2</PRE></FONT>\n<P></P>\n<br /></p><p class=\"subtitle\">样例输出</p><p class=\"probcontent\">\n<P><FONT face=\"Times New Roman\" size=3><PRE>7</PRE></FONT>\n<P></P>\n<br />\n</pre>\n\n","gpid":"T108","lanqiaotitle":"Hanoi问题","memorylimit":"512.0MB","tid":"ALGO-46","timelimit":"1.0s","title":"算法训练 Hanoi问题","src":""},{"checkpoint":"","updatetime":"2014-03-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输入一个实数x，求最小的n使得，1/2+1/3+1/4+...+1/(n+1)&gt;=x。<br />\n<br />\n　　输入的实数x保证大于等于0.01，小于等于5.20，并且恰好有两位小数。你的程序要能够处理多组数据，即不停地读入x，如果x不等于0.00，则计算答案，否则退出程序。<br />\n<br />\n　　输出格式为对于一个x，输出一行n card(s)。其中n表示要计算的答案。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　分行输入x的具体数值</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　分行输出n的数值，格式为n card(s)</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n1.00\n3.71\n0.04\n5.19\n0.00</PRE></FONT>\n<P></P>\n<br /></p><p class=\"subtitle\">样例输出</p><p class=\"probcontent\">\n<P><FONT face=\"Times New Roman\" size=3><PRE>3 card(s)\n61 card(s)\n1 card(s)\n273 card(s)</PRE></FONT>\n<P></P>\n<br />\n</pre>\n\n","gpid":"T107","lanqiaotitle":"调和数列问题","memorylimit":"512.0MB","tid":"ALGO-45","timelimit":"1.0s","title":"算法训练 调和数列问题","src":""},{"checkpoint":"APIO 2009","updatetime":"2014-02-28","content":"<div class='pdcont'>　　会议中心　　Siruseri政府建造了一座新的会议中心。许多公司对租借会议中心的会堂很感兴趣，他们希望能够在里面举行会议。<br />\n　　对于一个客户而言，仅当在开会时能够独自占用整个会堂，他才会租借会堂。会议中心的销售主管认为：最好的策略应该是将会堂租借给尽可能多的客户。显然，有可能存在不止一种满足要求的策略。<br />\n　　例如下面的例子。总共有4个公司。他们对租借会堂发出了请求，并提出了他们所需占用会堂的起止日期（如下表所示）。<br />\n<br />\n<table cellspacing=0 cellpadding=2px style='border-collapse:collapse;' class='table table-striped table-horver'><tbody><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'><br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>开始日期<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>结束日期<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>公司1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>4<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>9<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>公司2<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>9<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>11<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>公司3<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>13<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>19<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>公司4<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>10<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>17<br />\n</td></tr></tbody></table><br />\n<br />\n　　上例中，最多将会堂租借给两家公司。租借策略分别是租给公司1和公司3，或是公司2和公司3，也可以是公司1和公司4。注意会议中心一天最多租借给一个公司，所以公司1和公司2不能同时租借会议中心，因为他们在第九天重合了。<br />\n　　销售主管为了公平起见，决定按照如下的程序来确定选择何种租借策略：首先，将租借给客户数量最多的策略作为候选，将所有的公司按照他们发出请求的顺序编号。对于候选策略，将策略中的每家公司的编号按升序排列。最后，选出其中字典序最小[1]的候选策略作为最终的策略。<br />\n　　例中，会堂最终将被租借给公司1和公司3：3个候选策略是{(1,3),(2,3),(1,4)}。而在字典序中(1,3)&lt;(1,4)&lt;(2,3)。<br />\n　　你的任务是帮助销售主管确定应该将会堂租借给哪些公司。<b></b></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行有一个整数<i>N</i>，表示发出租借会堂申请的公司的个数。第2到第<i>N</i>+1行每行有2个整数。第<i>i</i>+1行的整数表示第<i>i</i>家公司申请租借的起始和终止日期。对于每个公司的申请，起始日期为不小于1的整数，终止日期为不大于10<sup>9</sup>的整数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出的第一行应有一个整数<i>M</i>，表示最多可以租借给多少家公司。第二行应列出<i>M</i>个数，表示最终将会堂租借给哪些公司。</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于50%的输入，<i>N</i>≤3000。在所有输入中，<i>N</i>≤200000。</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\n4 9<br />\n9 11<br />\n13 19<br />\n10 17</div><div class='pdsec'>样例输出</div><div class='pddata'>2<br />\n1 3<br />\n<br />\n[1] 字典序指在字典中排列的顺序，如果序列<i>l</i><sub>1</sub>是序列<i>l</i><sub>2</sub>的前缀，或者对于<i>l</i><sub>1</sub>和<i>l</i><sub>2</sub>的第一个不同位置<i>j</i>，<i>l</i><sub>1</sub>[<i>j</i>]&lt;<i>l</i><sub>2</sub>[<i>j</i>]，则<i>l</i><sub>1</sub>比<i>l</i><sub>2</sub>小。</div>\n","gpid":"T105","lanqiaotitle":"会议中心","memorylimit":"512.0MB","tid":"ALGO-40","timelimit":"2.0s","title":"算法训练 会议中心","src":"APIO 2009"},{"checkpoint":"APIO 2009","updatetime":"2014-02-28","content":"<div class='pdcont'>　　采油区域　　Siruseri政府决定将石油资源丰富的Navalur省的土地拍卖给私人承包商以建立油井。被拍卖的整块土地为一个矩形区域，被划分为<i>M</i>×<i>N</i>个小块。<br />\n　　Siruseri地质调查局有关于Navalur土地石油储量的估测数据。这些数据表示为<i>M</i>×<i>N</i>个非负整数，即对每一小块土地石油储量的估计值。<br />\n　　为了避免出现垄断，政府规定每一个承包商只能承包一个由<i>K</i>×<i>K</i>块相连的土地构成的正方形区域。<br />\n　　AoE石油联合公司由三个承包商组成，他们想选择三块互不相交的<i>K</i>×<i>K</i>的区域使得总的收益最大。<br />\n　　例如，假设石油储量的估计值如下：<br />\n<br />\n<table cellspacing=0 cellpadding=2px style='border-collapse:collapse;' class='table table-striped table-horver'><tbody><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>8<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>8<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>8<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>8<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>8<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>8<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>8<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>8<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>8<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>8<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>8<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>8<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>8<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>8<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>8<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>8<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>8<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>8<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>8<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>8<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>8<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>9<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>9<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>9<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>1<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>9<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>9<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>9<br />\n</td></tr></tbody></table><br />\n<br />\n　　如果<i>K</i> = 2, AoE公司可以承包的区域的石油储量总和为100, 如果<i>K</i> = 3, AoE公司可以承包的区域的石油储量总和为208。<br />\n　　AoE公司雇佣你来写一个程序，帮助计算出他们可以承包的区域的石油储量之和的最大值。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入第一行包含三个整数<i>M</i>, <i>N</i>, <i>K</i>，其中<i>M</i>和<i>N</i>是矩形区域的行数和列数，<i>K</i>是每一个承包商承包的正方形的大小（边长的块数）。接下来<i>M</i>行，每行有<i>N</i>个非负整数表示这一行每一小块土地的石油储量的估计值。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出只包含一个整数，表示AoE公司可以承包的区域的石油储量之和的最大值。</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　数据保证<i>K</i>≤<i>M</i>且<i>K</i>≤<i>N</i>并且至少有三个<i>K</i>×<i>K</i>的互不相交的正方形区域。其中30%的输入数据，<i>M</i>, <i>N</i>≤ 12。所有的输入数据, <i>M</i>, <i>N</i>≤ 1500。每一小块土地的石油储量的估计值是非负整数且≤ 500。</div><div class='pdsec'>样例输入</div><div class='pddata'>9 9 3<br />\n1 1 1 1 1 1 1 1 1<br />\n1 1 1 1 1 1 1 1 1<br />\n1 8 8 8 8 8 1 1 1<br />\n1 8 8 8 8 8 1 1 1<br />\n1 8 8 8 8 8 1 1 1<br />\n1 1 1 1 8 8 8 1 1<br />\n1 1 1 1 1 1 8 8 8<br />\n1 1 1 1 1 1 9 9 9<br />\n1 1 1 1 1 1 9 9 9</div><div class='pdsec'>样例输出</div><div class='pddata'>208</div>\n","gpid":"T104","lanqiaotitle":"采油区域","memorylimit":"512.0MB","tid":"ALGO-44","timelimit":"2.0s","title":"算法训练 采油区域","src":"APIO 2009"},{"checkpoint":"试用 C++ 入门","updatetime":"2014-02-28","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输入A,B。<br />\n　　输出A+B。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含两个整数A,B，用一个空格分隔。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个整数，表示A+B的值。</div><div class='pdsec'>样例输入</div><div class='pddata'>5 8</div><div class='pdsec'>样例输出</div><div class='pddata'>13</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　-1,000,000,000&lt;=A,B&lt;=1,000,000,000。</div>\n","gpid":"T103","lanqiaotitle":"A+B Problem","memorylimit":"512.0MB","tid":"ALGO-43","timelimit":"1.0s","title":"算法训练 A+B Problem","src":""},{"checkpoint":"","updatetime":"2014-02-20","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输入10个整数组成的序列，要求对其进行升序排序，并去掉重复元素。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　10个整数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　多行输出，每行一个元素。</div><div class='pdsec'>样例输入</div><div class='pddata'>2 2 3 3 1 1 5 5 5 5</div><div class='pdsec'>样例输出</div><div class='pddata'>1<br />\n2<br />\n3<br />\n5</div>\n","gpid":"T101","lanqiaotitle":"数组排序去重","memorylimit":"512.0MB","tid":"ALGO-39","timelimit":"1.0s","title":"算法训练 数组排序去重","src":""},{"checkpoint":"模拟","updatetime":"2013-11-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　学校里有一个水房，水房里一共装有m 个龙头可供同学们打开水，每个龙头每秒钟的 供水量相等，均为1。 现在有n 名同学准备接水，他们的初始接水顺序已经确定。将这些同学按接水顺序从1 到n 编号，i 号同学的接水量为wi。接水开始时，1 到m 号同学各占一个水龙头，并同时打 开水龙头接水。当其中某名同学j 完成其接水量要求wj 后，下一名排队等候接水的同学k 马上接替j 同学的位置开始接水。这个换人的过程是瞬间完成的，且没有任何水的浪费。即 j 同学第x 秒结束时完成接水，则k 同学第x+1 秒立刻开始接水。若当前接水人数n’不足m， 则只有n’个龙头供水，其它m&minus;n’个龙头关闭。 现在给出n 名同学的接水量，按照上述接水规则，问所有同学都接完水需要多少秒。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第1 行2 个整数n 和m，用一个空格隔开，分别表示接水人数和龙头个数。 第2 行n 个整数w1、w2、……、wn，每两个整数之间用一个空格隔开，wi 表示i 号同 学的接水量。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出只有一行，1 个整数，表示接水所需的总时间。</div><div class='pdsec'>样例输入</div><div class='pddata'>5 3<br />\n4 4 1 2 1</div><div class='pdsec'>样例输出</div><div class='pddata'>4</div><div class='pdsec'>样例输入</div><div class='pddata'>8 4<br />\n23 71 87 32 70 93 80 76</div><div class='pdsec'>样例输出</div><div class='pddata'>163</div><div class='pdsec'>输入输出样例 1 说明</div><div class='pdcont'>　　第1 秒，3 人接水。第1 秒结束时，1、2、3 号同学每人的已接水量为1，3 号同学接完<br />\n　　水，4 号同学接替3 号同学开始接水。<br />\n　　第2 秒，3 人接水。第2 秒结束时，1、2 号同学每人的已接水量为2，4 号同学的已接<br />\n　　水量为1。<br />\n　　第3 秒，3 人接水。第3 秒结束时，1、2 号同学每人的已接水量为3，4 号同学的已接<br />\n　　水量为2。4 号同学接完水，5 号同学接替4 号同学开始接水。<br />\n　　第4 秒，3 人接水。第4 秒结束时，1、2 号同学每人的已接水量为4，5 号同学的已接<br />\n　　水量为1。1、2、5 号同学接完水，即所有人完成接水。<br />\n　　总接水时间为4 秒。</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1 ≤ n ≤ 10000，1 ≤m≤ 100 且m≤ n；<br />\n　　1 ≤ wi ≤ 100。</div>\n","gpid":"T100","lanqiaotitle":"接水问题","memorylimit":"64.0MB","tid":"ALGO-38","timelimit":"1.0s","title":"算法训练 接水问题","src":"NOIP2010 普及组"},{"checkpoint":"数论","updatetime":"2013-11-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Hanks 博士是BT (Bio-Tech，生物技术) 领域的知名专家，他的儿子名叫Hankson。现 在，刚刚放学回家的Hankson 正在思考一个有趣的问题。 今天在课堂上，老师讲解了如何求两个正整数c1 和c2 的最大公约数和最小公倍数。现 在Hankson 认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公 倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数a0,a1,b0,b1，设某未知正整 数x 满足： 1． x 和a0 的最大公约数是a1； 2． x 和b0 的最小公倍数是b1。 Hankson 的“逆问题”就是求出满足条件的正整数x。但稍加思索之后，他发现这样的 x 并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的x 的个数。请你帮 助他编程求解这个问题。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入第一行为一个正整数n，表示有n 组输入数据。<br />\n<br />\n　　接下来的n 行每 行一组输入数据，为四个正整数a0，a1，b0，b1，每两个整数之间用一个空格隔开。输入 数据保证a0 能被a1 整除，b1 能被b0 整除。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出共n 行。每组输入数据的输出结果占一行，为一个整数。<br />\n　　对于每组数据：若不存在这样的 x，请输出0； 若存在这样的 x，请输出满足条件的x 的个数；</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n41 1 96 288<br />\n95 1 37 1776</div><div class='pdsec'>样例输出</div><div class='pddata'>6<br />\n2</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　第一组输入数据，x 可以是9、18、36、72、144、288，共有6 个。<br />\n　　第二组输入数据，x 可以是48、1776，共有2 个。</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于 50%的数据，保证有1≤a0，a1，b0，b1≤10000 且n≤100。<br />\n　　对于 100%的数据，保证有1≤a0，a1，b0，b1≤2,000,000,000 且n≤2000。</div>\n","gpid":"T99","lanqiaotitle":"Hankson的趣味题","memorylimit":"64.0MB","tid":"ALGO-37","timelimit":"1.0s","title":"算法训练 Hankson的趣味题","src":"NOIP2009 提高组"},{"checkpoint":"动态规划","updatetime":"2013-11-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排做成一个m行n列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标(1,1)，小轩坐在矩阵的右下角，坐标(m,n)。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。<br />\n　　在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。<br />\n　　还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用0表示），可以用一个0-100的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度只和最大。现在，请你帮助小渊和小轩找到这样的两条路径。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入第一行有2个用空格隔开的整数m和n，表示班里有m行n列（1&lt;=m,n&lt;=50）。<br />\n　　接下来的m行是一个m*n的矩阵，矩阵中第i行j列的整数表示坐在第i行j列的学生的好心程度。每行的n个整数之间用空格隔开。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行，包含一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 3<br />\n0 3 9<br />\n2 8 5<br />\n5 7 0</div><div class='pdsec'>样例输出</div><div class='pddata'>34</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　30%的数据满足：1&lt;=<i>m</i>,<i>n</i>&lt;=10<br />\n　　100%的数据满足：1&lt;=<i>m</i>,<i>n</i>&lt;=50</div>\n","gpid":"T98","lanqiaotitle":"传纸条","memorylimit":"512.0MB","tid":"ALGO-36","timelimit":"1.0s","title":"算法训练 传纸条","src":"NOIP2008 提高组"},{"checkpoint":"动态规划","updatetime":"2013-11-08","content":"<div class='pdcont'>　　<b>【</b>问题描述】<br />\n　　上体育课的时候，小蛮的老师经常带着同学们一起做游戏。这次，老师带着同学们一起做传球游戏。<br />\n　　游戏规则是这样的：n个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时，拿着球没传出去的那个同学就是败者，要给大家表演一个节目。<br />\n　　聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了m次以后，又回到小蛮手里。两种传球的方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有3个同学1号、2号、3号，并假设小蛮为1号，球传了3次回到小蛮手里的方式有1-&gt;2-&gt;3-&gt;1和1-&gt;3-&gt;2-&gt;1，共2种。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　共一行，有两个用空格隔开的整数n，m（3&lt;=n&lt;=30，1&lt;=m&lt;=30）。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　t共一行，有一个整数，表示符合题意的方法数。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 3</div><div class='pdsec'>样例输出</div><div class='pddata'>2</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　40%的数据满足：3&lt;=n&lt;=30，1&lt;=m&lt;=20<br />\n　　100%的数据满足：3&lt;=n&lt;=30，1&lt;=m&lt;=30</div>\n","gpid":"T97","lanqiaotitle":"传球游戏","memorylimit":"256.0MB","tid":"ALGO-35","timelimit":"1.0s","title":"算法训练 传球游戏","src":"NOIP2008 普及组"},{"checkpoint":"贪心 排序","updatetime":"2013-11-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　元旦快到了，校学生会让乐乐负责新年晚会的纪念品发放工作。为使得参加晚会的同学所获得的纪念品价值 相对均衡，他要把购来的纪念品根据价格进行分组，但每组最多只能包括两件纪念品，并且每组纪念品的价格之和不能超过一个给定的整数。为了保证在尽量短的时 间内发完所有纪念品，乐乐希望分组的数目最少。<br />\n　　你的任务是写一个程序，找出所有分组方案中分组数最少的一种，输出最少的分组数目。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含<i>n</i>+2行：<br />\n　　第1行包括一个整数<i>w</i>，为每组纪念品价格之和的上限。<br />\n　　第2行为一个整数<i>n</i>，表示购来的纪念品的总件数。<br />\n　　第3~<i>n</i>+2行每行包含一个正整数<i>p<sub>i</sub></i> (5  &lt;= <i>p<sub>i</sub></i> &lt;= <i>w</i>)，表示所对应纪念品的价格。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出仅一行，包含一个整数，即最少的分组数目。</div><div class='pdsec'>样例输入</div><div class='pddata'>100<br />\n9<br />\n90<br />\n20<br />\n20<br />\n30<br />\n50<br />\n60<br />\n70<br />\n80<br />\n90</div><div class='pdsec'>样例输出</div><div class='pddata'>6</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　50%的数据满足：1 &lt;= <i>n</i> &lt;= 15<br />\n　　100%的数据满足：1 &lt;= <i>n</i> &lt;= 30000, 80 &lt;= <i>w</i> &lt;= 200</div>\n","gpid":"T96","lanqiaotitle":"纪念品分组","memorylimit":"256.0MB","tid":"ALGO-34","timelimit":"1.0s","title":"算法训练 纪念品分组","src":"NOIP2007 普及组"},{"checkpoint":"数学 进制","updatetime":"2013-11-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个正整数k(3≤k≤15),把所有k的方幂及所有有限个互不相等的k的方幂之和构成一个递增的序列，例如，当k=3时，这个序列是：<br />\n　　1，3，4，9，10，12，13，…<br />\n　　（该序列实际上就是：3<sup>0</sup>，3<sup>1</sup>，3<sup>0</sup>+3<sup>1</sup>，3<sup>2</sup>，3<sup>0</sup>+3<sup>2</sup>，3<sup>1</sup>+3<sup>2</sup>，3<sup>0</sup>+3<sup>1</sup>+3<sup>2</sup>，…）<br />\n　　请你求出这个序列的第N项的值（用10进制数表示）。<br />\n　　例如，对于k=3，N=100，正确答案应该是981。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　只有1行，为2个正整数，用一个空格隔开：<br />\n　　k N<br />\n　　（k、N的含义与上述的问题描述一致，且3≤k≤15，10≤N≤1000）。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　计算结果，是一个正整数（在所有的测试数据中，结果均不超过2.1*10<sup>9</sup>）。（整数前不要有空格和其他符号）。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 100</div><div class='pdsec'>样例输出</div><div class='pddata'>981</div>\n","gpid":"T95","lanqiaotitle":"数列","memorylimit":"256.0MB","tid":"ALGO-33","timelimit":"1.0s","title":"算法训练 数列","src":"NOIP2006 普及组"},{"checkpoint":"组合生成","updatetime":"2013-11-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Jam是个喜欢标新立异的科学怪人。他不使用阿拉伯数字计数，而是使用<b>小写英文字母</b>计数，他觉得这样做，会使世界更加丰富多彩。在他的计数法中，每个数字的位数都是相同的（使用相同个数的字母），英文字母按原先的顺序，排在前面的字母小于排在它后面的字母。我们把这样的“数字”称为Jam数字。在Jam数字中，每个字母互不相同，而且<b>从左到右是严格递增</b>的。每次，Jam还指定使用字母的<b>范围</b>，例如，从2到10，表示只能使用{b,c,d,e,f,g,h,i,j}这些字母。如果再规定位数为5，那么，紧接在Jam数字“bdfij”之后的数字应该是“bdghi”。（如果我们用U、V依次表示Jam数字“bdfij”与“bdghi”，则U&lt;V&lt;  span&gt;，且不存在Jam数字P，使U&lt;P&lt;V&lt;  span&gt;）。你的任务是：对于从文件读入的一个Jam数字，按顺序输出紧接在后面的5个Jam数字，如果后面没有那么多Jam数字，那么有几个就输出几个。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　有2行，第1行为3个正整数，用一个空格隔开：<br />\n　　s t w<br />\n　　（其中s为所使用的最小的字母的序号，t为所使用的最大的字母的序号。w为数字的位数，这3个数满足：1≤s&lt;T≤26,  2≤w≤t-s ）<br />\n　　第2行为具有w个小写字母的字符串，为一个符合要求的Jam数字。<br />\n　　所给的数据都是正确的，不必验证。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　最多为5行，为紧接在输入的Jam数字后面的5个Jam数字，如果后面没有那么多Jam数字，那么有几个就输出几个。每行只输出一个Jam数字，是由w个小写字母组成的字符串，不要有多余的空格。</div><div class='pdsec'>样例输入</div><div class='pddata'>2 10 5<br />\nbdfij</div><div class='pdsec'>样例输出</div><div class='pddata'>bdghi<br />\nbdghj<br />\nbdgij<br />\nbdhij<br />\nbefgh</div>\n","gpid":"T94","lanqiaotitle":"JAM计数法","memorylimit":"256.0MB","tid":"ALGO-32","timelimit":"1.0s","title":"算法训练 JAM计数法","src":"NOIP2006 普及组"},{"checkpoint":"01背包 动态规划","updatetime":"2013-11-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎 么布置，你说了算，只要不超过N元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一 个重要度，分为5等：用整数1~5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过N元（可以等于N元）的前提 下，使每件物品的价格与重要度的乘积的总和最大。<br />\n　　设第j件物品的价格为v[j]，重要度为w[j]，共选中了k件物品，编号依次为 j1，j2，……，jk，则所求的总和为：<br />\n　　v[j1]*w[j1]+v[j2]*w[j2]+ …+v[jk]*w[jk]。（其中*为乘号）<br />\n　　请 你帮助金明设计一个满足要求的购物单。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入文件 的第1行，为两个正整数，用一个空格隔开：<br />\n　　N m<br />\n　　（其中N（&lt;30000）表示总钱 数，m（&lt;25）为希望购买物品的个数。）<br />\n　　从第2行到第m+1行，第j行给出了编号为j-1的物品的基本数据，每行有2个非负整数<br />\n　　v  p<br />\n　　（其中v表示该物品的价格(v&lt;=10000)，p表示该物品的重要度(1~5)）</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出文件只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（&lt;100000000）。</div><div class='pdsec'>样例输入</div><div class='pddata'>1000 5<br />\n800 2<br />\n400 5<br />\n300 5<br />\n400 3<br />\n200 2</div><div class='pdsec'>样例输出</div><div class='pddata'>3900</div><div class='pdsec'>数据规模和约定</div>\n","gpid":"T93","lanqiaotitle":"开心的金明","memorylimit":"256.0MB","tid":"ALGO-31","timelimit":"1.0s","title":"算法训练 开心的金明","src":"NOIP2006 普及组"},{"checkpoint":"0/1背包 动态规划","updatetime":"2013-11-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”<br />\n　　如果你是辰辰，你能完成这个任务吗？</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行有两个整数T（1  &lt;= T &lt;= 1000）和M（1  &lt;= M &lt;= 100），用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到100之间（包括1和100）的整数，分别表示采摘某株草药的时间和这株草药的价值。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。</div><div class='pdsec'>样例输入</div><div class='pddata'>70 3<br />\n71 100<br />\n69 1<br />\n1 2</div><div class='pdsec'>样例输出</div><div class='pddata'>3</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于30%的数据，M  &lt;= 10；<br />\n　　对于全部的数据，M  &lt;= 100。</div>\n","gpid":"T92","lanqiaotitle":"入学考试","memorylimit":"256.0MB","tid":"ALGO-30","timelimit":"1.0s","title":"算法训练 入学考试","src":"NOIP2005 普及组"},{"checkpoint":"区间处理","updatetime":"2013-11-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　某校大门外长度为L的马路上有一排树，每两棵相邻的树之间的间隔都是1米。我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；数 轴上的每个整数点，即0，1，2，……，L，都种有一棵树。<br />\n　　由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已 知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树 都移走后，马路上还有多少棵树。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入文件的第一行有两个整数L（1 &lt;= L &lt;= 10000）和 M（1 &lt;= M &lt;=  100），L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。接下来的M行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点 和终止点的坐标。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出文件包括一行，这一行只包含一个整数，表示马路上剩余的树的数目。</div><div class='pdsec'>样例输入</div><div class='pddata'>500 3<br />\n150 300<br />\n100 200<br />\n470 471</div><div class='pdsec'>样例输出</div><div class='pddata'>298</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于20%的数据，区域之间没有重合的部分；<br />\n　　对于其它的数据，区域之间有重合的情况。</div>\n","gpid":"T91","lanqiaotitle":"校门外的树","memorylimit":"256.0MB","tid":"ALGO-29","timelimit":"1.0s","title":"算法训练 校门外的树","src":"NOIP2005 普及组"},{"checkpoint":"排列生成算法","updatetime":"2013-11-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　人类终于登上了火星的土地并且见到了神秘的火星人。人类和火星人都无法理解对方的语言，但是我们的科学家发明了一种用数字交流的方法。这种交流方法是这样 的，首先，火星人把一个非常大的数字告诉人类科学家，科学家破解这个数字的含义后，再把一个很小的数字加到这个大数上面，把结果告诉火星人，作为人类的回 答。<br />\n　　火星人用一种非常简单的方式来表示数字——掰手指。火星人只有一只手，但这只手上有成千上万的手指，这些手指排成一列，分别编号为1，2，3……。火星人的任意两根手指都能随意交换位置，他们就是通过这方法计数的。<br />\n　　一个火星人用一个人类的手演示了如何用手指计数。如果把五根手指——拇指、食指、中指、无名指和小指分别编号为1，2，3，4和5，当它们按正常顺序排列 时，形成了5位数12345，当你交换无名指和小指的位置时，会形成5位数12354，当你把五个手指的顺序完全颠倒时，会形成54321，在所有能够形 成的120个5位数中，12345最小，它表示1；12354第二小，它表示2；54321最大，它表示120。下表展示了只有3根手指时能够形成的6个 3位数和它们代表的数字：<br />\n　　三进制数<br />\n　　123<br />\n　　132<br />\n　　213<br />\n　　231<br />\n　　312<br />\n　　321<br />\n　　代表的数字<br />\n　　1<br />\n　　2<br />\n　　3<br />\n　　4<br />\n　　5<br />\n　　6<br />\n　　现在你有幸成为了第一个和火星人交流的地球人。一个火星人会让你看他的手指，科学家会告诉你要加上去的很小的数。你的任务是，把火星人用手指表示的数与科 学家告诉你的数相加，并根据相加的结果改变火星人手指的排列顺序。输入数据保证这个结果不会超出火星人手指能表示的范围。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　包括三行，第一行有一个正整数N，表示火星人手指的数目（1 &lt;= N &lt;=  10000）。第二行是一个正整数M，表示要加上去的小整数（1 &lt;= M &lt;=  100）。下一行是1到N这N个整数的一个排列，用空格隔开，表示火星人手指的排列顺序。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　只有一行，这一行含有N个整数，表示改变后的火星人手指的排列顺序。每两个相邻的数中间用一个空格分开，不能有多余的空格。</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n3<br />\n1 2 3 4 5</div><div class='pdsec'>样例输出</div><div class='pddata'>1 2 4 5 3</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于30%的数据，N&lt;=15；<br />\n　　对于60%的数据，N&lt;=50；<br />\n　　对于全部的数据，N&lt;=10000；</div>\n","gpid":"T90","lanqiaotitle":"星际交流","memorylimit":"256.0MB","tid":"ALGO-28","timelimit":"1.0s","title":"算法训练 星际交流","src":"NOIP2004 普及组"},{"checkpoint":"树 遍历","updatetime":"2013-11-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　我们可以把由“0”和“1”组成的字符串分为三类：全“0”串称为B串，全“1”串称为I串，既含“0”又含“1”的串则称为F串。<br />\n　　FBI树是一种二叉树，它的结点类型也包括F结点，B结点和I结点三种。由一个长度为2<sup>N</sup>的“01”串S可以构造出一棵FBI树T，递归的构造方法如下：<br />\n　　1)T的根结点为R，其类型与串S的类型相同；<br />\n　　2)若串S的长度大于1，将串S从中间分开，分为等长的左右子串S1和S2；由左子串S1构造R的左子树T1，由右子串S2构造R的右子树T2。<br />\n　　现在给定一个长度为2<sup>N</sup>的“01”串，请用上述构造方法构造出一棵FBI树，并输出它的后序遍历序列。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行是一个整数N（0  &lt;= N &lt;= 10），第二行是一个长度为2<sup>N</sup>的“01”串。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　包括一行，这一行只包含一个字符串，即FBI树的后序遍历序列。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n10001011</div><div class='pdsec'>样例输出</div><div class='pddata'>IBFBBBFIBFIIIFF</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于40%的数据，N  &lt;= 2；<br />\n　　对于全部的数据，N  &lt;= 10。<br />\n　　注：<br />\n　　[1]   二叉树：二叉树是结点的有限集合，这个集合或为空集，或由一个根结点和两棵不相交的二叉树组成。这两棵不相交的二叉树分别称为这个根结点的左子树和右子树。<br />\n　　[2]   后序遍历：后序遍历是深度优先遍历二叉树的一种方法，它的递归定义是：先后序遍历左子树，再后序遍历右子树，最后访问根。</div>\n","gpid":"T89","lanqiaotitle":"FBI树","memorylimit":"256.0MB","tid":"ALGO-27","timelimit":"1.0s","title":"算法训练 FBI树","src":"NOIP2004 普及组"},{"checkpoint":"二分 高精度","updatetime":"2013-11-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　形如2<i><sup>P</sup></i>-1的素数称为麦森数，这时P一定也是个素数。但反过来不一定，即如果P是个素数，2<i><sup>P</sup></i>-1不一定也是素数。到1998年底，人们已找到了37个麦森数。最大的一个是P=3021377，它有909526位。麦森数有许多重要应用，它与完全数密切相关。<br />\n　　任务：从文件中输入P（1000&lt;P&lt;3100000），计算2<i><sup>P</sup></i>-1的位数和最后500位数字（用十进制高精度数表示）</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　文件中只包含一个整数P（1000&lt;P&lt;3100000）</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第一行：十进制高精度数2<i><sup>P</sup></i>-1的位数。<br />\n　　第2-11行：十进制高精度数2<i><sup>P</sup></i>-1的最后500位数字。（每行输出50位，共输出10行，不足500位时高位补0）<br />\n　　不必验证2<i><sup>P</sup></i>-1与P是否为素数。</div><div class='pdsec'>样例输入</div><div class='pddata'>1279</div><div class='pdsec'>样例输出</div><div class='pddata'>386<br />\n00000000000000000000000000000000000000000000000000<br />\n00000000000000000000000000000000000000000000000000<br />\n00000000000000104079321946643990819252403273640855<br />\n38615262247266704805319112350403608059673360298012<br />\n23944173232418484242161395428100779138356624832346<br />\n49081399066056773207629241295093892203457731833496<br />\n61583550472959420547689811211693677147548478866962<br />\n50138443826029173234888531116082853841658502825560<br />\n46662248318909188018470682222031405210266984354887<br />\n32958028878050869736186900714720710555703168729087</div>\n","gpid":"T88","lanqiaotitle":"麦森数","memorylimit":"256.0MB","tid":"ALGO-26","timelimit":"1.0s","title":"算法训练 麦森数","src":"NOIP2003 普及组"},{"checkpoint":"最短路","updatetime":"2013-11-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　又到暑假了，住在城市A的Car想和朋友一起去城市B旅游。她知道每个城市都有四个飞机场，分别位于一个矩形的四个顶点上，同一个城市中两个机场之间有一 条笔直的高速铁路，第I个城市中高速铁路了的单位里程价格为Ti，任意两个不同城市的机场之间均有航线，所有航线单位里程的价格均为t。<br />\n　　那么Car应如何安排到城市B的路线才能尽可能的节省花费呢?她发现这并不是一个简单的问题，于是她来向你请教。<br />\n　　找出一条从城市A到B的旅游路线，出发和到达城市中的机场可以任意选取，要求总的花费最少。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　的第一行有四个正整数s，t，A，B。<br />\n　　S表示城市的个数，t表示飞机单位里程的价格，A，B分别为城市A，B的序号，(1&lt;=A，B&lt;=S)。<br />\n　　接下来有S行，其中第I行均有7个正整数xi1，yi1，xi2，yi2，xi3，yi3，Ti，这当中的(xi1，yi1)，(xi2，yi2)，(xi3，yi3)分别是第I个城市中任意三个机场的坐标，T        I为第I个城市高速铁路单位里程的价格。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　共有n行，每行一个数据对应测试数据，保留一位小数。</div><div class='pdsec'>样例输入</div><div class='pddata'>1<br />\n1 10 1 3<br />\n1 1 1 3 3 1 30<br />\n2 5 7 4 5 2        1<br />\n8 6 8 8 11 6 3</div><div class='pdsec'>样例输出</div><div class='pddata'>47.55</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　0&lt;S&lt;=100，</div>\n","gpid":"T87","lanqiaotitle":"Car的旅行路线","memorylimit":"256.0MB","tid":"ALGO-25","timelimit":"1.0s","title":"算法训练 Car的旅行路线","src":"NOIP2001 提高组"},{"checkpoint":"字符串","updatetime":"2013-11-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给出一个长度不超过200的由小写英文字母组成的字母串(约定;该字串以每行20个字母的方式输入，且保证每行一定为20个)。要求将此字母串分成k份 (1&lt;k&lt;=40)，且每份中包含的单词个数加起来总数最大(每份中包含的单词可以部分重叠。当选用一个单词之后，其第一个字母不能再用。例 如字符串this中可包含this和is，选用this之后就不能包含th)。<br />\n　　单词在给出的一个不超过6个单词的字典中。<br />\n　　要求输出最大的个数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行有二个正整数(p，k)<br />\n　　p表示字串的行数;<br />\n　　k表示分为k个部分。<br />\n　　接下来的p行，每行均有20个字符。<br />\n　　再接下来有一个正整数s，表示字典中单词个数。(1&lt;=s&lt;=6)<br />\n　　接下来的s行，每行均有一个单词。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　每行一个整数，分别对应每组测试数据的相应结果。</div><div class='pdsec'>样例输入</div><div class='pddata'>1        3<br />\nthisisabookyouareaoh<br />\n4<br />\nis<br />\na<br />\nok<br />\nsab</div><div class='pdsec'>样例输出</div><div class='pddata'>7</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　长度不超过200，1&lt;k&lt;=40，字典中的单词数不超过6。</div>\n","gpid":"T86","lanqiaotitle":"统计单词个数","memorylimit":"256.0MB","tid":"ALGO-24","timelimit":"1.0s","title":"算法训练 统计单词个数","src":"NOIP2001 提高组"},{"checkpoint":"解方程","updatetime":"2013-11-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有形如：ax<sup>3</sup>+bx<sup>2</sup>+cx+d=0  这样的一个一元三次方程。给出该方程中各项的系数(a，b，c，d  均为实数)，并约定该方程存在三个不同实根(根的范围在-100至100之间)，且根与根之差的绝对值&gt;=1。要求三个实根。。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　四个实数：a，b，c，d</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后2位</div><div class='pdsec'>样例输入</div><div class='pddata'>1   -5   -4   20</div><div class='pdsec'>样例输出</div><div class='pddata'>-2.00          2.00   5.00</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　|a|，|b|，|c|，|d|&lt;=10</div>\n","gpid":"T85","lanqiaotitle":"一元三次方程求解","memorylimit":"256.0MB","tid":"ALGO-23","timelimit":"1.0s","title":"算法训练 一元三次方程求解","src":"NOIP2001 提高组"},{"checkpoint":"动态规划","updatetime":"2013-11-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　将整数n分成k份，且每份不能为空，任意两份不能相同(不考虑顺序)。<br />\n　　例如：n=7，k=3，下面三种分法被认为是相同的。<br />\n　　1，1，5;        1，5，1; 5，1，1;<br />\n　　问有多少种不同的分法。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　n，k</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个整数，即不同的分法</div><div class='pdsec'>样例输入</div><div class='pddata'>7 3</div><div class='pdsec'>样例输出</div><div class='pddata'>4      {四种分法为：1，1，5;1，2，4;1，3，3;2，2，3;}</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　6&lt;n&lt;=200，2&lt;=k&lt;=6</div>\n","gpid":"T84","lanqiaotitle":"数的划分","memorylimit":"256.0MB","tid":"ALGO-22","timelimit":"1.0s","title":"算法训练 数的划分","src":"NOIP2001 提高组"},{"checkpoint":"动态规划","updatetime":"2013-11-07","content":"<div class='pdcont'><b>问题描述</b><br />\n　　有一个箱子容量为V（正整数，0＜＝V＜＝20000），同时有n个物品（0＜n＜＝30），每个物品有一个体积（正整数）。<br />\n　　要求n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行为一个整数，表示箱子容量；<br />\n　　第二行为一个整数，表示有n个物品；<br />\n　　接下来n行，每行一个整数表示这n个物品的各自体积。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个整数，表示箱子剩余空间。<br />\n　　<b>样例</b>输入<br />\n　　24<br />\n　　6<br />\n　　8<br />\n　　3<br />\n　　12<br />\n　　7<br />\n　　9<br />\n　　7</div><div class='pdsec'>样例输出</div><div class='pddata'>0</div>\n","gpid":"T83","lanqiaotitle":"装箱问题","memorylimit":"256.0MB","tid":"ALGO-21","timelimit":"1.0s","title":"算法训练 装箱问题","src":"NOIP2001 普及组"},{"checkpoint":"递归","updatetime":"2013-11-07","content":"<div class='pdcont'><b>问题描述</b><br />\n　　给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，长度&lt;=8）。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　两行，每行一个字符串，分别表示中序和后序排列</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个字符串，表示所求先序排列<br />\n<br />\n　　<b>样例</b>输入<br />\n　　BADC<br />\n　　BDCA</div><div class='pdsec'>样例输出</div><div class='pddata'>ABCD</div>\n","gpid":"T82","lanqiaotitle":"求先序排列","memorylimit":"256.0MB","tid":"ALGO-20","timelimit":"1.0s","title":"算法训练 求先序排列","src":"NOIP2001 普及组"},{"checkpoint":"动态规划","updatetime":"2013-11-07","content":"<div class='pdcont'><b>问题描述</b><b>   </b><br />\n　　设有N*N的方格图(N&lt;=10),我们将其中的某些方格中填入正整数,而其他的方格中则放入数字0。<br />\n　　某人从图的左上角的A 点(1,1)出发，可以向下行走，也可以向右走，直到到达右下角的B点(N,N)。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。<br />\n　　此人从A点到B 点共走两次，试找出2条这样的路径，使得取得的数之和为最大。<br />\n<b>输</b><b>入格式</b><br />\n　　输入的第一行为一个整数N（表示N*N的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的0表示输入结束。<br />\n<b>输</b><b>出格式</b><br />\n　　只需输出一个整数，表示2条路径上取得的最大的和。<br />\n<b>样</b><b>例</b><b>输</b><b>入</b><br />\n　　8<br />\n　　2 3 13<br />\n　　2 6 6<br />\n　　3 5 7<br />\n　　4 4 14<br />\n　　5 2 21<br />\n　　5 6 4<br />\n　　6 3 15<br />\n　　7 2 14<br />\n　　0 0 0<br />\n<b>样例输出</b><br />\n　　67</div>\n","gpid":"T79","lanqiaotitle":"方格取数","memorylimit":"256.0MB","tid":"ALGO-19","timelimit":"1.0s","title":"算法训练 方格取数","src":"NOIP2000 提高组"},{"checkpoint":"搜索","updatetime":"2013-11-07","content":"<div class='pdcont'><b>问题描述</b><b>   </b><br />\n<br />\n　　单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 beast和astonish，如果接成一条龙则变为beastonish，另外相邻的两部分不能存在包含关系，例如at 和 atide 间不能相连。<br />\n<br />\n<b>输</b><b>入格式</b><b>  </b><br />\n<br />\n　　输入的第一行为一个单独的整数n (n&lt;=20)表示单词数，以下n 行每行有一个单词，输入的最后一行为一个单个字符，表示“龙”开头的字母。你可以假定以此字母开头的“龙”一定存在.<br />\n<br />\n<b>输</b><b>出格式</b><b>  </b><br />\n<br />\n　　只需输出以此字母开头的最长的“龙”的长度<br />\n<br />\n<b>样</b><b>例输入</b><br />\n　　5<br />\n　　at<br />\n　　touch<br />\n　　cheat<br />\n　　choose<br />\n　　tact<br />\n　　a</div><div class='pdsec'>样例输出</div><div class='pddata'>23</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　连成的“龙”为atoucheatactactouchoose</div>\n","gpid":"T78","lanqiaotitle":"单词接龙","memorylimit":"256.0MB","tid":"ALGO-18","timelimit":"1.0s","title":"算法训练 单词接龙","src":"NOIP2000 提高组"},{"checkpoint":"动态规划","updatetime":"2013-11-07","content":"<div class='pdcont'><b>问题描述</b><b>   </b><br />\n<br />\n　　今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰90周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友XZ也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：<br />\n<br />\n　　设有一个长度为N的数字串，要求选手使用K个乘号将它分成K+1个部分，找出一种分法，使得这K+1个部分的乘积能够为最大。<br />\n<br />\n　　同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：<br />\n<br />\n　　有一个数字串：312， 当N=3，K=1时会有以下两种分法：<br />\n<br />\n　　3*12=36<br />\n　　31*2=62<br />\n<br />\n　　这时，符合题目要求的结果是：31*2=62<br />\n<br />\n　　现在，请你帮助你的好朋友XZ设计一个程序，求得正确的答案。<br />\n<br />\n<b>输</b><b>入格式</b><b>   </b><br />\n<br />\n　　程序的输入共有两行：<br />\n　　第一行共有2个自然数N，K（6≤N≤40，1≤K≤6）<br />\n　　第二行是一个长度为N的数字串。<br />\n<br />\n<br />\n<b>输</b><b>出格式</b><b>   </b><br />\n<br />\n　　输出所求得的最大乘积（一个自然数）。<br />\n<br />\n　　<b>样</b><b>例</b>输入<br />\n<br />\n　　4  2<br />\n　　1231</div><div class='pdsec'>样例输出</div><div class='pddata'>62</div>\n","gpid":"T77","lanqiaotitle":"乘积最大","memorylimit":"256.0MB","tid":"ALGO-17","timelimit":"1.0s","title":"算法训练 乘积最大","src":"NOIP2000 提高组"},{"checkpoint":"进制转换","updatetime":"2013-11-07","content":"<div class='pdcont'><b>问题描述</b><b>   </b><br />\n<br />\n　　我们可以用这样的方式来表示一个十进制数： 将每个阿拉伯数字乘以一个以该数字所处位置的（值减１）为指数，以１０为底数的幂之和的形式。例如：１２３可表示为 １＊１０<sup>２</sup>＋２＊１０<sup>１</sup>＋３＊１０<sup>０</sup>这样的形式。<br />\n　　与之相似的，对二进制数来说，也可表示成每个二进制数码乘以一个以该数字所处位置的（值－１）为指数，以２为底数的幂之和的形式。一般说来，任何一个正整数Ｒ或一个负整数－Ｒ都可以被选来作为一个数制系统的基数。如果是以Ｒ或－Ｒ为基数，则需要用到的数码为 ０，１，．．．．Ｒ－１。例如，当Ｒ＝７时，所需用到的数码是０，１，２，３，４，５和６，这与其是Ｒ或－Ｒ无关。如果作为基数的数绝对值超过１０，则为了表示这些数码，通常使用英文字母来表示那些大于９的数码。例如对１６进制数来说，用Ａ表示１０，用Ｂ表示１１，用Ｃ表示１２，用Ｄ表示１３，用Ｅ表示１４，用Ｆ表示１５。<br />\n　　在负进制数中是用－Ｒ 作为基数，例如－１５（十进制）相当于１１０００１（－２进制），并且它可以被表示为２的幂级数的和数：<br />\n　　１１０００１＝１＊（－２）<sup>５</sup>＋１＊（－２）<sup>４</sup>＋０＊（－２）<sup>３</sup>＋０＊（－２）<sup>２</sup>＋<br />\n　　０＊（－２）<sup>１</sup> ＋１＊（－２）<sup>０</sup><br />\n　　<sup>  </sup>  设计一个程序，读入一个十进制数和一个负进制数的基数, 并将此十进制数转换为此负进制下的数：     －Ｒ∈｛－２，－３，－４，．．．，－２０｝<br />\n<br />\n<b>输</b><b>入格式</b><b>   </b><br />\n　　一行两个数，第一个是十进制数Ｎ（－32768＜＝Ｎ＜＝32767），  第二个是负进制数的基数－Ｒ。<br />\n<br />\n<b>输</b>出格式<b>   </b><br />\n　　输出所求负进制数及其基数，若此基数超过１０，则参照１６进制的方式处理。（格式参照样例）<br />\n<br />\n　　<b>样</b><b>例</b>输入1<br />\n　　30000 -2</div><div class='pdsec'>样例输出</div><div class='pddata'>30000=11011010101110000(base-2)</div><div class='pdsec'>样例输入</div><div class='pddata'>-20000 -2</div><div class='pdsec'>样例输出</div><div class='pddata'>-20000=1111011000100000(base-2)</div><div class='pdsec'>样例输入</div><div class='pddata'>28800 -16</div><div class='pdsec'>样例输出</div><div class='pddata'>28800=19180(base-16)</div><div class='pdsec'>样例输入</div><div class='pddata'>-25000 -16</div><div class='pdsec'>样例输出</div><div class='pddata'>-25000=7FB8(base-16)</div>\n","gpid":"T76","lanqiaotitle":"进制转换","memorylimit":"256.0MB","tid":"ALGO-16","timelimit":"1.0s","title":"算法训练 进制转换","src":"NOIP2000 提高组"},{"checkpoint":"贪心","updatetime":"2013-11-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　一个旅行家想驾驶汽车以最少的费用从一个城市到另一个城市（假设出发时油箱是空的）。给定两个城市之间的距离D1、汽车油箱的容量C（以升为单位）、每升汽油能行驶的距离D2、出发点每升汽油价格P和沿途油站数N（N可以为零），油站i离出发点的距离Di、每升汽油价格Pi（i=1，2，……N）。计算结果四舍五入至小数点后两位。如果无法到达目的地，则输出“No Solution”。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行为4个实数D1、C、D2、P与一个非负整数N；<br />\n　　接下来N行，每行两个实数Di、Pi。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　如果可以到达目的地，输出一个实数（四舍五入至小数点后两位），表示最小费用；否则输出“No Solution”（不含引号）。</div><div class='pdsec'>样例输入</div><div class='pddata'>275.6 11.9 27.4 2.8 2<br />\n102.0 2.9<br />\n220.0 2.2</div><div class='pdsec'>样例输出</div><div class='pddata'>26.95</div>\n","gpid":"T75","lanqiaotitle":"旅行家的预算","memorylimit":"256.0MB","tid":"ALGO-15","timelimit":"1.0s","title":"算法训练 旅行家的预算","src":"NOIP1999 提高组"},{"checkpoint":"模拟 高精度计算","updatetime":"2013-11-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　若一个数（首位不为零）从左向右读与从右向左读都一样，我们就将其称之为回文数。<br />\n　　例如：给定一个10进制数56，将56加65（即把56从右向左读），得到121是一个回文数。<br />\n<br />\n　　又如：对于10进制数87：<br />\n　　STEP1：87+78  = 165                  STEP2：165+561 = 726<br />\n　　STEP3：726+627 = 1353                STEP4：1353+3531 = 4884<br />\n<br />\n　　在这里的一步是指进行了一次N进制的加法，上例最少用了4步得到回文数4884。<br />\n<br />\n　　写一个程序，给定一个N（2&lt;=N&lt;=10或N=16）进制数M（其中16进制数字为0-9与A-F），求最少经过几步可以得到回文数。<br />\n　　如果在30步以内（包含30步）不可能得到回文数，则输出“Impossible!”</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　两行，N与M</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　如果能在30步以内得到回文数，输出“STEP=xx”（不含引号），其中xx是步数；否则输出一行”Impossible!”（不含引号）</div><div class='pdsec'>样例输入</div><div class='pddata'>9<br />\n87</div><div class='pdsec'>样例输出</div><div class='pddata'>STEP=6</div>\n","gpid":"T74","lanqiaotitle":"回文数","memorylimit":"256.0MB","tid":"ALGO-14","timelimit":"1.0s","title":"算法训练 回文数","src":"NOIP1999 提高组"},{"checkpoint":"贪心 动态规划","updatetime":"2013-11-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。<br />\n<br />\n　　输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一行，为导弹依次飞来的高度</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　两行，分别是最多能拦截的导弹数与要拦截所有导弹最少要配备的系统数</div><div class='pdsec'>样例输入</div><div class='pddata'>389 207 155 300 299 170 158 65</div><div class='pdsec'>样例输出</div><div class='pddata'>6<br />\n2</div>\n","gpid":"T73","lanqiaotitle":"拦截导弹","memorylimit":"256.0MB","tid":"ALGO-13","timelimit":"1.0s","title":"算法训练 拦截导弹","src":"NOIP1999 提高组"},{"checkpoint":"递归","updatetime":"2013-11-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　任何一个正整数都可以用2的幂次方表示。例如：<br />\n　　137=2<sup>7</sup>+2<sup>3</sup>+2<sup>0         </sup><br />\n　　同时约定方次用括号来表示，即a<sup>b</sup> 可表示为a（b）。<br />\n　　由此可知，137可表示为：<br />\n　　2（7）+2（3）+2（0）<br />\n　　进一步：7= 2<sup>2</sup>+2+2<sup>0   </sup>（2<sup>1</sup>用2表示）<br />\n　　3=2+2<sup>0   </sup><br />\n　　所以最后137可表示为：<br />\n　　2（2（2）+2+2（0））+2（2+2（0））+2（0）<br />\n　　又如：<br />\n　　1315=2<sup>10</sup> +2<sup>8</sup> +2<sup>5</sup> +2+1<br />\n　　所以1315最后可表示为：<br />\n　　2（2（2+2（0））+2）+2（2（2+2（0）））+2（2（2）+2（0））+2+2（0）</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含一个正整数N（N&lt;=20000），为要求分解的整数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　程序输出包含一行字符串，为符合约定的n的0，2表示（在表示中不能有空格）</div>\n","gpid":"T72","lanqiaotitle":"幂方分解","memorylimit":"256.0MB","tid":"ALGO-12","timelimit":"1.0s","title":"算法训练 幂方分解","src":"NOIP1998 普及组"},{"checkpoint":"递归","updatetime":"2013-11-01","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有一长度为N(1&lt;=Ｎ&lt;=10)的地板，给定两种不同瓷砖：一种长度为1，另一种长度为2，数目不限。要将这个长度为N的地板铺满，一共有多少种不同的铺法？<br />\n　　例如，长度为4的地面一共有如下5种铺法：<br />\n　　4=1+1+1+1<br />\n　　4=2+1+1<br />\n　　4=1+2+1<br />\n　　4=1+1+2<br />\n　　4=2+2<br />\n　　编程用递归的方法求解上述问题。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　只有一个数N，代表地板的长度</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个数，代表所有不同的瓷砖铺放方法的总数</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n<font face=\"Times New Roman\" size=\"3\">4</font>\n</pre>\n<div class='pdsec'>样例输出</div><pre class='pddata'>\n<font face=\"Times New Roman\" size=\"3\">5</font>\n</pre>\n\n","gpid":"T55","lanqiaotitle":"瓷砖铺放","memorylimit":"512.0MB","tid":"ALGO-11","timelimit":"1.0s","title":"算法训练 瓷砖铺放","src":""},{"checkpoint":"数组 排序","updatetime":"2013-11-01","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给出两个整数集合A、B，求出他们的交集、并集以及B在A中的余集。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行为一个整数n，表示集合A中的元素个数。<br />\n　　第二行有n个互不相同的用空格隔开的整数，表示集合A中的元素。<br />\n　　第三行为一个整数m，表示集合B中的元素个数。<br />\n　　第四行有m个互不相同的用空格隔开的整数，表示集合B中的元素。<br />\n　　集合中的所有元素均为int范围内的整数，n、m&lt;=1000。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第一行按从小到大的顺序输出A、B交集中的所有元素。<br />\n　　第二行按从小到大的顺序输出A、B并集中的所有元素。<br />\n　　第三行按从小到大的顺序输出B在A中的余集中的所有元素。</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n1 2 3 4 5<br />\n5<br />\n2 4 6 8 10</div><div class='pdsec'>样例输出</div><div class='pddata'>2 4<br />\n1 2 3 4 5 6 8 10<br />\n1 3 5</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\n1 2 3 4<br />\n3<br />\n5 6 7</div><div class='pdsec'>样例输出</div><div class='pddata'>1 2 3 4 5 6 7<br />\n1 2 3 4</div>\n","gpid":"T53","lanqiaotitle":"集合运算","memorylimit":"512.0MB","tid":"ALGO-10","timelimit":"1.0s","title":"算法训练 集合运算","src":""},{"checkpoint":"动态规划","updatetime":"2013-10-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　如果一个序列满足下面的性质，我们就将它称为摆动序列：<br />\n　　1.        序列中的所有数都是不大于<i>k</i>的正整数；<br />\n　　2.        序列中至少有两个数。<br />\n　　3.        序列中的数两两不相等；<br />\n　　4.        如果第<i>i</i> – 1个数比第<i>i</i> – 2个数大，则第<i>i</i>个数比第<i>i</i> – 2个数小；如果第<i>i</i> – 1个数比第<i>i</i> – 2个数小，则第<i>i</i>个数比第<i>i</i> – 2个数大。<br />\n　　比如，当<i>k</i> = 3时，有下面几个这样的序列：<br />\n　　1 2<br />\n　　1 3<br />\n　　2 1<br />\n　　2 1 3<br />\n　　2 3<br />\n　　2 3 1<br />\n　　3 1<br />\n　　3 2<br />\n　　一共有8种，给定<i>k</i>，请求出满足上面要求的序列的个数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含了一个整数<i>k</i>。（<i>k</i>&lt;=20）</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个整数，表示满足要求的序列个数。</div><div class='pdsec'>样例输入</div><div class='pddata'>3</div><div class='pdsec'>样例输出</div><div class='pddata'>8</div>\n","gpid":"T44","lanqiaotitle":"摆动序列","memorylimit":"512.0MB","tid":"ALGO-9","timelimit":"1.0s","title":"算法训练 摆动序列","src":""}]},{"name":"算法提高","prefix":"ADV-","problems":[{"checkpoint":"","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　植物大战僵尸这款游戏中，还有一个特别的玩儿法：玩家操纵僵尸进攻植物。<br />\n　　首先，僵尸有m种（每种僵尸都是无限多的），玩家可以选择合适的僵尸来进攻。使用第i种僵尸需要花费Wi资源，可以得到Pi的攻击效果。在这里，我们认为多个僵尸总的攻击效果就是他们每个攻击效果的代数和。<br />\n　　地图共有n行，对于第i行，最左端有若干植物，这些植物需要至少Qi的攻击才能被全部消灭。若一行上的植物全部被消灭，我们称这一行被攻破。<br />\n　　由于资源紧张，你只有总量为K的资源，不一定能够攻破所有行。但统治者希望攻破相邻的T行，并希望T尽量的大。你能帮他算出T的值吗？</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行三个非负整数：m、n、K；<br />\n　　第二行m个正整数，第i个数表示Wi；<br />\n　　第三行m个正整数，第i个数表示Pi；<br />\n　　第四行n个非负整数，第i个数表示Qi。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　3 11 39<br />\n　　5 2 11<br />\n　　3 1 7<br />\n　　5 3 6 10 3 2 4 200 1 1 1</div><div class='pdsec'>样例输入</div><div class='pddata'>一个满足题目要求的输入范例。<br />\n例：<br />\n2 2<br />\n1 2<br />\n3 4</div><div class='pdsec'>样例输出</div><div class='pddata'>4</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于70%的数据：n&lt;=1000<br />\n<br />\n　　对于100%的数据：n&lt;=200000，m&lt;=100，K&lt;=1000000，所有Pi、Qi&lt;=100000000</div>\n","gpid":"T754","lanqiaotitle":"进攻策略加强","memorylimit":"256.0MB","tid":"ADV-365","timelimit":"1.0s","title":"算法提高 进攻策略加强","src":""},{"checkpoint":"DP","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　A同学的学习成绩十分不稳定，于是老师对他说：“只要你连续4天成绩有进步，那我就奖励给你一朵小红花。”可是这对于A同学太困难了。于是，老师对他放宽了要求：“只要你有4天成绩是递增的，我就奖励你一朵小红花。”即只要对于第i、j、k、l四天，满足i&lt;j&lt;k&lt;l并且对于成绩wi&lt;wj&lt;wk&lt;wl，那么就可以得到一朵小红花的奖励。现让你求出，A同学可以得到多少朵小红花。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个整数n，表示总共有n天。第二行n个数，表示每天的成绩wi。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个数，表示总共可以得到多少朵小红花。</div><div class='pdsec'>样例输入</div><div class='pddata'>6<br />\n1 3 2 3 4 5</div><div class='pdsec'>样例输出</div><div class='pddata'>6</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于40%的数据，n&lt;=50；<br />\n　　对于100%的数据，n&lt;=2000，0&lt;=wi&lt;=10<sup>9</sup>。</div>\n","gpid":"T753","lanqiaotitle":"天天向上","memorylimit":"256.0MB","tid":"ADV-364","timelimit":"1.0s","title":"算法提高 天天向上","src":""},{"checkpoint":"欧拉函数","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　老师出了一道难题，小酱不会做，请你编个程序帮帮他，奖金一瓶酱油：<br />\n　　从1—n中有多少个数与n互质?<br />\n　　|||||╭══╮ ┌═════┐<br />\n　　╭╯让路║═║酱油专用车║<br />\n　　╰⊙═⊙╯ └══⊙═⊙═(坑爹的题面格式化，害得我用‘|’来代替空格，复制到记事本上看就变成正版的了)</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入共一行，表示一个整数n。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出共一行，表示从1—n中与n互质的数的个数。</div><div class='pdsec'>样例输入</div><div class='pddata'>30</div><div class='pdsec'>样例输出</div><div class='pddata'>8</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　60%的数据≤10^6<br />\n　　100%的数据≤2*10^9</div>\n","gpid":"T752","lanqiaotitle":"欧拉函数","memorylimit":"256.0MB","tid":"ADV-363","timelimit":"1.0s","title":"算法提高 欧拉函数","src":"程序设计基础"},{"checkpoint":"","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　计算1*(1+k)*(1+2*k)*(1+3*k)*...*(1+n*k-k)的末尾有多少个0，最后一位非0位是多少。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含两个整数n, k。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出两行，每行一个整数，分别表示末尾0的个数和最后一个非0位。</div><div class='pdsec'>样例输入</div><div class='pddata'>15 2</div><div class='pdsec'>样例输出</div><div class='pddata'>0<br />\n5</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=k&lt;=10，1&lt;=n&lt;=1000000。</div>\n","gpid":"T751","lanqiaotitle":"计算超阶乘","memorylimit":"256.0MB","tid":"ADV-362","timelimit":"1.0s","title":"算法提高 计算超阶乘","src":""},{"checkpoint":"递归","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　汉诺塔是一个古老的数学问题：<br />\n　　有三根杆子A，B，C。A杆上有N个(N&gt;1)穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至C杆：<br />\n　　每次只能移动一个圆盘；<br />\n　　大盘不能叠在小盘上面。<br />\n　　提示：可将圆盘临时置于B杆，也可将从A杆移出的圆盘重新移回A杆，但都必须遵循上述两条规则。<br />\n<br />\n　　问：如何移？最少要移动多少次？</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一行，包含2个正整数，一个是N（N&lt;=15)，表示要移动的盘子数；一个是M，表示在最少移动d第M步</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　共2行。<br />\n　　第一行输出格式为：#No: a-&gt;b，表示第M步骤具体移动方法，其中No表示第M步移动的盘子的编号（N个盘子从上到下依次编号为1到n），表示第M步是将No号盘子从a杆移动到b杆（a和b的取值均为{A、B、C}）。<br />\n　　第2行输出一个整数，表示最少移动步数。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 2</div><div class='pdsec'>样例输出</div><div class='pddata'>#2: A-&gt;B<br />\n7</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　0&lt;N&lt;20，0&lt;M&lt;=最小移动步数</div>\n","gpid":"T750","lanqiaotitle":"汉诺塔","memorylimit":"256.0MB","tid":"ADV-361","timelimit":"1.0s","title":"算法提高 汉诺塔","src":""},{"checkpoint":"高精度减法","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　高精度减法</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　两行，表示两个非负整数a、b，且有a &gt; b。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行，表示a与b的差</div><div class='pdsec'>样例输入</div><div class='pddata'>1234567890987654321<br />\n<br />\n9999</div><div class='pdsec'>样例输出</div><div class='pddata'>1234567890987644322</div>\n","gpid":"T749","lanqiaotitle":"高精度减法","memorylimit":"256.0MB","tid":"ADV-360","timelimit":"1.0s","title":"算法提高 高精度减法","src":""},{"checkpoint":"","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个正整数n，尝试对其分解质因数</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　仅一行，一个正整数，表示待分解的质因数</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　仅一行，从小到大依次输出其质因数，相邻的数用空格隔开</div><div class='pdsec'>样例输入</div><div class='pddata'>100</div><div class='pdsec'>样例输出</div><div class='pddata'>2 2 5 5</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=2147483647</div>\n","gpid":"T748","lanqiaotitle":"分解质因数","memorylimit":"256.0MB","tid":"ADV-359","timelimit":"1.0s","title":"算法提高 分解质因数","src":""},{"checkpoint":"","updatetime":"2020-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给出在数轴上的n条线段的左右端点的坐标l,r和它们的价值v，请你选出若干条没有公共点的线段(端点重合也算有公共点)，使得它们的价值和最大，输出最大价值和。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个正整数n。<br />\n<br />\n　　接下来n行，每行三个整数l,r,v分别表示一条线段的左端点，右端点和价值。l&lt;r，v&gt;0。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个整数表示最大价值和。</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\n1 3 4<br />\n3 5 7<br />\n5 7 3<br />\n2 6 8</div><div class='pdsec'>样例输出</div><div class='pddata'>8</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=2000<br />\n　　l,r,v&lt;=1000000</div>\n","gpid":"T747","lanqiaotitle":"不重叠的线段","memorylimit":"256.0MB","tid":"ADV-358","timelimit":"1.0s","title":"算法提高 不重叠的线段","src":""},{"checkpoint":"基本输入输出、字符类型","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　从键盘输入一个字符，如果是大写字母（A-Z），就转换成小写；如果是小写字母（a-z），就转换成大写，如果是其他字符原样保持并将结果输出。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入一行，包含一个字符。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行，即按照要求输出的字符。</div><div class='pdsec'>样例输入</div><div class='pddata'>a</div><div class='pdsec'>样例输出</div><div class='pddata'>A</div>\n","gpid":"T726","lanqiaotitle":"字母大小写转换","memorylimit":"256.0MB","tid":"ADV-357","timelimit":"1.0s","title":"算法提高 字母大小写转换","src":""},{"checkpoint":"","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给出一个字符串S，然后给出q条指令，分别有4种：<br />\n<br />\n　　1. Append str<br />\n　　表示在S的最后追加一个字符串str。<br />\n　　例：<br />\n　　原字符串：ABCDE<br />\n　　执行 Append FGHIJ 后<br />\n　　字符串变为：ABCDEFGHIJ<br />\n<br />\n　　2. Insert x str<br />\n　　表示在位置x处插入一个字符串str。（输入保证0&lt;x&lt;=当前字符串长度）<br />\n　　例：<br />\n　　原字符串：ABCGHIJ<br />\n　　执行 Insert 4 DEF 后<br />\n　　字符串变为：ABCDEFGHIJ<br />\n<br />\n　　3. Swap a b c d<br />\n　　表示交换从第a位到第b位的字符串与从第c位到第d位的字符串。（输入保证0&lt;a&lt;b&lt;c&lt;d&lt;=当前字符串长度）<br />\n　　例：<br />\n　　原字符串：ABGHIFCDEJ<br />\n　　执行 Swap 3 5 7 9后<br />\n　　字符串变为：ABCDEFGHIJ<br />\n<br />\n　　4. Reverse a b<br />\n　　表示将从第a位到第b位的字符串反转。（输入保证0&lt;a&lt;b&lt;=当前字符串长度）<br />\n　　例：<br />\n　　原字符串：ABGFEDCHIJ<br />\n　　执行 Reverse 3 7 后<br />\n　　字符串变为：ABCDEFGHIJ<br />\n<br />\n　　最后输出按顺序执行完指令后的字符串。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入第一行包含字符串S，第二行包含一个整数q，接下来q行分别为q个指令。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出为1行，为按顺序执行完输入指令后的字符串。</div><div class='pdsec'>样例输入</div><div class='pddata'>My<br />\n5<br />\nAppend  Hello<br />\nInsert 3 dlroW<br />\nReverse 3 7<br />\nSwap 3 7 8 12<br />\nSwap 1 2 3 7</div><div class='pdsec'>样例输出</div><div class='pddata'>HelloMyWorld</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　原字符串：My<br />\n　　执行 Append  Hello 后：MyHello<br />\n　　执行 Insert 3 dlroW 后：MydlroWHello<br />\n　　执行 Reverse 3 7 后：MyWorldHello<br />\n　　执行 Swap 3 7 8 12 后：MyHelloWorld<br />\n　　执行 Swap 1 2 3 7 后：HelloMyWorld</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于30%的数据，q=1；<br />\n<br />\n　　对于70%的数据，如有Swap指令，Swap指令中b-a=d-c；<br />\n<br />\n　　对于100%的数据，最终字符串长度不大于40000，1&lt;=q&lt;=150</div>\n","gpid":"T725","lanqiaotitle":"字符串的操作","memorylimit":"256.0MB","tid":"ADV-356","timelimit":"1.0s","title":"算法提高 字符串的操作","src":""},{"checkpoint":"数组,循环,质数","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个正整数N，请你输出N以内（不包含N）的质数以及质数的个数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入一行，包含一个正整数N。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　共两行。<br />\n　　第1行包含一个整数，表示N以内质数的个数。<br />\n　　第2行包含若干个素数，每两个素数之间用一个空格隔开，素数从小到大输出。</div><div class='pdsec'>样例输入</div><div class='pddata'>10</div><div class='pdsec'>样例输出</div><div class='pddata'>4<br />\n2 3 5 7</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　N&lt;=1000</div>\n","gpid":"T724","lanqiaotitle":"质数2","memorylimit":"256.0MB","tid":"ADV-355","timelimit":"1.0s","title":"算法提高 质数2","src":""},{"checkpoint":"循环、素数","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个正整数N，请你输出N以内（不包含N）的质数以及质数的个数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入一行，包含一个正整数N。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　共两行。<br />\n　　第1行包含若干个素数，每两个素数之间用一个空格隔开，素数从小到大输出。<br />\n　　第2行包含一个整数，表示N以内质数的个数。</div><div class='pdsec'>样例输入</div><div class='pddata'>10</div><div class='pdsec'>样例输出</div><div class='pddata'>2 3 5 7<br />\n4</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　N&lt;=1000</div>\n","gpid":"T723","lanqiaotitle":"质数","memorylimit":"256.0MB","tid":"ADV-354","timelimit":"1.0s","title":"算法提高 质数","src":""},{"checkpoint":"高精度乘法","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'><b>计算机真是最傻的东西；他都不能计算大于</b><b>10^65-1</b><b>的</b><b>a*b</b><b>，请你帮这个“最傻”的东西过关，否则它就真的只认识</b><b>1</b><b>和</b><b>0</b><b>了。</b><b></b></div><div class='pdsec'>输入格式</div><div class='pdcont'><b>共两行；</b><b></b><br />\n<b>  第一行输入一个整数</b><b>a</b><b>；</b><b></b><br />\n<b>     </b><b>第一行输入一个整数</b><b>b</b><b>。</b><b></b></div><div class='pdsec'>输出格式</div><div class='pdcont'>　　共一行，一个表示a*b的整数。</div><div class='pdsec'>样例输入</div><div class='pddata'><b>2147483647</b><br />\n<b>2147483647</b></div><div class='pdsec'>样例输出</div><div class='pddata'>4611686014132420609</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　10^65-1&lt;a,b&lt;10^201-1</div>\n","gpid":"T722","lanqiaotitle":"高精度乘法","memorylimit":"256.0MB","tid":"ADV-353","timelimit":"1.0s","title":"算法提高 高精度乘法","src":"7号同学何佳优的脸"},{"checkpoint":"函数","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　C语言数学库中用来计算x的y次幂的函数的定义如下： double pow( double x, double y)，用该函数用来做整数的幂运算不仅耗时多，结果也经常不够准确。<br />\n　　请你自己写一个计算整数x的y（y是非负整数）次幂的函数，该函数的定义如下：<br />\n　　int power( int x, int y );</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　只写函数，不用考虑输入输出格式。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　函数中无需输出，只要将所求的的返回。</div><div class='pdsec'>样例输入</div><div class='pddata'>10 2</div><div class='pdsec'>样例输出</div><div class='pddata'>100</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入和计算结果都在int表示范围内。</div>\n","gpid":"T721","lanqiaotitle":"编写函数计算x^y","memorylimit":"256.0MB","tid":"ADV-352","timelimit":"1.0s","title":"算法提高 编写函数计算x^y","src":""},{"checkpoint":"","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输入n个字符串，比较这些字符串的大小并统计并按字典序输出字符串及出现个数</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含一个整数n，表示字符串个数。接下来n行，表示输入的字符串。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出n行，每行包含一个字符串及一个整数，表示字符串及出现个数。</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\naab<br />\nbbc<br />\naab<br />\nsdffg<br />\nsgjklsa</div><div class='pdsec'>样例输出</div><div class='pddata'>aab 2<br />\nbbc 1<br />\nsdffg 1<br />\nsgjklsa 1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　30%  l=1<br />\n　　30% l=10<br />\n　　20%  l&lt;=100<br />\n　　100% n&lt;=1000,l&lt;=1000</div>\n","gpid":"T720","lanqiaotitle":"比大小","memorylimit":"256.0MB","tid":"ADV-351","timelimit":"1.0s","title":"算法提高 比大小","src":""},{"checkpoint":"","updatetime":"2020-04-17","content":"<div class='pdcont'><img width=\"781\" height=\"741\" src=\"/RequireFile.do?fid=6B5DGb32\" /></div>\n","gpid":"T702","lanqiaotitle":"珠心算测验","memorylimit":"256.0MB","tid":"ADV-350","timelimit":"1.0s","title":"算法提高 珠心算测验","src":""},{"checkpoint":"","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　树的直径</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含一个整数n，表示树中的点数。接下来n-1行，每行3个正整数，表示连同的两点及边的权值。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出1行，包含一个整数，表示树的直径。</div><div class='pdsec'>样例输入</div><div class='pddata'>7<br />\n1 2 1<br />\n1 3 1<br />\n2 4 1<br />\n3 5 1<br />\n4 7 1<br />\n4 6 1</div><div class='pdsec'>样例输出</div><div class='pddata'>5</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;10^5</div>\n","gpid":"T701","lanqiaotitle":"树的直径","memorylimit":"8.0MB","tid":"ADV-349","timelimit":"100ms","title":"算法提高 树的直径","src":""},{"checkpoint":"","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学排成合唱队形。<br />\n　　合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1，2…，K，他们的身高分别为T1，T2，…，TK， 则他们的身高满足T1&lt;...&lt;Ti&gt;Ti+1&gt;…&gt;TK(1&lt;=i&lt;=K)。<br />\n　　你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行是一个整数N(2&lt;=N&lt;=100)，表示同学的总数。第一行有n个整数，用空格分隔，第i个整数Ti(130&lt;=Ti&lt;=230)是第i位同学的身高(厘米)。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n8\n186 186 150 200 160 130 197 220\n</pre>\n<div class='pdsec'>样例输出</div><div class='pddata'>4<pre class='pddata'>\n</pre>\n</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　up</div>\n","gpid":"T700","lanqiaotitle":"合唱队形","memorylimit":"256.0MB","tid":"ADV-348","timelimit":"1.0s","title":"算法提高 合唱队形","src":"NOIP2004 提高组"},{"checkpoint":"八数码","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　RXY八数码</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入两个3*3表格<br />\n　　第一个为目标表格<br />\n　　第二个为检索表格</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出步数</div><div class='pdsec'>样例输入</div><div class='pddata'>1 2 3<br />\n4 5 6<br />\n7 8 0<br />\n1 2 3<br />\n4 5 6<br />\n7 0 8</div><div class='pdsec'>样例输出</div><div class='pddata'>1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　3*3*2</div>\n","gpid":"T699","lanqiaotitle":"八数码","memorylimit":"256.0MB","tid":"ADV-347","timelimit":"1.0s","title":"算法提高 八数码","src":""},{"checkpoint":"计算几何","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　WYF酷爱玩魔兽世界。这天他要去4个不同的地方A、B、C、D。现在CWZ要WYF给他500金。WYF不情愿地答应了。他告诉CWZ，在<img src=\"/fckeditor/editor/images/smiley/msn/thumbs_down.gif\" />直线<img src=\"/fckeditor/editor/images/smiley/msn/thumbs_up.gif\" />AC和BD的交点E等他。CWZ立刻前往交易地点。突然WYF发现一个致命的问题——他的智商严重不够，算不出AC、BD的交点E的位置......。于是——现在问题来了——他找到了机智的你，要你求出AC、BD的交点E。如果没有交点或AC、BD重合，请输出“LLJJ”。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入共四行，每行为2个实数，保留2位小数。<br />\n　　第一行为Xa，Ya；<br />\n　　第一行为Xb，Yb；<br />\n　　第一行为Xc，Yc；<br />\n　　第一行为Xd，Yd。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出仅一行，为交点的坐标Xe，Ye，保留5位小数。</div><div class='pdsec'>样例输入</div><div class='pddata'>1.00 1.00<br />\n1.00 -1.00<br />\n-1.00 -1.00<br />\n-1.00 1.00</div><div class='pdsec'>样例输出</div><div class='pddata'>0.00000 0.00000</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　|X|，|Y|&lt;=290。</div>\n","gpid":"T698","lanqiaotitle":"WYF的交易地点","memorylimit":"256.0MB","tid":"ADV-346","timelimit":"1.0s","title":"算法提高 WYF的交易地点","src":"WYF系列"},{"checkpoint":"","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　在参观Theta VIII星球时，你的宇航员队伍有了一次狗血经历，被逼迫在Google Royale赌场里参加赌博。为了离开这个赌场，你必须赚够足够多的钱。<br />\n　　一开始你有A快钱。你必须一直进行一轮一轮的赌博，直到满足以下条件之一<br />\n　　1.你的钱&lt;=0，此时你输了整场比赛<br />\n　　2.你的钱&gt;=V，此时你赢了整场比赛<br />\n　　每一轮赌博规则如下：<br />\n　　赌博开始时，你要押注。若当前你有X块钱，那么你押注的金额B可以取[1,min(X,M)]中的任意整数（M为给定常数），作为第一次押注。<br />\n　　赌博过程就是买大买小，所以每一次押注都有50%的概率会赢，50%的概率会输<br />\n　　若赢，则赌场会立刻付给你B块钱，于是你就有了X+B块钱<br />\n　　若输，则你会欠赌场B块钱。此时你可以选择立刻支付这B块钱并结束本轮游戏。但你还有另一种选择，如果2B&lt;=M的话，你可以选择将本次支付延期，并再赌一次，同时赌注加倍：2B块钱。如果你又输了，那你就欠赌场B+2B=3B块钱了。你还可以继续将你的赌注像这样加倍，加到4B,8B等等。直到在这个过程中你赢了某一次押注，或者下一次加倍的赌金会超过M。这种加倍再赌一次的过程可以在你的欠款超过X的时候进行。<br />\n　　一轮赌博结束后，如果你输了你就必须立刻偿还所有欠下的赌金，如果你赢了赌场会给你你应得的赌金。比方说：在一轮中，你一开始下注1块钱，之后连续连续三次加倍，最后一次加倍赢了，那你会获得8 - 4 - 2 - 1 = 1块钱。如果你连续加倍两次之后就不加倍了，那你需要付给赌场4 + 2 + 1 = 7块钱。如果在支付后你还有&lt;=0块钱，你就输了整场比赛。<br />\n　　幸运的的是，你带了一台安卓，它能帮你算你在最优策略下最后获胜的概率。所以请输出：你在最优策略下的获胜概率，以及在所有的最优策略中，你第一次下注的最大可能值。不要忘记每次下注都不能&gt;M。<br />\n<br />\n　　一个例子：<br />\n　　一开始你有A=5块钱，押注上限M=20，获胜金额V=40。那么下面是一次可能实际的赌博：<br />\n　　第1轮<br />\n　　(B=2)：你可以下注1,2,3,4或5块钱，你选择下注2块钱，你赢了，现在你有7块钱<br />\n　　第2轮<br />\n　　(B=5)：你选择下注5块钱。你输了，因为5*2&lt;=20，你可以再加倍下注5*2=10块钱。但你选择不这么做。于是本轮结束后你失去了5块钱。现在你有2块钱<br />\n　　第3轮<br />\n　　(B=2)：你下注2块钱，你输了，你现在欠债2块钱<br />\n　　(B=4)：你表示不能忍，加倍下注4块钱，但又输了。现在你欠债2+4=6块钱<br />\n　　(B=8)：你再次加倍下注，你赢了。于是本轮你获得了8-2-4=2块钱。现在你有4块钱<br />\n　　第4论：<br />\n　　(B=2)：你下注2块钱，输了，欠2块钱<br />\n　　(B=4)：你加倍下注4块钱，输了，欠6块钱<br />\n　　(B=8)：你加倍下注8块钱，输了，欠14块钱<br />\n　　(B=16)：你加倍下注16块钱，输了，欠30块钱。<br />\n　　由于2*16&gt;=M，你不能再加倍下注了，于是你要偿还你所欠的钱，你还剩余-26块钱，所以你输了。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个整数T，表示本题有T组数据<br />\n　　之后T行，每行三个整数A,M,V，分别表示初始钱数，押注上限，和胜利钱数</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每一组数据，你输出一行两个数，分别为最优策略下的胜率和在所有的最优策略中你第一轮下注的最大可能值。允许有10^(-6)的绝对误差或者相对误差</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\n1 1 3<br />\n3 6 12<br />\n4 20 15<br />\n13 6 20</div><div class='pdsec'>样例输出</div><div class='pddata'>0.333333333 1<br />\n0.500000000 3<br />\n0.755555555 3<br />\n0.730769231 6</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=M&lt;=10^16<br />\n　　1&lt;=A&lt;V&lt;=10^16<br />\n　　1&lt;=T&lt;=5</div>\n","gpid":"T697","lanqiaotitle":"Google Royale","memorylimit":"256.0MB","tid":"ADV-345","timelimit":"1.0s","title":"算法提高 Google Royale","src":"Google Codejam 2011 E"},{"checkpoint":"数学 博弈","updatetime":"2020-04-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　艾米有一副N张卡片的牌，牌上面的数值为1到N。<br />\n　　她把这副牌排列好了，且保证没有三张牌的子序列是递减的。<br />\n　　例如，1，5，4，6，3，2的子序列是不可以的，因为5，3，2是递减的三张牌。<br />\n<br />\n　　艾米现在把这副牌反面朝上给本。本知道，这副牌没有长度为3的递减的子序列，但他并不知道确切的顺序。他想找到值为1的卡牌。他可以选择任意卡，翻开它，然后重复，直到他发现了卡值1。在每一步，本选择的卡，将最小化最坏情况下的次数，亦即本的策略并不会浪费他翻开卡的次数。<br />\n<br />\n　　本之后告诉你，他的运气非常不好，不得不翻开所有N张牌才找到卡值为1的卡。<br />\n　　给你本翻牌的顺序，求出艾米放置的每张卡的值。<br />\n　　如果有多个可能性，请输出字典最大的。<br />\n<br />\n　　两个不同的牌的排列的字典序比较方式为，比较从左起第一个值不同的卡牌大小。<br />\n<br />\n　　例如：N=3，本以2，1，3（卡牌标号从1开始）的顺序翻开卡牌，那么卡的值一定是：2，3，1。<br />\n<br />\n　　说明：如果卡＃2为值1，那么本就会立即停止。如果卡＃2具有值2，则本会知道第一张卡一定是1，因为（3，2，1）是长度为3的递减的子序列，因此不可能会有该顺序。在任一情况下，本就不会需要翻开第三张牌。因此，我们可以推断出卡＃2有值3。同样，卡＃1不可能有值1，否则本可以提前终止。因此，卡值一定是2，3，1。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　（原题的输入为多组数据，这里因故改为单组数据）<br />\n　　第一行一个数N，为卡牌的数量。<br />\n　　第二行N个数，为1～N的排列，表示本翻牌的顺序。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行N个数，用空格隔开，表示字典序最大的Amy可能使用的牌的顺序。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n3 2 1</div><div class='pdsec'>样例输出</div><div class='pddata'>1 3 2</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于20%的数据，N&lt;=8<br />\n　　对于100%的数据，N&lt;=300</div>\n","gpid":"T696","lanqiaotitle":"Ace in the Hole","memorylimit":"256.0MB","tid":"ADV-344","timelimit":"1.0s","title":"算法提高 Ace in the Hole","src":"GCJ 2011 Final D"},{"checkpoint":"suffix array","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　由于战网的密码是一串乱码，WYF巧妙地忘记了他的密码。（他就是作死，如同自掘坟墓。说到掘坟墓，问题就来了——挖掘机技术究竟哪家强？）他现在非常着急，走投无路，都快飞起来了。他只记得他的密码是某个字符串S的子串。现在问题来了，你要告诉他有多少种可能的密码，以帮助他确定他能在多少时间内完成枚举并尝试密码的工作。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入仅包含一行，为字符串S，不含空格。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个整数，表示可能的密码数量。</div><div class='pdsec'>样例输入</div><div class='pddata'>ToTal</div><div class='pdsec'>样例输出</div><div class='pddata'>14</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于70%的数据，S的长度不超过1000；（暴力）<br />\n　　对于100%的数据，S的长度不超过15000。<img src=\"/fckeditor/editor/images/smiley/msn/regular_smile.gif\" />（Suffix Array）</div>\n","gpid":"T679","lanqiaotitle":"着急的WYF（不同子串个数）","memorylimit":"256.0MB","tid":"ADV-343","timelimit":"476ms","title":"算法提高 着急的WYF（不同子串个数）","src":"《后缀数组...》——例5"},{"checkpoint":"判断，简单，偶数还是奇数","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　判断一个数是奇数还是偶数</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入1个整数n。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　如果是偶数，输出“even”。<br />\n　　如果是奇数输出“odd”</div><div class='pdsec'>样例输入</div><div class='pddata'>34</div><div class='pdsec'>样例输出</div><div class='pddata'>even</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=100000000</div>\n","gpid":"T678","lanqiaotitle":"偶数还是奇数","memorylimit":"256.0MB","tid":"ADV-342","timelimit":"1.0s","title":"算法提高 偶数还是奇数","src":"练习"},{"checkpoint":"状态压缩的动态规划","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给了一nxm的方格，用1x3的瓷砖铺满，请问有多少种铺法。瓷砖可以旋转。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含两个整数，n, m。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个整数，表示总的铺法数。这个数可能很大，请输出对65521取余的结果。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 3</div><div class='pdsec'>样例输出</div><div class='pddata'>2</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于100%的数据，1&lt;=n&lt;=10^15，1&lt;=m&lt;=9。</div>\n","gpid":"T677","lanqiaotitle":"瓷砖铺放 增强","memorylimit":"256.0MB","tid":"ADV-341","timelimit":"3.0s","title":"算法提高 瓷砖铺放 增强","src":""},{"checkpoint":"","updatetime":"2020-04-03","content":"<div class='pdcont'>　　给出一个整数　　n ( n&lt;10^30) 和k个变换规则（k&lt;=15）。<br />\n　　规则：<br />\n　　（1）1位数可变换成另一个一位数；<br />\n　　（2）规则的右部不能为０。<br />\n<br />\n　　例如：n=234，有规则(k=2)：<br />\n　　2 → 5<br />\n　　3 → 6<br />\n　　上面的整数234经过变换后可能产生出的整数为（包括原数）：<br />\n　　234<br />\n　　534<br />\n　　264<br />\n　　564<br />\n　　共　　4 种不同的产生数<br />\n　　求经过任意次的变换（0次或多次），能产生出多少个不同的整数。仅要求输出不同整数个数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　n<br />\n　　k<br />\n　　x1 y1<br />\n　　x2 y2<br />\n　　… …<br />\n　　xn yn</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　格式为一个整数（满足条件的整数个数）。</div><div class='pdsec'>样例输入</div><div class='pddata'>234<br />\n2<br />\n2 5<br />\n3 6</div><div class='pdsec'>样例输出</div><div class='pddata'>4</div>\n","gpid":"T676","lanqiaotitle":"产生数","memorylimit":"256.0MB","tid":"ADV-340","timelimit":"1.0s","title":"算法提高 产生数","src":"noip 2002"},{"checkpoint":"二分答案 贪心","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　信息技术的发展日益渗透到人类活动的各个领域。令人难以置信的是，最先进的科技被用到了农业上。<br />\n　　在一个大农场有一片草地和成群的羊。这里总共有 <i>n</i> 只羊，它们中的每一个被标上了一个独一无二的编号，编号的范围从 1 到 <i>n</i> ——因为你需要区分出每只羊并记住它们的信息，而且它们还如此的相似！这片草地有无限数量的区域，从 1 到无穷编号。已知 <i>i</i> 号羊喜欢编号从 <i>l<sub>i</sub></i> 到 <i>r<sub>i</sub></i> 的区域。<br />\n　　这里有两个牧羊人在照顾羊群：甲和乙。甲每天早晨起得很早，领着羊群到草地上去吃草。乙则在晚上出来领回所有的羊。<br />\n　　一天早晨，甲起得比平时有点迟，没有时间领羊群到草地上吃草。因此，他把所有有公共喜欢区域的羊拴在一起。甲认为这样会更好——乙晚上时会少做些工作，因为羊不会走开太远，它们正被互相拴着呢！<br />\n　　到了夜晚，乙来到了草地，他把羊群聚集起来并尝试把它们排成一队。但是尽管他很努力了，羊群还是没有排成他想要的那样。乙没有力气和能力去解开羊群，只好让它们保持原样，但有一个条件：他想要把羊群排成一队，使得相互栓着的羊的最大距离尽可能小。两只羊的距离定义为它们在队列中排名的差值。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含一个整数 <i>n</i>。接下来的 <i>n</i> 行每行包含两个整数 <i>l<sub>i</sub></i> 和 <i>r<sub>i</sub></i>。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出共一行，<i>n</i> 个用空格隔开的数字——要求的羊群的排列。这一行的第 <i>i</i> 个值必须代表最优排列从左数第 <i>i</i> 只羊的编号。<br />\n　　如果有多种最优解，输出任意一种即可。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n1 3<br />\n5 7<br />\n2 4</div><div class='pdsec'>样例输出</div><div class='pddata'>1 3 2</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n1 5<br />\n2 4<br />\n3 6<br />\n1 7<br />\n2 6</div><div class='pdsec'>样例输出</div><div class='pddata'>2 1 3 5 4</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\n1 3<br />\n4 6<br />\n5 7<br />\n2 3</div><div class='pdsec'>样例输出</div><div class='pddata'>1 4 2 3</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于20%的数据，1 ≤ <i>n</i> ≤ 8；<br />\n　　对于60%的数据，1 ≤ <i>n</i> ≤ 200；<br />\n　　对于100%的数据，1 ≤ <i>n</i> ≤ 2000，1 ≤ <i>l<sub>i</sub></i> ≤ <i>r<sub>i</sub></i> ≤ 10<sup>9</sup>。</div>\n","gpid":"T675","lanqiaotitle":"Sheep","memorylimit":"256.0MB","tid":"ADV-339","timelimit":"1.0s","title":"算法提高 Sheep","src":"Codeforces 309E"},{"checkpoint":"构造","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　疯狂的科学家Mike申请了一份工作。他的任务是管理一个抽水站系统。<br />\n　　这个系统包含n个抽水站，抽水站被标号为1到n。连接两个抽水站的双向管道可以使水在任何一个方向流动（但同一时间水只能往一个方向流）。你知道每个管道的宽度——每小时可以流过的最大水量。每个抽水站可以通过这些管道把水从一些站台抽向其他站台，同时在一小时内总的进水量等于总的出水量。<br />\n　　Mike的责任是用泵在这些站台之间输送水。遵循上述规则，可以在一小时内将一定数量的水通过管道（可能是通过其他站台）从站台a输送到站台b。在这期间，其他站台的水不能流入a，同时b站台的水也不能流出去。但是，任意多的水可以流出站台a，或者是流进站台b。如果一小时内有x升水流出站台a，Mike将获得额外的x元工资。<br />\n　　根据合同，Mike需要工作n-1天才能得到薪水。在第一天，他选择两个站台v_1和v_2，同时在一小时内，他将一定数量的水从v_1输送到v_2。然后，在第i天，Mike选择一个之前没有选过的站台v_i+1，再将一定数量的水在一小内从v_i输送到v_i+1。他在第i天输送的水的总量并不取决于他在第i-1天输送的水的总量。<br />\n　　Mike需要挣得尽可能多的钱，帮助迈克找到这样的一个排列v_1，v_2，……，v_n使得麦克能够获得尽可能高的薪水。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行读入两个整数n，m表示站台和管道的数量。<br />\n　　接下来m行每行三个整数a_i,b_i,c_i（a_i≠b_i）表示有一根管道连接站台a_i和b_i，并且它的容量是c_i。<br />\n　　保证任意两个站台之间最多有一根管道，任意两个站都可以通过管道到达。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第一行一个整数——麦克能够获得的最高的薪水。<br />\n　　在第二行输出n个用空格隔开的整数v_1，v_2，……，v_n。如果有多解，输出任意一组。</div><div class='pdsec'>样例输入</div><div class='pddata'>6 11<br />\n1 2 10<br />\n1 6 8<br />\n2 3 4<br />\n2 5 2<br />\n2 6 3<br />\n3 4 5<br />\n3 5 4<br />\n3 6 2<br />\n4 5 7<br />\n4 6 2<br />\n5 6 3</div><div class='pdsec'>样例输出</div><div class='pddata'>77<br />\n6 2 1 5 3 4</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于40％的数据，n≤30，m≤350<br />\n　　对于60％的数据，n≤80，m≤1000<br />\n　　对于100％的数据，n≤200，m≤1000，1≤c_i≤100</div>\n","gpid":"T674","lanqiaotitle":"Pumping Stations","memorylimit":"256.0MB","tid":"ADV-338","timelimit":"1.0s","title":"算法提高 Pumping Stations","src":"CF 343 E"},{"checkpoint":"枚举","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　从 Awesome Programmer University 毕业之前，学生们传统上要完成特定的“毕业要求”。其中之一是开车围绕环岛逆向行驶。对于大多数人来说，这是够疯狂的，但是作为一个额外的挑战，你要看看你能够在环岛逆向行驶多久，中途不停车。<br />\n　　这个环岛共有 N 个路口，均匀地分布在一个圆上。一辆汽车通常会从其中一个路口进入环岛，接下来每一秒，它会逆时针行驶到下一个路口，直到最后到达它的目的地才会离开，中途也不停车。<br />\n<img src=\"/RequireFile.do?fid=r4er9bGj\" /><br />\n　　你一直在观察进进出出的车辆，已经持续了 X 秒。对于每辆汽车，你记录下了它进入环岛的时间和它的进入路口与离开路口。所有的汽车都以 1 路口每秒的速度逆时针行驶。你看到的所有车都会在回到它的进入路口之前离开。这个环岛里有多条车道，所以多辆车可以同时出现在同一位置。<br />\n　　如果你计划得恰到好处，你可以在这个环岛顺时针行驶多久？你必须在一个 ≥ 0 的整数时刻进入环岛，在 ≤ X 的时刻离开，并且一旦你离开了，你就不允许再次进入。你在环岛里必须以 1 路口每秒的速度顺时针行驶。你想要尽可能地安全，所以你千万不能碰到或经过另一辆车。特别是，你不能在一个另一辆车正在进入或离开的路口进入，也不能在一个另一辆车正在进入或离开的路口离开，除此之外你可以选择任意的时间地点进入和离开环岛。<br />\n　　记住，你需要在一个可以表示成整秒的时间进入环岛——你必须在整数时刻进入，因此也会在整数时刻到达每个路口。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行给出了数据组数 T，接下来有 T 组数据。每组数据的第一行是一个整数 C，表示你观察的汽车数量。第二行两个整数 X 和 N ——你观察的时间(秒)和环岛上的路口数。接下来 C 行描述了你看到的每辆汽车，每行包含三个整数 s<sub>i</sub>, e<sub>i</sub>, t<sub>i</sub> ——这辆汽车的进入路口，离开路口和它进入的时间。路口从 1 到 N 逆时针编号(即 2 号路口在 1 号路口的逆时针方向)。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组数据，输出一行形如\"Case #x: y\"，其中 x 是数据编号(从 1 开始)，y 是你可以在环岛里行驶的最大秒数。注意，当你任何时刻都不能进入，或者是可以进入，但不能前往下一个路口时，y 是 0。</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n1<br />\n3 4<br />\n1 4 0<br />\n6<br />\n3 5<br />\n5 2 0<br />\n5 1 2<br />\n1 3 0<br />\n1 2 2<br />\n2 3 0<br />\n3 4 0<br />\n3<br />\n2 3<br />\n1 3 0<br />\n2 1 0<br />\n3 2 0<br />\n0<br />\n6 4<br />\n1<br />\n2 3<br />\n1 3 0</div><div class='pdsec'>样例输出</div><div class='pddata'>Case #1: 1<br />\nCase #2: 2<br />\nCase #3: 0<br />\nCase #4: 6<br />\nCase #5: 0</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　在第一个样例中，我们有一辆汽车，如图所示。有多种方法使得我们可以逆向行驶 1 秒——例如，我们可以在时刻 1 从 1 号路口进入(我们不能在时刻 0 进入，因为那时有其他车辆)，行驶到 4 号路口(我们不能行驶到 3 号路口，因为我们会经过一辆将要从 3 到 4 的车)。另一种选择是在 0 时刻从 4 号路口进入，行驶到 3 号路口并离开。<br />\n<img src=\"/RequireFile.do?fid=22j2EHq8\" width=\"251\" height=\"252\" /><br />\n　　在第二个样例中，我们可以行驶两秒，在时刻 1 从 5 号路口进入，逆向行驶到3号路口。<br />\n　　在第三个样例中，我们甚至无法进入这个环岛——每秒都有车在每个路口。<br />\n　　在第四个样例中，一辆车都没有，所以我们可以在时刻 0 从任意路口进入，行驶一圈又一圈直到时刻 6。<br />\n　　在第五个样例中，我们可以进入环岛，但是由于只有三个路口，我们将始终与另一辆车相撞，如果我们试图移到下一个路口。</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于10%的数据，3 ≤ N  ≤ 10，1 ≤ X ≤ 10，0 ≤ C ≤ 10；<br />\n　　对于30%的数据，3 ≤ N ≤ 10<sup>4</sup>，1 ≤ X ≤ 10<sup>6</sup>，0 ≤ C ≤ 10；<br />\n　　对于70%的数据，3 ≤ N ≤ 10<sup>10</sup>，1 ≤ X ≤ 10<sup>10</sup>，0 ≤ C ≤ 100；<br />\n　　对于另30%的数据，3 ≤ N ≤ 10<sup>10</sup>，1 ≤ X ≤ 10<sup>10</sup>，0 ≤ C ≤ 1000，T = 1；<br />\n　　对于100%的数据，1 ≤ T ≤ 10，1 ≤ s<sub>i</sub>,e<sub>i</sub> ≤ N，s<sub>i</sub> ≠ e<sub>i</sub>，0 ≤ t<sub>i</sub>，所有车辆的离开时间 ≤ X。</div>\n","gpid":"T673","lanqiaotitle":"Graduation Requirements","memorylimit":"256.0MB","tid":"ADV-337","timelimit":"1.0s","title":"算法提高 Graduation Requirements","src":"Google Code Jam 2013 Final A"},{"checkpoint":"CCF计算机软件能力认证 201409","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给出一个字符串和多行文字，在这些文字中找到字符串出现的那些行。你的程序还需支持大小写敏感选项：当选项打开时，表示同一个字母的大写和小写看作不同的字符；当选项关闭时，表示同一个字母的大写和小写看作相同的字符。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含一个字符串S，由大小写英文字母组成。<br />\n　　第二行包含一个数字，表示大小写敏感的选项，当数字为0时表示大小写不敏感，当数字为1时表示大小写敏感。<br />\n　　第三行包含一个整数n，表示给出的文字的行数。<br />\n　　接下来n行，每行包含一个字符串，字符串由大小写英文字母组成，不含空格和其他字符。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出多行，每行包含一个字符串，按出现的顺序依次给出那些包含了字符串S的行。</div><div class='pdsec'>样例输入</div><div class='pddata'>Hello<br />\n1<br />\n5<br />\nHelloWorld<br />\nHiHiHelloHiHi<br />\nGrepIsAGreatTool<br />\nHELLO<br />\nHELLOisNOTHello</div><div class='pdsec'>样例输出</div><div class='pddata'>HelloWorld<br />\nHiHiHelloHiHi<br />\nHELLOisNOTHello</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　在上面的样例中，第四个字符串虽然也是Hello，但是大小写不正确。如果将输入的第二行改为0，则第四个字符串应该输出。</div><div class='pdsec'>评测用例规模与约定</div><div class='pdcont'>　　1&lt;=n&lt;=100，每个字符串的长度不超过100。</div>\n","gpid":"T656","lanqiaotitle":"字符串匹配","memorylimit":"256.0MB","tid":"ADV-336","timelimit":"1.0s","title":"算法提高 字符串匹配","src":"CCF计算机软件能力认证 201409"},{"checkpoint":"","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　小X打算去超市shopping。小X没什么钱，只有N元。超市里有M种物品，每种物品都需要money，在小X心中有一个重要度。有的物品有无限件，有的物品只有几件。小X想让他买的物品重要度之和最大，请问这个和最大是多少？</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行为两个整数N，M。<br />\n　　以下M行，每行包含三个整数P，R，C，分别表示价格、重要度和个数。若C为-1则表示无限件。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出只有一行，即题目中要求的最大和。</div><div class='pdsec'>样例输入</div><div class='pddata'>2 10<br />\n3 7 2<br />\n2 4 -1</div><div class='pdsec'>样例输出</div><div class='pddata'>22</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于20%的数据，N&lt;=20，每种物品都只有一件。<br />\n　　对于50%的数据，N&lt;=100，没有无限件的物品。<br />\n　　对于100%的数据，N&lt;=1000，M&lt;=100。</div>\n","gpid":"T655","lanqiaotitle":"小X的购物计划","memorylimit":"128.0MB","tid":"ADV-335","timelimit":"1.0s","title":"算法提高 小X的购物计划","src":"小X的暑假模拟赛"},{"checkpoint":"CCF计算机软件能力认证 201409","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给出一个n×m的方格图，现在要用如下L型的积木拼到这个图中，使得方格图正好被拼满，请问总共有多少种拼法。其中，方格图的每一个方格正好能放积木中的一块。积木可以任意旋转。<br />\n<img src=\"/RequireFile.do?fid=NemE2TeN\" width=\"106\" height=\"106\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含两个整数n, m，表示方格图的大小。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行，表示可以放的方案数，由于方案数可能很多，所以请输出方案数除以1,000,000,007的余数。</div><div class='pdsec'>样例输入</div><div class='pddata'>6 2</div><div class='pdsec'>样例输出</div><div class='pddata'>4</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　四种拼法如下图所示：<br />\n<img src=\"/RequireFile.do?fid=dgDJLgJ9\" width=\"454\" height=\"278\" /></div><div class='pdsec'>评测用例规模与约定</div><div class='pdcont'>　　在评测时将使用10个评测用例对你的程序进行评测。<br />\n　　评测用例1和2满足：1&lt;=n&lt;=30，m=2。<br />\n　　评测用例3和4满足：1&lt;=n, m&lt;=6。<br />\n　　评测用例5满足：1&lt;=n&lt;=100，1&lt;=m&lt;=6。<br />\n　　评测用例6和7满足：1&lt;=n&lt;=1000，1&lt;=m&lt;=6。<br />\n　　评测用例8、9和10满足：1&lt;=n&lt;=10^15，1&lt;=m&lt;=7。</div>\n","gpid":"T654","lanqiaotitle":"拼图","memorylimit":"256.0MB","tid":"ADV-334","timelimit":"3.0s","title":"算法提高 拼图","src":"CCF计算机软件能力认证 201409"},{"checkpoint":"","updatetime":"2020-04-03","content":"<div class='pdcont'>　　请编程输出一个菱形。输入为菱形中心到顶点的距离</div><div class='pdsec'>样例输入</div><div class='pddata'>2</div><div class='pdsec'>样例输出</div><div class='pddata'><img src=\"/RequireFile.do?fid=5TtmNfMf\" /></div>\n","gpid":"T653","lanqiaotitle":"菱形","memorylimit":"256.0MB","tid":"ADV-333","timelimit":"1.0s","title":"算法提高 菱形","src":""},{"checkpoint":"","updatetime":"2020-04-03","content":"<div class='pdcont'>　　某个抽卡游戏卡池抽出限定卡的概率为p，该游戏有一个“井”的机制，抽满k次卡后直接送这张限定卡。试求获得这张限定卡需要的期望抽卡次数。输入为一行，用空格隔开的p和k。输出为一行，即期望抽卡次数，取2位小数</div><div class='pdsec'>样例输入</div><div class='pddata'>0.005 250</div><div class='pdsec'>样例输出</div><div class='pddata'>142.88</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　第1次抽到的概率为0.005<br />\n　　第2次抽到的概率为(1-0.005)*0.005<br />\n　　第n次抽到的概率为(1-0.005)^(n-1)*0.005<br />\n　　第250抽到的概率为之前都没有抽到的概率，即(1-0.005)^249<br />\n　　最终结果<br />\n　　1*0.005+2*(1-0.005)*0.005+…+n*(1-0.005)^(n-1)*0.005+…+250*(1-0.005)^249=142.88</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　请使用double类型存储所有浮点数变量<br />\n　　对60%的测试点，保证k≤1000，<br />\n　　对100%的测试点，保证k≤1000000。<br />\n　　如果程序过于低效，在k较大时会因超时而错误。</div>\n","gpid":"T652","lanqiaotitle":"抽卡游戏","memorylimit":"256.0MB","tid":"ADV-332","timelimit":"1.0s","title":"算法提高 抽卡游戏","src":""},{"checkpoint":"构造","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　在一条东西走向无限延伸的道路上有一个机器人，该机器人需要去投递一份蛋糕。在这条道路上，每隔一英里就有一根电线杆。你需要控制机器人向东移动恰好N英里，并在那放下蛋糕。机器人移动的路线不必一直朝着目的地前进，只需要最终正确地投递蛋糕即可。<br />\n　　但不幸的是，机器人只有极其有限的内存，而且不具备高等的逻辑思维。因此，你必须在开始时就为机器人设计一段简单的程序，使得机器人照着程序执行后能够正确地投递蛋糕。这种程序由一条或多条规则组成，每条规则都告诉机器人在特定的情形下应该怎么做。同时，这些规则必须以下述的形式呈现：&lt;S&gt; &lt;M&gt; -&gt; &lt; 操作&gt;<br />\n　　这表明了当下列所有的条件都满足时：<br />\n　　1. 现在机器人正处于状态S。<br />\n　　2. 机器人现在所处电线杆上的标记为M。<br />\n　　那么机器人将会执行下列的操作之一：<br />\n　　1. 若&lt; 操作&gt; 的形式为”&lt;D&gt; &lt;NS&gt; &lt;NM&gt;”，其中D表示下一步移动的方向(’W’ 表示向西；’E’ 表示向东)，NS表示机器人的新状态，NM表示当前电线杆的新标记，则机器人将修改当前所处电线杆上的标记，改变自身状态，然后继续移动。<br />\n　　2. 若&lt; 操作&gt; 的形式为”R”（单个字母），则机器人将会在当前位置放下蛋糕，并结束任务。<br />\n　　若存在两条规则的S和M值完全相同，则机器人会变得不知所措。如果在任务执行中的某一时刻，机器人正处于状态X并且当前电线杆的标记为Y，但是程序中不存在任意一条规则同时满足S = X 和M = Y，则机器人同样会罢工。在所有的规则中，机器人的所有状态以及电线杆上的所有标记都必须保证绝对值不超过10<sup>6</sup>。现在假定机器人初始位置为原点，初始状态为0，并且所有电线杆上的标记初始时都是0。<br />\n　　现在给定N，请你为机器人编写一个合法的程序，使得机器人能够正确地投递蛋糕。与此同时，你为机器人编写的程序最多只能包含30 条规则，而且必须保证机器人能在1.5*10<sup>5</sup>步之内结束任务。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含一个非负整数N。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第一行包含一个正整数T，表示你为机器人编写的程序由T条规则组成。<br />\n　　接下来T行，每行均包含一条合法的规则，形式参见题面。<br />\n　　若存在多种合法方案，你只需输出任意一解。</div><div class='pdsec'>样例输入</div><div class='pddata'>样例1：<br />\n0<br />\n样例2：<br />\n4<br />\n样例3：<br />\n0</div><div class='pdsec'>样例输出</div><div class='pddata'>样例1：<br />\n1<br />\n0 0 -&gt; R<br />\n样例2：<br />\n5<br />\n0 0 -&gt; E 1 1<br />\n1 0 -&gt; E 2 1<br />\n2 0 -&gt; E 3 1<br />\n3 0 -&gt; E -1 1<br />\n-1 0 -&gt; R<br />\n样例3：<br />\n3<br />\n0 0 -&gt; E 1 1<br />\n0 1 -&gt; R<br />\n1 0 -&gt; W 0 1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于40% 的数据：0≤N≤500。<br />\n　　对于100% 的数据：0≤N≤5000。</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　在第一个样例中，机器人初始时状态为0，并且所处电线杆上标记为0，所以机器人直接应用第一条规则，放下蛋糕。<br />\n　　在第二个样例中，机器人共有5 种状态，分别为0、1、2、3 和-1。机器人依次执行了下列操作：<br />\n　　1. 将当前电线杆上的标记修改为1，转为状态1，并向东移动。<br />\n　　2. 将当前电线杆上的标记修改为1，转为状态2，并向东移动。<br />\n　　3. 将当前电线杆上的标记修改为1，转为状态3，并向东移动。<br />\n　　4. 将当前电线杆上的标记修改为1，转为状态-1，并向东移动。<br />\n　　5. 放下蛋糕。<br />\n　　在第三个样例中，机器人共有2 种状态，所执行的操作依次为：<br />\n　　1. 将当前电线杆上的标记修改为1，转为状态1，并向东移动。<br />\n　　2. 将当前电线杆上的标记修改为1，转为状态0，并向西移动。<br />\n　　3. 放下蛋糕。<br />\n　　注意：机器人前后两次处于状态0 时应用了不同的规则，因为机器人所处电线杆上的标记不同。</div>\n","gpid":"T651","lanqiaotitle":"Program within a Program","memorylimit":"256.0MB","tid":"ADV-331","timelimit":"1.0s","title":"算法提高 Program within a Program","src":"Google Code Jam 2011 World Finals C"},{"checkpoint":"二分，决策树","updatetime":"2020-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Kelly 对 n 种食物中的一种过敏，但她不确定是哪一种。所以呢，她想通过一些实验来确定。<br />\n<br />\n　　每次实验，Kelly 可以选取几种不同的食物然后全吃了，A天之后，她就可以知道是否有过敏反应，如果没有，就说明她对吃的那几种食物都不过敏。 如果她有过敏反应，她就需要等过敏反应褪去（这个过程从刚开始吃算起需要B天），<br />\n　　为了简化她的实验，任何一个实验必需等上一个实验完成（等A天或者B天）后开始，每次实验开始时，她可以根据前面的实验结果来选择这次要吃的食物集合。<br />\n　　Kelly 想知道在最坏情况下，最少要多少天可以找到那个过敏食物。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个正整数T，表示有T组测试数据。<br />\n　　接下来T行，每行3个正整数n,A,B。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　共T行，第i行用\"Case #i: ans\"表示第i组数据，ans是第i个数据的答案。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n4 5 7<br />\n8 1 1<br />\n1 23  32</div><div class='pdsec'>样例输出</div><div class='pddata'>Case #1: 12<br />\nCase #2: 3<br />\nCase #3: 0</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　第一组数据n = 4,A = 5,B = 7。一开始吃1,2。如果5天之后过敏，就再等2天，然后吃1。否则就吃3，然后等5天就行。<br />\n　　第二组数据，每次对半分。<br />\n　　第三组数据，不用实验了。</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　50%的数据满足：1&lt;=A&lt;=B&lt;=100<br />\n　　100%的数据满足：1&lt;=n&lt;=10^15,1&lt;=A&lt;=B&lt;=10^12,1&lt;=T&lt;=10。</div>\n","gpid":"T650","lanqiaotitle":"Allergy Testing","memorylimit":"256.0MB","tid":"ADV-330","timelimit":"1.0s","title":"算法提高 Allergy Testing","src":"Google Codejam World Final 2014 E"},{"checkpoint":"字符函数","updatetime":"2020-03-06","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　比较两个字符串s1和s2，输出：0表示s1与s2相等；1表示s1的字母序先于s2；-1表示s1的字母序后于s2</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入两行，第一行输入一个字符串1，第二行输入字符串2。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出比较的结果</div><div class='pdsec'>样例输入</div><div class='pddata'>abc<br />\nabd</div><div class='pdsec'>样例输出</div><div class='pddata'>1</div><div class='pdsec'>样例输入</div><div class='pddata'>English<br />\nEnglish</div><div class='pdsec'>样例输出</div><div class='pddata'>0</div><div class='pdsec'>样例输入</div><div class='pddata'>hello<br />\nha</div><div class='pdsec'>样例输出</div><div class='pddata'>-1</div>\n","gpid":"T602","lanqiaotitle":"字符串顺序比较","memorylimit":"256.0MB","tid":"ADV-313","timelimit":"1.0s","title":"算法提高 字符串顺序比较","src":""},{"checkpoint":"函数","updatetime":"2020-02-28","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编写函数将十进制整数按8进制输出，然后编写main函数验证该函数。例如输入12，则输出为：12=014，输入32，则输出32=040。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入一个整数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出这个整数的八进制形式。</div><div class='pdsec'>样例输入</div><div class='pddata'>12</div><div class='pdsec'>样例输出</div><div class='pddata'>014</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入的整数n&gt;=0.</div>\n","gpid":"T595","lanqiaotitle":"进制转换","memorylimit":"256.0MB","tid":"ADV-309","timelimit":"1.0s","title":"算法提高 进制转换","src":""},{"checkpoint":"递归","updatetime":"2020-02-28","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编写递归函数，将组成整数的所有数字逐个输出，每个数字后面加上一个减号“-”，例如对于整数123，该函数将输出1-2-3- 。编写主函数测试该递归函数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入一个整数n</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　如题目要求，把n的每个数字后面加一个减号”-“输出</div><div class='pdsec'>样例输入</div><div class='pddata'>一个满足题目要求的输入范例。<br />\n例：<br />\n123</div><div class='pdsec'>样例输出</div><div class='pddata'>与上面的样例输入对应的输出。<br />\n例：<br />\n1-2-3-</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入n&gt;0，必须使用递归调用来实现！</div>\n","gpid":"T594","lanqiaotitle":"递归输出","memorylimit":"512.0MB","tid":"ADV-308","timelimit":"1.0s","title":"算法提高 递归输出","src":""},{"checkpoint":"搜索","updatetime":"2020-02-28","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个N个点M条边的无向图G（点的编号从1至N），问是否存在一个不超过K个点的集合S，使得G中的每条边都至少有一个点在集合S中。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含一个整数T，表示数据的组数。<br />\n　　接下来T组数据中：每组输入的第一行包含三个整数n, m, k，分别表示图的点数，边数，集合点数的最大值。接下来m行，每行2个正整数x，y，表示编号为 x 的节点与编号为 y 的节点间有一条边相连。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组测试数据，若其存在解，则将解输出出来：第一行为一个整数t，表示所选点集的大小；第二行为t个整数，表示所选的点的编号。如果存在多组解，只要输出其中一种方案即可（会有special judge程序对你的输出进行检查）。<br />\n　　若该组测试数据不包含解，则输出一个数-1（一行）。</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n10 8 3<br />\n6 4<br />\n7 2<br />\n7 4<br />\n7 6<br />\n9 3<br />\n9 5<br />\n10 6<br />\n10 9<br />\n10 8 2<br />\n6 4<br />\n7 2<br />\n7 4<br />\n7 6<br />\n9 3<br />\n9 5<br />\n10 6<br />\n10 9</div><div class='pdsec'>样例输出</div><div class='pddata'>3<br />\n6 7 9<br />\n-1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于80%的数据，满足 0&lt;n&lt;=20, m&lt;=200, k&lt;=20。<br />\n　　所有的数据满足 0&lt;n&lt;=100, m&lt;=5000, k&lt;=20。</div>\n","gpid":"T593","lanqiaotitle":"vertex cover","memorylimit":"256.0MB","tid":"ADV-307","timelimit":"2.0s","title":"算法提高 vertex cover","src":""},{"checkpoint":"基本编程规范","updatetime":"2020-02-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编写程序，输入3个整数，求出最大数并输出。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入三个整数，用空格分开。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出三个数的最大值</div><div class='pdsec'>样例输入</div><div class='pddata'>5 3 4</div><div class='pdsec'>样例输出</div><div class='pddata'>5</div>\n","gpid":"T589","lanqiaotitle":"输出三个整数的最大数","memorylimit":"256.0MB","tid":"ADV-306","timelimit":"1.0s","title":"算法提高 输出三个整数的最大数","src":""},{"checkpoint":"按位与操作","updatetime":"2020-02-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输入[-128，127]内的整数，输出其二进制表示。提示，可使用按位与&amp;</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　例：7</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　例：00000111</div><div class='pdsec'>样例输入</div><div class='pddata'>一个满足题目要求的输入范例。<br />\n例：<br />\n7</div><div class='pdsec'>样例输出</div><div class='pddata'>与上面的样例输入对应的输出。<br />\n例：<br />\n00000111</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入数据中每一个数的范围。<br />\n　　例：0&lt;n,m&lt;100, 0&lt;=矩阵中的每个数&lt;=1000。</div>\n","gpid":"T588","lanqiaotitle":"输出二进制表示","memorylimit":"256.0MB","tid":"ADV-305","timelimit":"1.0s","title":"算法提高 输出二进制表示","src":""},{"checkpoint":"","updatetime":"2020-02-21","content":"<div class='pdcont'><b>【问题描述】</b><b></b><br />\n<br />\n　　给定一个n×m矩阵相乘，求它的转置。其中1≤n≤20，1≤m≤20，矩阵中的每个元素都在整数类型（4字节）的表示范围内。<br />\n<b>【输入格式】</b><b></b><br />\n　　第一行两个整数n和m；<br />\n　　第二行起，每行m个整数，共n行，表示n×m的矩阵。数据之间都用一个空格分隔。<br />\n<b>【输出格式】</b><b></b><br />\n<br />\n　　共m行，每行n个整数，数据间用一个空格分隔，表示转置后的矩阵。</div><div class='pdsec'>样例输入</div><div class='pddata'>2 4<br />\n34 76 -54 7<br />\n-4 5 23 9</div><div class='pdsec'>样例输出</div><div class='pddata'>34 -4<br />\n76 5<br />\n-54 23<br />\n7 9</div>\n","gpid":"T587","lanqiaotitle":"矩阵转置","memorylimit":"256.0MB","tid":"ADV-304","timelimit":"1.0s","title":"算法提高 矩阵转置","src":"RUC2013Final"},{"checkpoint":"数组","updatetime":"2020-02-14","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输入n个数，围成一圈，求连续m（m&lt;n）个数的和最大为多少？</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含两个整数n, m。第二行，共n个整数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出1行，包含一个整数，连续m个数之和的最大值。</div><div class='pdsec'>样例输入</div><div class='pddata'>10 3<br />\n9 10 1 5 9 3 2 6 7 4</div><div class='pdsec'>样例输出</div><div class='pddata'>23</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　0&lt;m&lt;n&lt;1000, -32768&lt;=输入的每个数&lt;=32767。</div>\n","gpid":"T582","lanqiaotitle":"数组求和","memorylimit":"256.0MB","tid":"ADV-303","timelimit":"1.0s","title":"算法提高 数组求和","src":""},{"checkpoint":"动态规划","updatetime":"2020-02-14","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　小D接到一项任务，要求他爬到一座n层大厦的顶端与神秘人物会面。这座大厦有一个神奇的特点，每层的高度都不一样，同时，小D也拥有一项特殊能力，可以一次向上跳跃一层或两层，但是这项能力无法连续使用。已知向上1高度消耗的时间为1，跳跃不消耗时间。由于事态紧急，小D想知道他最少需要多少时间到达顶层。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含一个整数n，代表楼的高度。<br />\n<br />\n　　接下来n行每行一个整数ai，代表i层的楼层高度（ai &lt;= 100）。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出1行，包含一个整数，表示所需的最短时间。</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n3<br />\n5<br />\n1<br />\n8<br />\n4</div><div class='pdsec'>样例输出</div><div class='pddata'>1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对20%的数据,n&lt;=10<br />\n　　对40%的数据,n&lt;=100<br />\n　　对60%的数据,n&lt;=5000<br />\n　　对100%的数据,n&lt;=10000</div>\n","gpid":"T581","lanqiaotitle":"秘密行动","memorylimit":"256.0MB","tid":"ADV-302","timelimit":"1.0s","title":"算法提高 秘密行动","src":""},{"checkpoint":"字符串","updatetime":"2020-02-07","content":"<div class='pdcont'><b>问题描述</b><br />\n　　编写一个程序，输入一个字符串，然后采用如下的规则对该字符串当中的每一个字符进行压缩：<br />\n　　(1) 如果该字符是空格，则保留该字符；<br />\n　　(2) 如果该字符是第一次出现或第三次出现或第六次出现，则保留该字符；<br />\n　　(3) 否则，删除该字符。<br />\n　　例如，若用户输入“occurrence”，经过压缩后，字符c的第二次出现被删除，第一和第三次出现仍保留；字符r和e的第二次出现均被删除，因此最后的结果为：“ocurenc”。<br />\n　　输入格式：输入只有一行，即原始字符串。<br />\n　　输出格式：输出只有一行，即经过压缩以后的字符串。<br />\n<b>输入输出样例</b></div><div class='pdsec'>样例输入</div><div class='pddata'>occurrence</div><div class='pdsec'>样例输出</div><div class='pddata'>ocurenc</div>\n","gpid":"T578","lanqiaotitle":"字符串压缩","memorylimit":"256.0MB","tid":"ADV-301","timelimit":"1.0s","title":"算法提高 字符串压缩","src":"谌卫军程序设计基础课程"},{"checkpoint":"","updatetime":"2020-02-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有一个字符串生成器，初始时生成的字符串为空串，它每次按照给定概率随机生成一个小写字母，加在当前已生成字符串的后面。<br />\n　　给定N个长度为L的字符串，每个字符串由小写字母组成。<br />\n　　如果在某个时候，发现每个给定字符串都在当前已生成的字符串中作为子串出现过，生成器就会停下来，将当前生成的字符串作为输出。<br />\n　　求输出字符串长度的期望值。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含一个正整数C，表示有C组数据。<br />\n　　每组数据的第一行包含三个正整数N, L, T (L&lt;=6, T&lt;=10)。其中T表示生成器仅会生成前T个小写字母。<br />\n　　每组数据的第2~N+1行，每行包含一个长度为L的字符串，每个字符串由前T个小写英文字母组成。<br />\n　　每组数据的第N+2行包含T个不超过10000的正整数，设第i个正整数为x，那么字符串生成器生成第i个小写字母的概率为x/10000。输入保证这T个正整数之和为10000。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　包含C行，依次对应每组数据。每行包含一个实数，表示输出字符串长度的期望值。</div><div class='pdsec'>样例输入</div><div class='pddata'>1<br />\n2 3 3<br />\naac<br />\nabb<br />\n3333 3333 3334</div><div class='pdsec'>样例输出</div><div class='pddata'>40.5060771264</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　本题共10个测试点。<br />\n　　对于30%的数据，N=1, C=1；<br />\n　　对于60%的数据，N&lt;=4, C&lt;=2；<br />\n　　对于100%的数据，N&lt;=8, C&lt;=20。<br />\n　　其中N=1的数据中存在一个测试点，只有你的答案和我们的答案相差小于1才为正确，并且这个测试点中L=3, T=3；<br />\n　　对于其他9个测试点，只有你的答案和我们的答案相差小于0.01才为正确。<br />\n　　数据保证正确答案不会超过5*10^6。</div>\n","gpid":"T577","lanqiaotitle":"字符串生成器","memorylimit":"64.0MB","tid":"ADV-300","timelimit":"1.0s","title":"算法提高 字符串生成器","src":"中国国家队清华集训 2013-2014 第三天"},{"checkpoint":"dp","updatetime":"2020-02-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　炫炫回了内蒙，肯定要吃羊肉啦，所有他家要宰羊吃。<br />\n　　炫炫家有N只羊，羊圈排成一排，标号1~N。炫炫每天吃掉一只羊（这食量！其实是放生啦），吃掉的羊的邻居会以为它被放生了，然后又会告诉他们的邻居，这样一直传播下去，除非某个邻居已经被“放生”了。每一天，所有知道某羊被“放生”了这个消息的羊都会很不满，如果不给他们巧克力的话，他们就会很造反，炫炫已经知道他要吃掉哪些羊，他可以任意安排吃的顺序，然后使巧克力的用量最小，请求出这个最小值。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　本题有多组数据，第一行为数据组数T。<br />\n　　对于每组数据<br />\n　　第一行：两个用空格隔开的整数：N和M，表示羊的数量和需要吃掉的数量<br />\n　　第二行：有M个数，表示要吃那些羊。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　T行，为每组数据的答案。</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n8 1<br />\n3<br />\n20 3<br />\n3 6 14</div><div class='pdsec'>样例输出</div><div class='pddata'>7<br />\n35</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　T=10<br />\n　　N&lt;=10000<br />\n　　M&lt;=100</div>\n","gpid":"T576","lanqiaotitle":"宰羊","memorylimit":"256.0MB","tid":"ADV-299","timelimit":"1.0s","title":"算法提高 宰羊","src":""},{"checkpoint":"动态规划","updatetime":"2020-02-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　我的某室友学过素描，墙上有n张他的作品。这些作品都是宽度为1，高度不定的矩形，从左到右排成一排，且底边在同一水平线上。<br />\n　　宿舍评比就要来了，为了及格，我们决定买不多于m块的矩形木板，把这些作品和谐掉。要求木板也从左到右排成一排，且底边与作品的底边在同一水平线上。<br />\n　　在能够把所有作品和谐掉的前提下，我们希望这些木板的面积和最小，问最小面积和。<br />\n<img width=\"281\" height=\"255\" src=\"/RequireFile.do?fid=FaHtNHE3\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行两个数n和m，表示作品数和木板数；<br />\n　　第二行n个数Hi，表示从左到右第i个作品的高度。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行一个数ans，表示答案。</div><div class='pdsec'>样例输入</div><div class='pddata'>5 2<br />\n4 2 3 5 4</div><div class='pdsec'>样例输出</div><div class='pddata'>22</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于30%的数据：1&lt;=n，m&lt;=10；<br />\n　　对于100%的数据：1&lt;=n，m&lt;=100，1&lt;=Hi&lt;=10000。</div>\n","gpid":"T575","lanqiaotitle":"和谐宿舍2","memorylimit":"256.0MB","tid":"ADV-298","timelimit":"1.0s","title":"算法提高 和谐宿舍2","src":""},{"checkpoint":"快速排序","updatetime":"2020-01-15","content":"<div class='pdcont'><b>问题描述</b><br />\n　　用递归来实现快速排序（quick sort）算法。快速排序算法的基本思路是：假设要对一个数组a进行排序，且a[0] = x。首先对数组中的元素进行调整，使x放在正确的位置上。同时，所有比x小的数都位于它的左边，所有比x大的数都位于它的右边。然后对于左、右两段区域，递归地调用快速排序算法来进行排序。<br />\n　　输入格式：输入只有一行，包括若干个整数（不超过10个），以0结尾。<br />\n　　输出格式：输出只有一行，即排序以后的结果（不包括末尾的0）。<br />\n<b>输入输出样例</b></div><div class='pdsec'>样例输入</div><div class='pddata'>5 2 6 1 7 3 4 0</div><div class='pdsec'>样例输出</div><div class='pddata'>1 2 3 4 5 6 7</div>\n","gpid":"T571","lanqiaotitle":"快速排序","memorylimit":"256.0MB","tid":"ADV-297","timelimit":"1.0s","title":"算法提高 快速排序","src":"谌卫军程序设计课程"},{"checkpoint":"环形链表","updatetime":"2020-01-15","content":"<div class='pdcont'><b>问题描述</b><br />\n　　学校给高一（三）班分配了一个名额，去参加奥运会的开幕式。每个人都争着要去，可是名额只有一个，怎么办？班长想出了一个办法，让班上的所有同学（共有n个同学）围成一圈，按照顺时针方向进行编号。然后随便选定一个数m，并且从1号同学开始按照顺时针方向依次报数，1, 2, …, m，凡报到m的同学，都要主动退出圈子。然后不停地按顺时针方向逐一让报出m者出圈，最后剩下的那个人就是去参加开幕式的人。<br />\n　　要求：用环形链表的方法来求解。所谓环形链表，即对于链表尾结点，其next指针又指向了链表的首结点。基本思路是先创建一个环形链表，模拟众同学围成一圈的情形。然后进入循环淘汰环节，模拟从1到m报数，每次让一位同学（结点）退出圈子。<br />\n　　输入格式：输入只有一行，包括两个整数n和m，其中n和 m的含义如上所述。<br />\n　　输出格式：输出只有一个整数，即参加开幕式的那个人的编号。<br />\n<b>输入输出样例</b></div><div class='pdsec'>样例输入</div><div class='pddata'>8 3</div><div class='pdsec'>样例输出</div><div class='pddata'>7</div>\n","gpid":"T570","lanqiaotitle":"奥运会开幕式","memorylimit":"256.0MB","tid":"ADV-296","timelimit":"1.0s","title":"算法提高 奥运会开幕式","src":"谌卫军程序设计基础课程"},{"checkpoint":"","updatetime":"2020-01-15","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　对于一个n位的十进制数x（A<sub>n</sub>A<sub>n-1</sub>……A<sub>1</sub>），我们定义它的权重为：<br />\n　　F(x)=A<sub>n</sub>*2<sup>n-1</sup>+A<sub>n-1</sub>*2<sup>n-2</sup>+……+A<sub>1</sub>*2<sup>0</sup><br />\n　　现在，给你两个十进制数A和B，请计算出在闭区间[0, B]之中，有多少个数x的权重不大于A的权重，即F(x)&lt;=F(A)。由于答案可能很大，你只需要输出答案对1000000007（10<sup>9</sup> + 7）取模的结果即可。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个正整数T，表示测例的个数。<br />\n　　随后T行，每行描述一个测例，包含两个非负整数A、B，之间用空格隔开。含义见问题描述。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每个测例，单独输出一行”Case #t: ans”，其中t表示测例编号，从1开始递增，ans表示该组测例的答案（对1000000007取模后的结果）。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n0 100<br />\n1 10<br />\n5 100</div><div class='pdsec'>样例输出</div><div class='pddata'>Case #1: 1<br />\nCase #2: 2<br />\nCase #3: 13</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　对于Case #3，符合条件的数有0, 1, 2, 3, 4, 5, 10, 11, 12, 13, 20, 21, 100，共13个。<br />\n<br />\n　　//样例描述有修改，请注意！</div><div class='pdsec'>数据规模及约定</div><div class='pdcont'>　　对于20%的数据，A, B &lt;= 10<sup>9</sup>；<br />\n　　对于30%的数据，A, B &lt;= 10<sup>18</sup>；<br />\n<br />\n　　对于100%的数据，A,B &lt;= 10<sup>200</sup>，T&lt;=5。</div>\n","gpid":"T569","lanqiaotitle":"fx","memorylimit":"256.0MB","tid":"ADV-295","timelimit":"2.0s","title":"算法提高 fx","src":"中国国家队清华集训 2013-2014 第四天"},{"checkpoint":"递归 图遍历","updatetime":"2020-01-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　小袁非常喜欢滑雪， 因为滑雪很刺激。为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。 小袁想知道在某个区域中最长的一个滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。如下：<br />\n<br />\n<img src=\"/RequireFile.do?fid=nyJ35q4A\" width=\"320\" height=\"236\" /><br />\n　　一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-...-3-2-1更长。事实上，这是最长的一条。<br />\n　　你的任务就是找到最长的一条滑坡，并且将滑坡的长度输出。 滑坡的长度定义为经过点的个数，例如滑坡24-17-16-1的长度是4。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行表示区域的行数R和列数C(1&lt;=R, C&lt;=10)。下面是R行，每行有C个整数，依次是每个点的高度h（0&lt;= h &lt;=10000）。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　只有一行，为一个整数，即最长区域的长度。</div><div class='pdsec'>样例输入</div><div class='pddata'>5 5<br />\n1 2 3 4 5<br />\n16 17 18 19 6<br />\n15 24 25 20 7<br />\n14 23 22 21 8<br />\n13 12 11 10 9</div><div class='pdsec'>样例输出</div><div class='pddata'>25</div>\n","gpid":"T564","lanqiaotitle":"最长滑雪道","memorylimit":"256.0MB","tid":"ADV-294","timelimit":"1.0s","title":"算法提高 最长滑雪道","src":""},{"checkpoint":"遍历图 动态规划 递归","updatetime":"2020-01-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　刷微博，编程序。如下图所示，@北京发布 提出了如下“头脑震荡”问题。对此问题做一般化描述：<br />\n　　有n阶方阵，从矩阵的左下角元素为起点，从行或列（水平或垂直）两个方向上移动，直到右上角。求出有多少条路径可以使得经过的元素累加值最大，最大值是多少。<br />\n<img src=\"/RequireFile.do?fid=gL3HM39e\" width=\"512\" height=\"319\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　共有n+1行。<br />\n　　第一行整数n，表示矩阵的阶数，2&lt;=n&lt;=10。<br />\n　　第二行起，每行n个整数，以空格分隔，共n行。。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行，两个空格分隔的数，第一个表示最大值路径的条数，第二个表示最大值。</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n4 5 4 5 6<br />\n2 6 5 4 6<br />\n2 6 6 5 2<br />\n4 5 2 2 5<br />\n5 2 5 6 4</div><div class='pdsec'>样例输出</div><div class='pddata'>3 47</div>\n","gpid":"T563","lanqiaotitle":"最大值路径","memorylimit":"256.0MB","tid":"ADV-293","timelimit":"1.0s","title":"算法提高 最大值路径","src":""},{"checkpoint":"递归","updatetime":"2019-12-31","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　//据说很多人的题目会有一大堆废话，本傻×就不在这里废话了。<br />\n　　给定一个N×N的矩阵A，求|A|。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个正整数N。<br />\n　　接下来N行，每行N个整数，第i行第j个数字表示A[i][j]。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行，输出|A|。</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n1 2<br />\n3 4</div><div class='pdsec'>样例输出</div><div class='pddata'>-2</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　0&lt;N≤6<br />\n　　-10≤A[i][j]≤10</div>\n","gpid":"T559","lanqiaotitle":"计算行列式","memorylimit":"256.0MB","tid":"ADV-292","timelimit":"1.0s","title":"算法提高 计算行列式","src":"liouzhou_101"},{"checkpoint":"结构体","updatetime":"2019-12-31","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给出n个学生的成绩，将这些学生按成绩排序，排序规则：总分高的在前；总分相同，数学成绩高的在前；总分与数学相同，英语高的在前；总分数学英语都相同，学号小的在前</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个正整数n，表示学生人数<br />\n　　接下来n行每行3个0~100的整数，第i行表示学号为i的学生的数学、英语、语文成绩</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出n行，每行表示一个学生的数学成绩、英语成绩、语文成绩、学号<br />\n　　按排序后的顺序输出</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n1 2 3<br />\n2 3 4</div><div class='pdsec'>样例输出</div><div class='pddata'>2 3 4 2<br />\n1 2 3 1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n≤100</div>\n","gpid":"T558","lanqiaotitle":"成绩排序2","memorylimit":"256.0MB","tid":"ADV-291","timelimit":"1.0s","title":"算法提高 成绩排序2","src":""},{"checkpoint":"结构体","updatetime":"2019-12-31","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给出n个学生的成绩，将这些学生按成绩排序，<br />\n　　排序规则，优先考虑数学成绩，高的在前；数学相同，英语高的在前；数学英语都相同，语文高的在前；三门都相同，学号小的在前</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个正整数n，表示学生人数<br />\n　　接下来n行每行3个0~100的整数，第i行表示学号为i的学生的数学、英语、语文成绩</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出n行，每行表示一个学生的数学成绩、英语成绩、语文成绩、学号<br />\n　　按排序后的顺序输出</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n1 2 3<br />\n2 3 4</div><div class='pdsec'>样例输出</div><div class='pddata'>2 3 4 2<br />\n1 2 3 1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n≤100</div>\n","gpid":"T557","lanqiaotitle":"成绩排序","memorylimit":"256.0MB","tid":"ADV-290","timelimit":"1.0s","title":"算法提高 成绩排序","src":""},{"checkpoint":"冒泡排序","updatetime":"2019-12-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　一年一度的双十一又来了，某网购网站又开始了半价销售的活动。<br />\n　　小G打算在今年的双十一里尽情地购物，以享受购买的极度快感，她已经列好了她想买的物品的列表。<br />\n　　当然小G并不是出身富贵家庭，所以她网银里的钱只是一个有限的整数S（单位：元）。<br />\n　　这次抢购她打算遵循这三个原则选择每一个物品：<br />\n　　1.先买能“赚”最多的；<br />\n　　2.在“赚”一样多的情况下，先买最便宜的（这样买的东西就可能更多了）；<br />\n　　3.在前两条里都判断不了购买顺序的话，先购买在列表里靠前的。<br />\n　　（由于网站里还是有一部分商品并没有打五折，所以2的情况（“赚”的钱数为0）是完全可能发生的）<br />\n　　现在，在双十一的这一天，你要帮小G编写一个程序，来看看她应该去买她列表里的哪些物品。（总价格不要超过S哦）<br />\n　　要是帮她写好这个程序的话，或许你能在光棍节这一天里赢得她的芳心哦~</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入共N+1行。<br />\n　　第一行包含两个整数S和N，S表示小G的可用金额，N表示她看上的物品个数。<br />\n　　接下来N行，对应每一个物品，每行有两个整数a和b，a是物品的原价（单位：元），b为0或1，若b为0，则此物品不半价，若b为1，则此物品半价销售。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出共一行，为小G要买的物品序号（从1开始），用空格隔开，注意按序号从小到大输出。<br />\n　　若小G一件都买不了，则输出0.</div><div class='pdsec'>样例输入</div><div class='pddata'>10 3<br />\n5 0<br />\n4 0<br />\n10 1</div><div class='pdsec'>样例输出</div><div class='pddata'>2 3</div><div class='pdsec'>样例输入</div><div class='pddata'>10 3<br />\n11 0<br />\n21 1<br />\n100 1</div><div class='pdsec'>样例输出</div><div class='pddata'>0</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　0&lt;S&lt;=10000,0&lt;N&lt;=1000,每一个a和b满足0&lt;a&lt;=1000且b=0或1。</div>\n","gpid":"T552","lanqiaotitle":"双十一抢购","memorylimit":"256.0MB","tid":"ADV-289","timelimit":"1.0s","title":"算法提高 双十一抢购","src":""},{"checkpoint":"结构体排序","updatetime":"2019-12-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　小明刚经过了一次数学考试，老师由于忙碌忘记排名了，于是老师把这个光荣的任务交给了小明，小明则找到了聪明的你，希望你能帮他解决这个问题。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含一个正整数N，表示有个人参加了考试。接下来N行，每行有一个字符串和一个正整数，分别表示人名和对应的成绩，用一个空格分隔。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一共有N行，每行一个字符串，第i行的字符串表示成绩从高到低排在第i位的人的名字，若分数一样则按人名的字典序顺序从小到大。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\naaa 47<br />\nbbb 90<br />\nccc 70</div><div class='pdsec'>样例输出</div><div class='pddata'>bbb<br />\nccc<br />\naaa 【数据规模和约定】<br />\n人数&lt;=100,分数&lt;=100,人名仅包含小写字母。</div>\n","gpid":"T551","lanqiaotitle":"成绩排名","memorylimit":"256.0MB","tid":"ADV-288","timelimit":"1.0s","title":"算法提高 成绩排名","src":""},{"checkpoint":"循环","updatetime":"2019-12-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　这个问题是个简单的与数论有关的题目，看起来似乎是“求正整数的所有质因子”，但实际上并不完全是这样。<br />\n<br />\n　　本题中需要定义以下几个概念：<br />\n　　1．  Monday-Saturday数<br />\n　　对于一个正整数N，如果它除以7得到的余数是1或6，则可以写成N=7k+{1,6}的形式。更形象的，我们把这样的N称作“Monday-Saturday数”，简称“MS数”。<br />\n　　2．  Monday-Saturday因子<br />\n　　如果对于两个MS数a,b，若存在一个MS数x，使得ax=b，那么就称a是b的一个“Monday-Saturday因子”，简称“MS因子”。<br />\n　　3．  Monday-Saturday质数<br />\n　　如果对于MS数a，满足a&gt;1且除了1和a之外a没有其他的MS因子，那么称a是一个“Monday-Saturday质数”，简称“MS质数”。<br />\n　　注：对于传统意义上的质数，若它是一个MS数，则它一定是一个MS质数。但反之不必成立，例如27，它是一个MS质数但不是传统意义上的质数。<br />\n　　4．  Monday-Saturday质因子<br />\n　　如果对于两个MS数a,b，若满足a是b的MS因子且a是一个MS质数，那么称a是b的一个“Monday-Saturday质因子”。<br />\n　　例如：27是216的一个MS质因子（216=27*8）。<br />\n<br />\n　　问题就是，给定一个MS数N，求其所有的Monday-Saturday质因子。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　每个输入数据包含多行，每行一个整数N（保证N一定是MS数，1＜N＜300000）。<br />\n　　输入的最后一行是一个整数1（对于这一行，你不必输出任何信息）。<br />\n　　每个输入数据不超过100行。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每个N输出一行，表示N的所有Monday-Saturday质因子，按从小到大的顺序输出。格式形如“N: p1 p2 p3 …… pk”，注意行末无多余空格。<br />\n<br />\n<b>【样例输入】</b><br />\n　　205920<br />\n　　262144<br />\n　　262200<br />\n　　279936<br />\n　　299998<br />\n　　1<br />\n<b> </b><br />\n<b>【样例输出】</b><br />\n　　205920: 6 8 13 15 20 22 55 99<br />\n　　262144: 8<br />\n　　262200: 6 8 15 20 50 57 69 76 92 190 230 475 575 874 2185<br />\n　　279936: 6 8 27<br />\n　　299998: 299998</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1＜N＜300000，每个输入数据不超过100行。</div>\n","gpid":"T546","lanqiaotitle":"Monday-Saturday质因子","memorylimit":"256.0MB","tid":"ADV-287","timelimit":"1.0s","title":"算法提高 Monday-Saturday质因子","src":""},{"checkpoint":"插头dp 状压dp 动态规划","updatetime":"2019-12-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Joe，一个前冠军程序员，终于买了农场。不，不，他过得很好；他只是利用了他丰富的编程比赛奖金购买了他的祖传农场。<br />\n　　他希望退休，养奶牛度过余生(因为一些原因，他现在认为自己是一个奶牛专家)。<br />\n　　不幸的是，农夫Joe简单的田园梦也无法实现。他的农场所在气候寒冷--对于奶牛太冷了！<br />\n　　更糟糕的是，气候很干燥不适合种植庄稼。Joe现在意识到他必须为自己的农场制定一个灌溉方案。这个方案将使一条河穿过农场里的一条蜿蜒的渠道。由于作物在渠道旁能茁壮成长，所以渠道越长越好。<br />\n　　他的田地是一个被划分成格子的狭长的矩形。一些格子有泥土，用\".\"表示，或者不能移动的石头，用\"#\"表示。灌溉渠道是一个一格宽的从田地左上角进入从右下角流出。石头的格子不能通过。当然，它不能够自交，即使是在角上碰到也不行(这样水会渗透并采取更短的路径)。<br />\n　　下面两种情况表示渠道自交：<br />\n　　CCCC   C...<br />\n　　C.C.C   CCCC<br />\n　　CCC.C   ..CC<br />\n　　...CC   ..C.<br />\n　　...C.   ..C.<br />\n　　...CC   ..CC<br />\n　　（为什么不能等宽，大家自行放到等宽字体中看吧）<br />\n　　不幸的是，Joe那最好的编程能力已经被他抛之脑后了。他有一个很简单的解决方法但是太耗时了。你能帮他找到这个渠道的最佳位置吗？</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含多组数据。<br />\n　　每个测试数据包含一个r表示行数(2&lt;=r&lt;=20)和一个c表示列数(2&lt;=c&lt;=9)。接着r行c列的一个矩阵表示他的田地。<br />\n　　由0 0结束输入</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每一组数据。<br />\n　　输出数据序号。<br />\n　　接下来r行表示一种设置渠道的方案，保证有解。<br />\n　　每组数据后输出一个空行。<br />\n　　参照样例。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 3<br />\n.#.<br />\n...<br />\n.#.<br />\n6 7<br />\n.......<br />\n.......<br />\n.......<br />\n....#..<br />\n.......<br />\n.#.....<br />\n0 0</div><div class='pdsec'>样例输出</div><div class='pddata'>Case 1:<br />\nC#.<br />\nCCC<br />\n.#C<br />\n<br />\nCase 2:<br />\nCCCCCCC<br />\n......C<br />\nCCCCCCC<br />\nC...#..<br />\nCCC.CCC<br />\n.#CCC.C</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　见输入格式。</div>\n","gpid":"T545","lanqiaotitle":"Channel","memorylimit":"256.0MB","tid":"ADV-286","timelimit":"1.0s","title":"算法提高 Channel","src":"ACM/ICPC World Finals 2010 E"},{"checkpoint":"for if","updatetime":"2019-12-10","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定正方形边长width，如图按规律输出层层嵌套的正方形图形。<br />\n　　注意，为让选手方便观看，下图和样例输出均使用“_”代替空格，请选手输出的时候使用空格而不是“_”。<br />\n<br />\n　　width=6：<br />\n<br />\n　　******<br />\n<br />\n　　*____*<br />\n<br />\n　　*_**_*<br />\n<br />\n　　*_**_*<br />\n<br />\n　　*____*<br />\n<br />\n　　******</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　仅一行一个整数width。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　按规律输出图形，不要输出多余空格。</div><div class='pdsec'>样例输入</div><div class='pddata'>10</div><div class='pdsec'>样例输出</div><div class='pddata'>**********<br />\n*________*<br />\n*_******_*<br />\n*_*____*_*<br />\n*_*_**_*_*<br />\n*_*_**_*_*<br />\n*_*____*_*<br />\n*_******_*<br />\n*________*<br />\n**********</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　width满足width=4n+2，n为正整数。<br />\n<br />\n　　且width&lt;=50。</div>\n","gpid":"T540","lanqiaotitle":"套正方形","memorylimit":"256.0MB","tid":"ADV-285","timelimit":"1.0s","title":"算法提高 套正方形","src":"程序设计基础 2013年秋 期中考试"},{"checkpoint":"模拟、eps","updatetime":"2019-12-10","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输入A,B两人的学分获取情况，输出两人GPA之差。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含一个整数n表示A的课程数，以下n行每行Si,Ci分别表示第i个课程的学分与A的表现。<br />\n　　GPA=&Sigma;(Si*Ci) / &Sigma;(Si)。<br />\n　　特殊地，如果Ci是'P'或者'N'（对应于通过与不通过），则第i个课程不记入GPA的计算（即当其不存在）。<br />\n　　A读入结束后读入B，B的输入格式与A相同。<br />\n　　保证2人的&Sigma;(Si)非零</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出A的GPA - B的GPA的值，保留2位小数（四舍五入）<br />\n　　Tips：当A和B的分数相近时输出0.00。</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n1 10<br />\n2 N<br />\n2<br />\n1 10<br />\n1 5</div><div class='pdsec'>样例输出</div><div class='pddata'>2.50</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入的所有数字均为不超过100的非负整数</div>\n","gpid":"T539","lanqiaotitle":"GPA","memorylimit":"256.0MB","tid":"ADV-284","timelimit":"1.0s","title":"算法提高 GPA","src":""},{"checkpoint":"数组 循环","updatetime":"2019-12-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　在矩形的世界里任何事物都是矩形的，矩形的枪靶，甚至矩形的子弹。现在给你一张N*M的枪靶，同时告诉你子弹的大小为(2l+1)*(2r+1)。读入一张01的图每个点的01状态分别表示这个点是否被子弹的中心击中（1表示被击中，0则没有）一旦一个点被子弹的中心击中，那么以这个点为中心 (2l+1)*(2r+1) 范围内靶子上的点都会被击毁。要求输出最终靶子的状态。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行为N，M，L,R表示靶子的大小，以及子弹的大小。<br />\n　　下面读入一个N*M的01矩阵表示每个点是否被子弹的中心击中</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　N*M的01矩阵表示靶子上的每个点是否被破坏掉</div><div class='pdsec'>样例输入</div><div class='pddata'>4 4 1 1<br />\n1000<br />\n0000<br />\n0000<br />\n0010</div><div class='pdsec'>样例输出</div><div class='pddata'>1100<br />\n1100<br />\n0111<br />\n0111</div><div class='pdsec'>样例输入</div><div class='pddata'>7 4 1 1<br />\n1000<br />\n0000<br />\n0010<br />\n<br />\n0000<br />\n0000<br />\n0000<br />\n0100</div><div class='pdsec'>样例输出</div><div class='pddata'>1100<br />\n1111<br />\n0111<br />\n0111<br />\n0000<br />\n1110<br />\n1110</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　N,M&lt;=600,l,r&lt;=5</div>\n","gpid":"T534","lanqiaotitle":"矩形靶","memorylimit":"256.0MB","tid":"ADV-283","timelimit":"1.0s","title":"算法提高 矩形靶","src":""},{"checkpoint":"最小生产树","updatetime":"2019-12-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　太平洋岛网公司（PLN）已经瞄向了太平洋中的一些群岛。这些群岛没有快捷的互联网连接。PLN计划向群岛提供互联网服务，以开发这个太平洋中潜在的市场。每组群岛的核心岛屿已经被深海电缆连入互联网。接下来需要做的事把其余岛屿和核心岛屿连接起来。<br />\n　　对于每个岛，将给出它的路由器的位置和居民数量。PIN将会在群岛中连接多条电缆，每条电缆连接两座岛的路由器，最后使得每座岛都通过一条电缆路径与核心岛屿相连。PIN希望总的电缆长度最小。这样也许会有多个最佳方案。PIN并不关心哪个最佳网络方案被采纳。<br />\n　　PIN对于新顾客连上互联网的平均时间很感兴趣，我们不妨假设：所有连接网络的电线都是同时开始建设的。电缆铺设效率为一千米每天。因此，短的电缆会比长的更快铺好。<br />\n　　当一座岛到核心岛屿的电缆连通时，这座岛就接入了互联网。PIN希望你告诉他所有居民连入互联网的平均时间。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入数据包含多组群岛的描述。每组描述的第一行是一个正整数n，表示群岛的数量(n ≤ 50)。接下来n行每行包含三个整数xi,yi,mi，表示路由器的位置（xi,yi），以及岛上居民数量mi (mi &gt; 0)。坐标以千米为单位。序列中的第一座岛是核心岛屿。<br />\n　　输入数据最后以一个整数0结束。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于测试点中的每组群岛，输出该组的序列号和居民连入互联网的平均天数。保留两位小数。具体   格式如样例输出所示。<br />\n　　每一个测试点输出后打印一个空行。</div><div class='pdsec'>样例输入</div><div class='pddata'>7<br />\n11 12 2500<br />\n14 17 1500<br />\n9 9 750<br />\n7 15 600<br />\n19 16 500<br />\n8 18 400<br />\n15 21 250<br />\n0</div><div class='pdsec'>样例输出</div><div class='pddata'>Island Group: 1  Average 3.20</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入数据中所有数字保证不超过2^31-1</div>\n","gpid":"T533","lanqiaotitle":"Island Hopping","memorylimit":"256.0MB","tid":"ADV-282","timelimit":"1.0s","title":"算法提高 Island Hopping","src":"ACM/ICPC World Finals 2002 E"},{"checkpoint":"数组练习题","updatetime":"2019-11-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　小明最近刚刚学习了矩阵乘法，但是他计算的速度太慢，于是他希望你能帮他写一个矩阵乘法的运算器。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含三个正整数N,M,K，表示一个N*M的矩阵乘以一个M*K的矩阵。接下来N行，每行M个整数，表示第一个矩阵。再接下来的M行，每行K个整数，表示第二个矩阵。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出有N行，每行K个整数，表示矩阵乘法的结果。</div><div class='pdsec'>样例输入</div><div class='pddata'>2 1 3<br />\n1<br />\n2<br />\n1 2 3</div><div class='pdsec'>样例输出</div><div class='pddata'>1 2 3<br />\n2 4 6</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　0&lt;N,M,K&lt;=100, 0&lt;=矩阵中的每个数&lt;=1000。</div>\n","gpid":"T530","lanqiaotitle":"矩阵乘法","memorylimit":"256.0MB","tid":"ADV-279","timelimit":"1.0s","title":"算法提高 矩阵乘法","src":""},{"checkpoint":"模拟","updatetime":"2019-11-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　X市正在进行歌唱比赛，请你写一个程序计算得分。<br />\n<br />\n　　每名选手从1到N编号，每名选手的综合成绩由以下几个部分组成：<br />\n<br />\n　　1.歌唱得分占70%<br />\n<br />\n　　2.才艺展示得分占20%<br />\n<br />\n　　3.观众投票得分占10%<br />\n<br />\n　　4.不超过五分的特殊加分（如果总分超过100分则记为100）</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个整数N，表示选手人数<br />\n<br />\n　　接下来N行，每行四个整数，分别表示歌唱得分，才艺得分，投票得分和加分。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出N行，每行一个数，表示得分（保留一位小数）</div><div class='pdsec'>样例输入</div><div class='pddata'>6<br />\n62 50 60 1<br />\n77 71 85 3<br />\n98 79 98 5<br />\n75 62 60 0<br />\n99 72 68 4<br />\n82 88 89 2</div><div class='pdsec'>样例输出</div><div class='pddata'>60.4<br />\n79.6<br />\n99.2<br />\n70.9<br />\n94.5<br />\n85.9</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　N &lt;= 10000;</div>\n","gpid":"T529","lanqiaotitle":"歌唱比赛","memorylimit":"256.0MB","tid":"ADV-278","timelimit":"1.0s","title":"算法提高 歌唱比赛","src":""},{"checkpoint":"动态规划","updatetime":"2019-11-27","content":"<div class='pdcont'><img width=\"260\" height=\"196\" src=\"/RequireFile.do?fid=74bgAymE\" /></div><div class='pdsec'>问题描述</div><div class='pdcont'>　　温晨是一艘救援艇的船长。他的一项重要任务是每天访问一趟岛屿群以便检查是否一切正常。温船长从最西边的小岛开始，寻找一条路径去最东边的岛屿，途中访问一些岛屿，之后再找寻另一条路径从最东边的岛屿回到出发点，途中访问剩下的岛屿。在每一条路径中温船长必须一直向东（在第一条路径中）或一直向西（在第二条路径中），但是可以向北或南移动任意远距离使其能达到下一个岛屿。唯一的问题是有两个特殊岛屿，温船长能在那里得到供给他的船的油，所以他必须在不同的路径中访问这两个岛（在第一条路径中访问其中一个岛，在另一条路径中访问剩下的一个岛）。图中显示了两个用粉红色标出的特殊岛屿（1和3）以及一条温船长可能采取的可行路径。<br />\n　　当给定每座岛的坐标以及两座特殊岛屿编号时，计算用两条路径访问所有岛屿的最短路径长度。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含若干测试数据。每个数据第一行为3个整数n(4&lt;=n&lt;=100),b1和b2(0&lt;b1,b2&lt;n-1并且b1不等于b2)，n代表岛屿数(从0到n-1编号)而b1和b2代表两个特殊岛屿的编号。接下来有n行，每行包含整数x和y代表每个岛的坐标(0&lt;=x,y&lt;=2000)，从0号岛开始。没有两座岛有相同的x坐标并且岛屿按从西向东的顺序（即从最小的x坐标到最大的x坐标）。<br />\n　　最后一组数据之后由3个0代表结束。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每个数据，输出两行。第一行包含数据编号以及温船长访问所有岛屿所需的最小航程，四舍五入至小数点后两位。第二行包含一个有空格隔开的所需要访问的岛屿编号列表，以0和1开始，并以0结束。每组数据都有唯一解。按样例格式输出。</div><div class='pdsec'>样例输入</div><div class='pddata'>5 1 3<br />\n1 3<br />\n3 4<br />\n4 1<br />\n7 5<br />\n8 3<br />\n5 3 2<br />\n0 10<br />\n3 14<br />\n4 7<br />\n7 10<br />\n8 12<br />\n0 0 0</div><div class='pdsec'>样例输出</div><div class='pddata'>Case 1: 18.18<br />\n0 1 4 3 2 0<br />\nCase 2: 24.30<br />\n0 1 3 4 2 0</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　4 &lt;= n &lt;=100<br />\n　　0 &lt; b1, b2 &lt; n-1 and b1!=b2<br />\n　　0 &lt;=x, y &lt;=2000</div>\n","gpid":"T528","lanqiaotitle":"The Islands","memorylimit":"256.0MB","tid":"ADV-277","timelimit":"1.0s","title":"算法提高 The Islands","src":"ACM/ICPC World Finals 2010 G"},{"checkpoint":"几何","updatetime":"2019-11-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　你需要帮助一个修屋顶工人估算装修屋顶所需要的材料数量，以保护屋顶的表面不被阳光晒伤。所需要的材根据从正上方俯瞰说能看到的屋顶的面积计算。<br />\n　　屋顶的几何形状是由围住屋顶平面的三角形的顶点开确定的。一个顶点坐标的X和Y是由屋顶的俯瞰图确定的，而Z坐标是这个顶点高于地面的高度，假设地面时平坦的。例如，端点在(10,10,10)和(10,20,10)的线段与地面平行，该线段的长度是10个长度单位。端点在（10,10,10)和(10,18,16)的线段从地面上10个高度单位斜向上16个高度单位；从高处俯瞰它是8个长度单位，但实际是10个长度单位。<br />\n　　在一个屋顶的俯瞰图里，一个较高区域有时候会遮挡一个比较低的区域。只有俯瞰直接可见的屋顶部分才会计入总的面积。例如，假设你俯瞰一幢两层的建筑物，第二层比第一层小，显然，第二层的屋顶面积要计入总面积，而第一层屋顶的可视面积不包括位于第二层正下方被遮挡的部分。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包括若干组描述屋顶的测试用例。每组测试用例的第一行给出整数V（1&lt;=V&lt;=300)和T(1&lt;=T&lt;=1000)，分别表示顶点的数量和三角形的数量；接下来V行<br />\n　　每行是一个顶点的坐标x,y,z；然后分别给出T个三角形的描述，每个三角形给出3个顶点的标号，表示一个屋顶三角形的3个顶点。顶点按照输入中出现的顺序，从1开始编号。<br />\n　　所有坐标都是不大于1的正整数。三角形不会出现3点一线的情况，并且任意两个三角形的部分是独立的，也就是说，这些三角形可能会邻接，但不会重叠或相交。<br />\n　　最后以两个0作为输入结束。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对每一个数据，输出一行，先是数据组号，然后是可见区域，每个组输出后面有一个空行。（详见样例，最后有空行）</div><div class='pdsec'>样例输入</div><div class='pddata'>6 2<br />\n10 10 10<br />\n10 20 10<br />\n20 10 10<br />\n10 10 20<br />\n10 20 20<br />\n20 20 20<br />\n1 2 3<br />\n4 5 6<br />\n3 1<br />\n10 10 10<br />\n10 18 16<br />\n20 10 10<br />\n1 2 3<br />\n0 0</div><div class='pdsec'>样例输出</div><div class='pddata'>Case 1: 75.00<br />\n<br />\nCase 2: 50.00<pre class='pddata'>\n<br />\n</pre>\n</div>\n","gpid":"T527","lanqiaotitle":"Raising the Roof","memorylimit":"256.0MB","tid":"ADV-276","timelimit":"8.0s","title":"算法提高 Raising the Roof","src":"ACM/ICPC World Finals 2007H"},{"checkpoint":"乘法 循环","updatetime":"2019-11-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有一天，JOE终于不能忍受计算a^b%c这种平凡的运算了。所以他决定要求你写一个程序，计算a^b%c。<br />\n<br />\n　　提示：若b为奇数,，a^b=(a^(b/2))^2*a，否则a^b=(a^(b/2))^2。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　三个非负整数a,b,c；</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个整数ans，表示a^b%c；</div><div class='pdsec'>样例输入</div><div class='pddata'>7 2 5</div><div class='pdsec'>样例输出</div><div class='pddata'>4</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　30% a &lt;= 100, b &lt;= 10^4, 1 &lt;= c &lt;= 100<br />\n　　60% a &lt;=10^4, b &lt;= 10^5, 1 &lt;= c &lt;= 10^4<br />\n　　100% a &lt;=10^6, b &lt;= 10^9, 1 &lt;= c &lt;= 10^6</div>\n","gpid":"T526","lanqiaotitle":"JOE的算数","memorylimit":"256.0MB","tid":"ADV-275","timelimit":"1.0s","title":"算法提高 JOE的算数","src":""},{"checkpoint":"动态规划","updatetime":"2019-01-14","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　盘子装运公司是一家网络零售商，顾名思义，是一家只销售盘子的公司。该公司销售的盘子由不计其数的生产厂商提供，品种是全宇宙最多的，为此公司的员工倍感自豪。<br />\n　　在最近的一次成本分析中，公司员工发现，他们花费了大量金钱在盘子的装箱环节。一部分原因是盘子在被运输工具运走前，需要被堆成一堆。很显然，这个阶段较预期浪费了大量的时间。或许你可以为公司提供帮助。<br />\n　　一次装运的盘子由若干厂商生产的盘子组合而成。各家厂商将其生产的盘子从小到大堆成一堆（小盘在上，大盘在下），再运送到公司。我们称上述按照顺序排列的盘堆顺序合理。为了方便装运，你必须将来自各个厂商的盘子重新组合成顺序合理的一堆。将来自各厂商的盘堆组合成一个盘堆时，可以进行如下两种操作：<br />\n　　拆分(Split)：可以将一个盘堆堆顶任意数目的盘子抬起，并放置在原堆的一侧，使堆一分为二。<br />\n　　合并(Join)：可以将一个盘堆放置在另一堆的堆顶，前提是在上方的堆最底层的盘子尺寸不大于在下方的堆最顶层的盘子尺寸。<br />\n　　注意不能将一个盘堆堆顶上的若干盘子直接移动到另一个盘堆的堆顶，必须先拆分，后合并。给定盘堆若干，你需要求出将这些盘堆通过两种操作合并成一堆的最少次数。下面的图是对输入输出样例的解释。<br />\n<img src=\"https://icpcarchive.ecs.baylor.edu/external/60/p6036.png\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　本题有多组输入数据。每组输入的第一行只有一个整数n，表示盘堆的数目，接下来的n行是对每个盘堆的描述，第i+1行的第一个整数hi为第i个盘堆的盘子数，之后有hi个正整数，为盘堆从上至下各个盘子的直径（直径为不超过10000的正整数），这些整数保证按照从小到大的顺序排列。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组数据，输出数据编号以及将n个盘堆按照规则合并为一个盘堆的最少操作次数。</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n2 <br />\n3 1 2 4<br />\n2 3 5<br />\n3<br />\n4 1 1 1 1<br />\n4 1 1 1 1<br />\n4 1 1 1 1\n</pre>\n<div class='pdsec'>样例输出</div><pre class='pddata'>\nCase 1: 5<br />\nCase 2: 2\n</pre>\n<div class='pdsec'>数据规模和约定</div><div class='pdcont'><table cellspacing=0 cellpadding=2px style='border-collapse:collapse;' class='table table-striped table-horver'><tbody><tr  style='border:solid 1.0pt'><td align=\"left\" style='border:solid 1.0pt'>数据编号</td><td align=\"left\" style='border:solid 1.0pt'>n</td><td align=\"left\" style='border:solid 1.0pt'>h</td><td align=\"left\" style='border:solid 1.0pt'>数据组数</td><td align=\"left\" style='border:solid 1.0pt'>数据编号</td><td align=\"left\" style='border:solid 1.0pt'>n</td><td align=\"left\" style='border:solid 1.0pt'>h</td><td align=\"left\" style='border:solid 1.0pt'>数据组数</td></tr><tr  style='border:solid 1.0pt'><td align=\"right\" style='border:solid 1.0pt'>1</td><td align=\"center\" style='border:solid 1.0pt'>2</td><td align=\"center\" style='border:solid 1.0pt'>≤1<br />\n</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>10</td><td align=\"right\" style='border:solid 1.0pt'>11</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>50</td><td align=\"center\" style='border:solid 1.0pt'>≤30</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>10</td></tr><tr  style='border:solid 1.0pt'><td align=\"right\" style='border:solid 1.0pt'>2</td><td align=\"center\" style='border:solid 1.0pt'>2</td><td align=\"center\" style='border:solid 1.0pt'>≤50</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>10</td><td align=\"right\" style='border:solid 1.0pt'>12</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>50</td><td align=\"center\" style='border:solid 1.0pt'>≤30</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>10</td></tr><tr  style='border:solid 1.0pt'><td align=\"right\" style='border:solid 1.0pt'>3</td><td align=\"center\" style='border:solid 1.0pt'>50</td><td align=\"center\" style='border:solid 1.0pt'>≤1</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>10</td><td align=\"right\" style='border:solid 1.0pt'>13</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>50</td><td align=\"center\" style='border:solid 1.0pt'>≤40</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>10</td></tr><tr  style='border:solid 1.0pt'><td align=\"right\" style='border:solid 1.0pt'>4</td><td align=\"center\" style='border:solid 1.0pt'>3</td><td align=\"center\" style='border:solid 1.0pt'>≤2</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>10</td><td align=\"right\" style='border:solid 1.0pt'>14</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>50</td><td align=\"center\" style='border:solid 1.0pt'>≤40</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>10</td></tr><tr  style='border:solid 1.0pt'><td align=\"right\" style='border:solid 1.0pt'>5</td><td align=\"center\" style='border:solid 1.0pt'>4</td><td align=\"center\" style='border:solid 1.0pt'>≤2</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>10</td><td align=\"right\" style='border:solid 1.0pt'>15</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>50</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>≤50</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>10</td></tr><tr  style='border:solid 1.0pt'><td align=\"right\" style='border:solid 1.0pt'>6</td><td align=\"center\" style='border:solid 1.0pt'>4</td><td align=\"center\" style='border:solid 1.0pt'>≤2</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>10</td><td align=\"right\" style='border:solid 1.0pt'>16</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>50</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>≤50</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>10</td></tr><tr  style='border:solid 1.0pt'><td align=\"right\" style='border:solid 1.0pt'>7</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>10</td><td align=\"center\" style='border:solid 1.0pt'>≤2</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>10</td><td align=\"right\" style='border:solid 1.0pt'>17</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>50</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>≤50</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>10</td></tr><tr  style='border:solid 1.0pt'><td align=\"right\" style='border:solid 1.0pt'>8</td><td align=\"center\" style='border:solid 1.0pt'>10</td><td align=\"center\" style='border:solid 1.0pt'>≤5</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>10</td><td align=\"right\" style='border:solid 1.0pt'>18</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>50</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>≤50</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>10</td></tr><tr  style='border:solid 1.0pt'><td align=\"right\" style='border:solid 1.0pt'>9</td><td align=\"center\" style='border:solid 1.0pt'>10</td><td align=\"center\" style='border:solid 1.0pt'>≤10</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>10</td><td align=\"right\" style='border:solid 1.0pt'>19</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>50</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>≤50</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>400</td></tr><tr  style='border:solid 1.0pt'><td align=\"right\" style='border:solid 1.0pt'>10</td><td align=\"center\" style='border:solid 1.0pt'>10</td><td align=\"center\" style='border:solid 1.0pt'>≤10</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>10</td><td align=\"right\" style='border:solid 1.0pt'>20</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>50</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>≤50</td><td valign=\"middle\" align=\"center\" style='border:solid 1.0pt'>400</td></tr></tbody></table></div>\n","gpid":"T507","lanqiaotitle":"Stacking Plates","memorylimit":"256.0MB","tid":"ADV-271","timelimit":"1.0s","title":"算法提高 Stacking Plates","src":"ACM/ICPC World Finals 2012 K"},{"checkpoint":"动态规划","updatetime":"2019-01-14","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　你的任务是写一个程序来完成飞机的飞行计划. 每一次飞行都可以被分为一系列的航段。你的程序必须对每一航段选出最佳的飞行高度，以最小化航程中需要消耗的燃料。<br />\n　　飞机的空速是给定的，我们将用VCRUISE来描述。以及一个效果最佳的飞行高度AOPT（单位为英尺）。当飞机以海拔为AOPT的高度飞行时，每小时将消耗燃料GPHOPT加仑。如果飞机不在AOPT高度飞行，每低于或高于AOPT 1000英尺，每小时消耗的燃料就会额外增加GPHEXTRA加仑。飞机的起飞前的高度、降落后的高度均为0. 飞机的飞行高度每提升1000英尺，燃料就会消耗CLIMBCOST加仑（飞行高度下降是不需要消耗燃料的），为了简化问题，我们认为飞机的飞行高度变化是瞬间完成的。以上的所有参数，在下表中给出：<br />\n<br />\n　　VCRUSITE  400          海里 / 小时<br />\n　　AOPT           30,000       英尺<br />\n　　GPHOPT     2000         加仑 / 小时<br />\n　　GPHEXTRA  10           加仑 / 1000英尺<br />\n　　CLIMBCOST 50           加仑 / 1000英尺<br />\n<br />\n　　每次飞行前，你都会得知每一航段的长度，以及每一航段的风速。风速并不是确定的，具体地说，它由飞机在该航段的飞行高度决定，并且是一个关于飞行高度的线性函数。例如，如果飞机的空速是400海里/小时，而风速是-50海里/小时时，飞机的实际对地速度就是350海里/小时。<br />\n　　由于某些特殊的规定，飞机在每一航段的飞行高度必须在20,000英尺~40,000英尺之间，且必须是1000英尺的整数倍。你的程序需要在最小化消耗燃料的前提下，输出每一航段的飞行高度，以及消耗的最少燃料。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个整数N，表示有N组数据。<br />\n　　对于每组数据，第一行包含一个整数K（K≤100），描述航段数量。<br />\n　　接下来K行，每行3个整数A、B、C，分别描述该航段的长度（单位为海里）、在20,000英尺时的风速（单位为海里/小时)、在40,000英尺时的风速。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组数据，输出一行，共k+1个整数。前k个整数分别描述每个航段的飞行高度(单位为1000英尺），最后一个整数描述消耗的最少燃料，由于答案有可能是实数，请对答案取上整后输出。如果有多种方案满足要求，请选择字典序最小的方案（例如当 K = 2 时，有2种方案(30, 40) 和 (20, 30)，则输出(20, 30))。具体格式见样例输出。</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n2<br />\n1500 -50 50<br />\n1000 0 0<br />\n3<br />\n1000 50 0<br />\n2000 0 20<br />\n1800 50 100</div><div class='pdsec'>样例输出</div><div class='pddata'>Flight 1: 35 30 13986<br />\nFlight 2: 20 30 30 23502</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　K≤100，A≤100,000，|B|、|C|≤100</div><div class='pdsec'>特殊说明</div><div class='pdcont'>　　请注意-O2下的精度问题</div>\n","gpid":"T506","lanqiaotitle":"Flight Planning","memorylimit":"256.0MB","tid":"ADV-270","timelimit":"3.0s","title":"算法提高 Flight Planning","src":"ACM/ICPC World Finals 1998 B"},{"checkpoint":"搜索","updatetime":"2018-10-22","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　什么！Anna Locke最近买了几个链环，并且其中的一些链环连接到了一起。它们是由zorkium做成的，这是一种在上世纪经常用来加工珠宝的材料，但它不再用来干这种事了。它有它独特的光泽，即使黄金和白银也无法与之比较，并且无法向任何以前没有见过它的人来描述它。<br />\n　　Anna想要把这些链环拼组成连续的一段链，这个段中的环节首尾相连。她把这些链环带到一个珠宝商那里，珠宝商告诉她合并这些链环的费用取决于必须打开和关上的环的数目。为了最小化这个费用，她小心地计算为了合并成一个单独的序列所需要打开的最小的环的数目。这个比她想象中更困难。你必须为她解决这个问题。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含多组关于链环集合的描述，对于每一组。每个链环集合由一行用一个或多个空格隔开的数字表示。每个描述由一个n开始，表示链环集合中环的数量。我们把这些环编号为1,2,…,n。紧接着n后面的整数描述了哪些环连接在一起。每个连接由一对整数i，j（<br />\n　　1&lt;=i,j&lt;=n并且i≠j）来描述，代表环i和环j连接，即一个穿过另一个。每个链环集合用一对-1 -1表示结束（-1 -1 不用进行计算）<br />\n　　输入用n=0表示结束，并且n=0不用进行计算</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每一个输入的链环集合，输出一行形如<br />\n　　Set N: Minimum links to open is M<br />\n　　N的环的个数，M是最小需要打开然后关闭的次数来使所有环组成一条单独的链。<br />\n　　1&lt;=i,j&lt;=n并且i≠j</div><div class='pdsec'>样例输入</div><div class='pddata'>5  1 2  2 3  4 5  -1 -1<br />\n7  1 2  2 3  3 1  4 5  5 6  6 7  7 4  -1 -1<br />\n4  1 2  1 3  1 4  -1 -1<br />\n3  1 2  2 3  3 1  -1 -1<br />\n3  1 2  2 1  -1 -1<br />\n0</div><div class='pdsec'>样例输出</div><div class='pddata'>Set 1: Minimum links to open is 1<br />\nSet 2: Minimum links to open is 2<br />\nSet 3: Minimum links to open is 1<br />\nSet 4: Minimum links to open is 1<br />\nSet 5: Minimum links to open is 1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=n&lt;=15</div>\n","gpid":"T501","lanqiaotitle":"Cutting Chains","memorylimit":"256.0MB","tid":"ADV-265","timelimit":"1.0s","title":"算法提高 Cutting Chains","src":"ACM/ICPC World Finals 2000 C"},{"checkpoint":"两点间最短距离","updatetime":"2018-10-22","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　在我们联系日益紧密的世界里，人们推测每个人和其他人的分离度不超过六（六度分离）。在这个问题里，你需要写一个程序来找出人们的关系网络中最大的分离度。<br />\n　　对于任意两个人，他们的分离度是联系两个人需要经过的最小的关系数。对于一个关系网络，最大的分离度是网络中任意两人的分离度的最大值。如果一个网络中有两个人没有通过关系链连接起来，这个网络是不连通的。<br />\n　　如下图所示，一个网络可以用一些连接两个人的对称关系来描述。一条线段表示两个人之间有联系。网络A描述了一个分离度最大值为2的网络，网络B没有连通。<img src=\"/RequireFile.do?fid=BMrtf6mt\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含多组描述关系网络的数据，对于每组数据，第一行有两个数P，表示网络中人的数目，和R，关系的对数。接下来一行是R个关系。每个关系用两个字符串表示，代表网络中有关系的两个人的名字。每个名字是不同的，并且中间没有空格。因为一个人可能和多个人有联系，一个名字可能在一组数据中出现多次。<br />\n　　最后以一行两个0表示结束。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每个网络，输出网络中最大的分离度。如果这个网络是不连通的，输出DISCONNECTED。每一个网络输出后再输出一个回车。按照样例输出中的格式输出。</div><div class='pdsec'>样例输入</div><div class='pddata'>4  4<br />\nAshok  Kiyoshi   Ursala  Chun   Ursala  Kiyoshi   Kiyoshi  Chun<br />\n4  2<br />\nAshok  Chun   Ursala  Kiyoshi<br />\n6 5<br />\nBubba  Cooter   Ashok  Kiyoshi   Ursala  Chun  Ursala  Kiyoshi   Kiyoshi  Chun<br />\n0  0</div><div class='pdsec'>样例输出</div><div class='pddata'>Network 1: 2<br />\n<br />\nNetwork 2: DISCONNECTED<br />\n<br />\nNetwork 3: DISCONNECTED</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　30%的数据2&lt;=P&lt;=15<br />\n　　100%的数据2&lt;=P&lt;=50，R>=1</div>\n","gpid":"T500","lanqiaotitle":"Degrees of Separation","memorylimit":"256.0MB","tid":"ADV-264","timelimit":"1.0s","title":"算法提高 Degrees of Separation","src":"ACM/ICPC World Finals 2006 I"},{"checkpoint":"枚举 几何","updatetime":"2018-01-10","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Banff城雇用了一家广告公司来提升这座城市对潜在的游客的吸引力。其中一个计划中的口号声称延伸在这座城市周围的山脉组成了加拿大最美丽的天际线。但是加拿大消费者保护协会认为“最美丽的天际线”是一种主观的，无法证实的声称，而且可能因此让人误解。<br />\n　　然后那个广告公司就想出了一个口号“Banff——加拿大最长的天际线”。虽然没有那么引人注意，但这是有希望能证实的，而且这样就能被加拿大复杂的广告法律所接受了。<br />\n　　这就是你要介入的原因。广告公司需要的是一个能确定天际线的长度的程序。把每座山脉看作是一个二维的上面两条边长度相等的三角形。一条天际线是一座或多座山脉的轮廓。天际线的长度就是轮廓的总长度。下面的左图显示了三座山脉。右图显示了（用黑线）天际线和（用虚线）山脉上面的边中不是天际线的部分。注意位于山脉之间的地平线部分不在天际线考虑的范围内。<br />\n<img src=\"/RequireFile.do?fid=LaqFramG\" width=\"600\" height=\"176\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含一个正整数N，表示范围内的山脉数。接下来N行每行用三个整数X,H,B来描述每一座山脉，分别表示山脉的最高点到某个固定的点的水平距离，山脉的垂直高度和山脉的底边的宽度。每座山脉的底部在同一条水平线上。数据满足N≤100，H＞0而且B＞0。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出只有一行，即天际线的长度。输出那个长度四舍五入后的结果。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n20 30 35<br />\n37 24 29<br />\n60 20 13</div><div class='pdsec'>样例输出</div><div class='pddata'>138</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于20%的数据，1≤N≤5<br />\n　　对于50%的数据，1≤N≤30<br />\n　　对于100%的数据，1≤N≤100</div>\n","gpid":"T483","lanqiaotitle":"The Sky is the Limit","memorylimit":"256.0MB","tid":"ADV-256","timelimit":"1.0s","title":"算法提高 The Sky is the Limit","src":"ACM/ICPC World Finals 2008 J"},{"checkpoint":"解方程","updatetime":"2018-01-05","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　全球定位系统（GPS）是一个导航系统，根据一些在距地表大约20,000千米的轨道运行的卫星。每个卫星在一个已知的轨道上运行，发射编码着当前时间的无线电信号。如果一个装有全球定位系统的交通工具有一个非常精确的时钟，它就可以比较它自己的当地时间和从卫星上接受到的编码成信号的时间。因为无线电信号按一个已知的速度传播，所以这个交通工具能够计算出它目前的位置和信号发出时卫星的位置之间的距离。通过测算这个交通工具和一些在已知轨道上运行的卫星之间的距离，它可以非常精确地计算出自己的位置。<br />\n<br />\n<img width=\"543\" height=\"322\" src=\"/RequireFile.do?fid=ftAreBNd\" /><br />\n<br />\n<br />\n　　你必须写一个简单的“自动导航装置”程序，根据GPS的导航。为了让这个问题更简单，我们描述一个二维的问题。换句话说，你不需要考虑地球的曲率或者卫星的高度。此外，这个问题使用了更加适合于飞机和声波的速度而不是卫星和无线电波。<br />\n　　给定一组移动的信号源，你的程序必须计算出在笛卡尔平面内的接收点。然后，给定一个在平面内的目标点，你的程序必须计算出从接收点到目标点指南针的指向。所有的指南针的指向用角度表示。指南针指向0（北）相当于Y轴方向，指南针指向90（东）相当于X轴方向，就像图1所展示的那样。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　读入包含多组测试数据。<br />\n　　每组数据的第一行包含一个整数N （1 ≤ N ≤ 10），表示信号源的数量。接下来有3个浮点数：t，x和y。这里，t表示当所有的信号被接收时精确的当地时间，从基准时间（0时刻）按秒计时算起；x和y表示在笛卡尔平面内目标点的坐标。接下来N行每行包含4个浮点数，携带有1个信号源的信息。前2个数字表示信号源在基准时间在笛卡尔平面内的位置。第3个数字表示信号源向指南针指向D（0 ≤ D &lt; 360）前进。第4个数字是编码在信号里的时间——也就是，信号发出的时间，从基准时间按秒计时算起。输入文件所有数字小于10000，没有一个浮点数在小数点后超过5位。<br />\n　　最后一组数据的接下来一行包含4个0。<br />\n　　坐标系的单位距离是1m。假设每个信号源以100m/s的速度在笛卡尔平面上移动，信号以350m/s的速度传播。由于时钟同步的不精确，你计算的距离都只精确到0.1m。也就是说，如果2个点相距0.1m以内，你应该把它们看成相同的点。信号可能在传播途中被干扰，所以接收到的多个信号可能会矛盾。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组数据，输出数据的编号和从接收位置到目的地指南针的指向，用角度表示，四舍五入到整数。使用在样例输出中展示的标识。如果信号包含不够多的信息来计算接收位置（也就是，符合所有信号的超过一个位置），输出“Inconclusive”。如果信号矛盾（也就是，没有位置符合所有的信号），输出“Inconsistent”。如果接收位置相距目的地0.1m以内，输出“Arrived”。如果情形是Inconclusive或者Inconsistent，那么你不需要考虑Arrived的情形。<br />\n　　图2对应着样例的第一个数据。t=0时3个卫星的位置A（-100，350），B（350，-100），和C（350，800）。被GPS装置接收的信号都在t=1.75时被发出，当卫星处在位置A'，B'，C'的时候（然而，通常被GPS装置接收的信号发出的时刻是不同的）。3个卫星发出信号在t=2.53571时刻汇聚在D，意味着D是接收信号的GPS装置的位置。从点D出发，指南针指向45度最终会到达目的地（1050，1050）。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 2.53571 1050.0 1050.0<br />\n-100.0 350.0 90.0 1.75<br />\n350.0 -100.0 0.0 1.75<br />\n350.0 800.0 180.0 1.75<br />\n2 2.0 1050.0 1050.0<br />\n-100.0 350.0 90.0 1.0<br />\n350.0 -100.0 0.0 1.0<br />\n0 0 0 0</div><div class='pdsec'>样例输出</div><div class='pddata'>Trial 1: 45 degrees<br />\nTrial 2: Inconclusive</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1 ≤ N ≤ 10；<br />\n　　指南针指向的范围均为[0，360)。<br />\n　　输入文件所有数字小于10000，没有一个浮点数在小数点后超过5位。<br />\n　　每个测试点包含不超过5组测试数据。</div>\n","gpid":"T472","lanqiaotitle":"Navigation","memorylimit":"256.0MB","tid":"ADV-252","timelimit":"1.0s","title":"算法提高 Navigation","src":"ACM/ICPC World Finals 2004 G"},{"checkpoint":"模拟","updatetime":"2017-12-29","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　一个Petri网是一个计算模型，用来说明并发事件。每个Petri网包含一些库所（被表示成圆圈），变迁（被表示成黑色的矩形），和一些有向边，用来连接库所到变迁，和变迁到库所。每个库所能够包含0个或多个令牌（被表示成黑点）。<br />\n　　这里有2个例子：<br />\n<br />\n<img width=\"319\" height=\"222\" src=\"/RequireFile.do?fid=LnH26QFn\" /><br />\n<br />\n<img width=\"419\" height=\"222\" src=\"/RequireFile.do?fid=3hAB8BDe\" /><br />\n　　在上面的第一个Petri网中，有2个库所（P1 和 P2）和2个变迁（T1 和 T2）。P1初始有1个令牌。P2没有令牌。P1是变迁T1的输入库所，P2是T1的输出库所。在第二个例子中，有3个库所和3个变迁，P1有3个令牌。T2有2个输入库所，2个都是P2。<br />\n<br />\n　　一个Petri网的操作<br />\n<br />\n　　每个Petri网的变迁要么被允许，要么不被允许。一个变迁被允许当且仅当每个输入库所都至少有1个令牌。任何被允许的变迁可以发生。如果有多个变迁被允许，任何一个都可能发生。当一个变迁发生时，每个输入库所都会移除1个令牌，每个输出库所都会增加1个令牌。这会有效地利用原子能来完成，作为一个事件。如果没有一个变迁被允许，这个Petri网就被认为是死的。<br />\n<br />\n　　最上面那个例子，只有T1是被允许的。当它发生时，会从P1移除1个令牌，给P2增加1个令牌。然后T2就被允许了。当它发生时，会从P2移除1个令牌，给P1增加1个令牌。显然，这个Petri网将会永远重复这个循环。<br />\n<br />\n　　下面那个例子更加有趣。T1被允许然后发生，有效地移动1个令牌给P2。在这个时候，T1仍然是唯一被允许的变迁（T2被允许需要P2有2个令牌）。T1再次发生，在P1剩下1个令牌，P2中有2个令牌。现在，T1和T2都被允许。假设T2发生，从P2移除2个令牌，给P3增加1个令牌。现在T1和T3都被允许。直到没有变迁被允许，你应该能看到在9次变迁发生后，在P2仅留下1个令牌。（注意到，如果当T1和T2都被允许的时候，T1代替了T2发生，这个结果也同样是在9次变迁发生后。）<br />\n<br />\n　　在这个问题中，你将会被给出1个或多个Petri网的描述。对于每个描述，你将要模拟NF（0 &lt; NF &lt; 1000）次变迁的发生，然后输出留在库所里的令牌数量。如果这个Petri网在NF次变迁发生之前就死了，你将按事实输出。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　每个Petri网的描述首先会包含一个整数NP（0 &lt; NP &lt; 100），紧接着有NP个整数分别表示编号为1，2，…，NP的库所初始有多个个令牌。接着会有一个整数NT（0 &lt; NT &lt; 100）表示变迁的数量。然后，对于每个变迁（编号为1，2，…，NT）将会有一个以0结尾的整数序列。序列中的负数代表输入库所，所以数字-n代表有一个输入库所在n。序列中的正数代表输出库所，所以数字p代表有一个输出库所在p。每个库所至少有一个输入库所，至少有一个输出库所。最后，在NT个变迁的描述之后，会有一个整数代表你至多要模拟变迁发生的次数，NF。输入会包含一个或多个Petri网的描述，最后会有一个0。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每个Petri网的描述，输出三行。第一行输出是第几组数据（从1开始连续编号）和是否有NF次变迁发生。如果有，输出这个Petri网在NF次变迁发生后仍然活着。否则输出这个Petri网已经死了和变迁发生的次数。两种情况下，在第二行都输出在模拟结束后，包含1个或多个令牌的库所的编号，和每个这种库所含有的令牌数量。输出的序列按编号递增。每组数据的第三行都应该是空行。<br />\n　　输入数据将会被选择来保证正确输出的唯一性。</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n1 0<br />\n2<br />\n-1 2 0<br />\n-2 1 0<br />\n100<br />\n3<br />\n3 0 0<br />\n3<br />\n-1 2 0<br />\n-2 -2 3 0<br />\n-3 1 0<br />\n100<br />\n0</div><div class='pdsec'>样例输出</div><div class='pddata'>Case 1: still live after 100 transitions<br />\nPlaces with tokens: 1 (1)<br />\n<br />\nCase 2: dead after 9 transitions<br />\nPlaces with tokens: 2 (1)</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　0 &lt; NP &lt; 100；<br />\n　　0 &lt; NT &lt; 100；<br />\n　　0 &lt; NF &lt; 1000；<br />\n　　每个库所初始的令牌数不超过10000。<br />\n　　每个Petri网的所有变迁输入的整数序列的总长度不超过20000。<br />\n　　每个测试点包含不超过5个Petri网的描述。</div>\n","gpid":"T471","lanqiaotitle":"Petri Net Simulation","memorylimit":"256.0MB","tid":"ADV-251","timelimit":"1.0s","title":"算法提高 Petri Net Simulation","src":"ACM/ICPC World Finals 1998 E"},{"checkpoint":"动态规划","updatetime":"2017-12-29","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　自从Peter Stuyvesant和Abel Tasman的日子以后，荷兰商人已经周游世界来买卖商品。有一次在Verweggistan的贸易，但是它在很短的时间后就结束了。在读完这个故事之后你就明白了。<br />\n　　在当时Verweggistan是非常受欢迎的，因为世界上只有那个地方的人知道怎样制作一个“prul”（或者“prullen”，荷兰语中的复数形式），并且如今只有很少的人知道什么是一个“prul”。<br />\n　　“prul”是在工场里生产的。当一个“prul”做完的时候，它被包装在一个箱子里，然后放在之前生产的“prul”所装的箱子堆的上面。<br />\n　　价格取决于生产“prul”所需要的时间。如果一切顺利，一个“prul”的价格会是1或者2弗罗林，但是在一个恶劣的日子，价格会很容易地上升到15弗罗林或者更高。“prul”在品质上没有什么差别，所有的“prul”具有相同的价值。<br />\n　　在这些天，“prul”在荷兰的售价为每件10弗罗林。交通运输的费用是可以忽略的，因为“prul”无论如何都会作为额外的东西被装载到要航行的船上。当一个荷兰商人去Verweggistan时，他有一个明确的目的：买“prul”，在荷兰销售，并且最大化他的利润。不幸的是，Verweggistan地区对“prul”的交易方式使得这比某些人预想的更为复杂。<br />\n　　有人认为这很简单，商人会买那些最便宜的“prul”，而那些售价比10弗罗林高的“prul”会一直不能出售。不幸的是，Verweggistan的所有工场按照一种奇怪的顺序销售“prul”。堆顶的箱子里的“prul”会最先销售，然后销售从顶上开始数的第二个箱子里的“prul”，以此类推。所以即使第五个箱子里的“prul”是最便宜的，商人也必须买它上面四个箱子里的“prul”才能得到它。<br />\n　　正如你想象的那样，这使得商人通过购买正确的“prul”的组合来最大化他们的利润是相当难的。没有电脑帮助他们的优化，他们迅速彻底失去了交易“prul”的兴趣。<br />\n　　在这个问题中，给你对几个工场里箱子堆的描述。你必须根据上面所给的限制，计算出一个商人通过购买箱子堆中的“prul”可以获得的最大利润。另外，你必须确定他需要买多少个“prul”才能获得最大利润。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入文件包含多组测试数据。每个测试数据的第一行是一个整数w(1&lt;=w&lt;=50)，该测试数据中工场的数目。<br />\n　　接下来有w行，每行描述一个放“prul”的箱子堆。每行的第一个整数b(0&lt;=b&lt;=20)，表示堆中的箱子数。接下来是b个正整数，表示堆中“prul”的价格（单位为弗罗林）。输入中箱子的顺序是从顶到底。<br />\n　　输入数据终止于w=0，不再有后续的描述内容。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组测试数据，输出测试点的编号(1,2...)。然后输出两行，第一行输出商人可以获得的最大利润。第二行输出为获得最大利润商人需要买的“prul”数量。如果这个数量不是唯一确定的，按照升序输出可能的值。如果有超过10种可能的取值，只输出10个最小的取值。</div><div class='pdsec'>样例输入</div><div class='pddata'>1<br />\n6 12 3 10 7 16 5<br />\n2<br />\n5 7 3 11 9 10<br />\n9 1 2 3 4 10 16 10 4 16<br />\n0</div><div class='pdsec'>样例输出</div><div class='pddata'>Workyards 1<br />\nMaximum profit is 8.<br />\nNumber of pruls to buy: 4<br />\nWorkyards 2<br />\nMaximum profit is 40.<br />\nNumber of pruls to buy: 6 7 8 9 10 12 13</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=w&lt;=50，0&lt;=b&lt;=20，输入文件保证测试点个数不超过10。</div>\n","gpid":"T470","lanqiaotitle":"Trade on Verweggistan","memorylimit":"128.0MB","tid":"ADV-250","timelimit":"1.0s","title":"算法提高 Trade on Verweggistan","src":"ACM/ICPC World Finals 1999 E"},{"checkpoint":"进制转换","updatetime":"2017-12-07","content":"<div class='pdcont'>　　用户输入三个字符，每个字符取值范围是0-9，A-F。然后程序会把这三个字符转化为相应的十六进制整数，并分别以十六进制，十进制，八进制输出，十六进制表示成3位，八进制表示成4位，若不够前面补0。（不考虑输入不合法的情况）<br />\n<b>输入</b><br />\n　　1D5<br />\n<b>输出</b><br />\n<b>（注意冒号后面有一个空格）</b><br />\n　　Hex: 0x1D5<br />\n　　Decimal: 469<br />\n　　Octal: 0725</div>\n","gpid":"T427","lanqiaotitle":"P0102","memorylimit":"256.0MB","tid":"ADV-239","timelimit":"1.0s","title":"算法提高 P0102","src":""},{"checkpoint":"水分子数问题","updatetime":"2017-11-21","content":"<div class='pdcont'>　　﻿<br />\n　　一个水分子的质量是3.0*10<sup>-23</sup>克，一夸脱水的质量是950克。写一个程序输入水的夸脱数n（0 &lt;= n &lt;= 1e10），然后输出水分子的总数。<br />\n<b>输入</b><br />\n　　109.43<br />\n<b>输出</b><br />\n　　3.465283E+027</div>\n","gpid":"T426","lanqiaotitle":"P0101","memorylimit":"256.0MB","tid":"ADV-238","timelimit":"1.0s","title":"算法提高 P0101","src":""},{"checkpoint":"枚举 条件判断","updatetime":"2017-11-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定L和R，你需要对于每一个6位三进制数（允许前导零），计算其每一个数位上的数字和，设其在十进制下为S。<br />\n<br />\n　　一个三进制数被判断为合法，当且仅当S为质数，或者S属于区间[L,R]。<br />\n<br />\n　　你的任务是给出合法三进制数的个数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一行两个非负整数L,R。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行一个非负整数表示答案。</div><div class='pdsec'>样例输入</div><div class='pddata'>0 0</div><div class='pdsec'>样例输出</div><div class='pddata'>330</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　保证0&lt;=L&lt;R&lt;=12。</div><div class='pdsec'>提示</div><div class='pdcont'>　　判断x是否为质数核心代码：for (int i = 2; i * i &lt;= x; ++i) if (x % i == 0) {/*你猜？*/}</div>\n","gpid":"T425","lanqiaotitle":"三进制数位和","memorylimit":"256.0MB","tid":"ADV-237","timelimit":"1.0s","title":"算法提高 三进制数位和","src":"程序设计基础"},{"checkpoint":"queue 队列","updatetime":"2017-01-18","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　﻿队列操作题。根据输入的操作命令，操作队列（1）入队、（2）出队并输出、（3）计算队中元素个数并输出。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个数字N。<br />\n　　下面N行，每行第一个数字为操作命令（1）入队、（2）出队并输出、（3）计算队中元素个数并输出。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　若干行每行显示一个2或3命令的输出结果。注意：2.出队命令可能会出现空队出队（下溢），请输出“no”，并退出。</div><div class='pdsec'>样例输入</div><div class='pddata'>7<br />\n1 19<br />\n1 56<br />\n2<br />\n3<br />\n2<br />\n3<br />\n2</div><div class='pdsec'>样例输出</div><div class='pddata'>19<br />\n1<br />\n56<br />\n0<br />\nno</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=N&lt;=50</div>\n","gpid":"T418","lanqiaotitle":"队列操作","memorylimit":"256.0MB","tid":"ADV-233","timelimit":"1.0s","title":"算法提高 队列操作","src":"jl"},{"checkpoint":"动态规划 DP","updatetime":"2017-01-18","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有n个矩阵，大小分别为a0*a1, a1*a2, a2*a3, ..., a[n-1]*a[n]，现要将它们依次相乘，只能使用结合率，求最少需要多少次运算。<br />\n　　两个大小分别为p*q和q*r的矩阵相乘时的运算次数计为p*q*r。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含一个整数n，表示矩阵的个数。<br />\n　　第二行包含n+1个数，表示给定的矩阵。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个整数，表示最少的运算次数。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n1 10 5 20</div><div class='pdsec'>样例输出</div><div class='pddata'>150</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=n&lt;=1000, 1&lt;=ai&lt;=10000。</div>\n","gpid":"T417","lanqiaotitle":"矩阵乘法","memorylimit":"256.0MB","tid":"ADV-232","timelimit":"3.0s","title":"算法提高 矩阵乘法","src":""},{"checkpoint":"","updatetime":"2017-01-18","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　为二维空间中的点设计一个结构体，在此基础上为三角形设计一个结构体。分别设计独立的函数计算三角形的周长、面积、中心和重心。输入三个点，输出这三个点构成的三角形的周长、面积、外心和重心。结果保留小数点后2位数字。</div><div class='pdsec'>样例输出</div><div class='pddata'>与上面的样例输入对应的输出。<br />\n例：<br />\n<img src=\"/RequireFile.do?fid=HNB5deQa\" width=\"182\" height=\"147\" /></div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入数据中每一个数的范围。<br />\n　　例：doule型表示数据。</div>\n","gpid":"T415","lanqiaotitle":"12-1三角形","memorylimit":"256.0MB","tid":"ADV-230","timelimit":"1.0s","title":"算法提高 12-1三角形","src":""},{"checkpoint":"动态规划 DP","updatetime":"2017-01-18","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　在一条直线上有n堆石子，每堆有一定的数量，每次可以将两堆相邻的石子合并，合并后放在两堆的中间位置，合并的费用为两堆石子的总数。求把所有石子合并成一堆的最小花费。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入第一行包含一个整数n，表示石子的堆数。<br />\n　　接下来一行，包含n个整数，按顺序给出每堆石子的大小 。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个整数，表示合并的最小花费。</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n1 2 3 4 5</div><div class='pdsec'>样例输出</div><div class='pddata'>33</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=n&lt;=1000, 每堆石子至少1颗，最多10000颗。</div>\n","gpid":"T414","lanqiaotitle":"合并石子","memorylimit":"256.0MB","tid":"ADV-229","timelimit":"2.0s","title":"算法提高 合并石子","src":""},{"checkpoint":"指针","updatetime":"2016-12-12","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　自己实现一个比较字符串大小的函数，也即实现strcmp函数。函数：int myStrcmp(char *s1,char *s2) 按照ASCII顺序比较字符串s1与s2。若s1与s2相等返回0，s1&gt;s2返回1，s1&lt;s2返回-1。具体来说，两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇'\\0'为止（注意'\\0'值为0，小于任意ASCII字符）。如：<br />\n　　\"A\"&lt;\"B\"<br />\n　　\"a\"&gt;\"A\"<br />\n　　\"computer\"&gt;\"compare\"<br />\n　　\"hello\"&lt;\"helloworld\"</div><div class='pdsec'>样例输出</div><div class='pddata'><img width=\"244\" height=\"77\" src=\"/RequireFile.do?fid=feaGhTD5\" /></div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　字符串长度&lt;100。</div>\n","gpid":"T412","lanqiaotitle":"11-1实现strcmp函数","memorylimit":"256.0MB","tid":"ADV-227","timelimit":"1.0s","title":"算法提高 11-1实现strcmp函数","src":""},{"checkpoint":"","updatetime":"2016-12-12","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　摩尔斯电码破译。类似于乔林教材第213页的例6.5，要求输入摩尔斯码，返回英文。请不要使用\"zylib.h\"，只能使用标准库函数。用' * '表示' . '，中间空格用' | '表示，只转化字符表。<br />\n<br />\n　　摩尔斯码定义见：http://baike.baidu.com/view/84585.htm?fromId=253988。<br />\n<br />\n<img width=\"515\" height=\"259\" src=\"/RequireFile.do?fid=dafbnrF3\" /></div><div class='pdsec'>提示</div><div class='pdcont'>　　清橙进行评测时，输入是以EOF结尾的，而不是换行符。（EOF不是一个字符，“以EOF结尾”是一种通俗但不严谨的说法。）因此可以通过以下方式之一获取输入：<br />\n<br />\n　　1. 一次读入整行字符串，再进行后续解析。<br />\n<br />\n　　2. 使用getchar或scanf一次读入一个字符，通过它们的返回值判断输入结束。</div><div class='pdsec'>样例输出</div><div class='pddata'><img width=\"238\" height=\"57\" src=\"/RequireFile.do?fid=d9rrhb57\" /></div>\n","gpid":"T411","lanqiaotitle":"9-3摩尔斯电码","memorylimit":"256.0MB","tid":"ADV-226","timelimit":"1.0s","title":"算法提高 9-3摩尔斯电码","src":""},{"checkpoint":"","updatetime":"2016-12-12","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　先编写函数EncryptChar,按照下述规则将给定的字符c转化（加密）为新的字符：\"A\"转化\"B\"，\"B\"转化为\"C\"，... ...\"Z\"转化为\"a\"，\"a\"转化为\"b\",... ..., \"z\"转化为\"A\"，其它字符不加密。编写程序，加密给定字符串。</div><div class='pdsec'>样例输出</div><div class='pddata'>与上面的样例输入对应的输出。<br />\n例：<br />\n<img src=\"/RequireFile.do?fid=QJgFn3ba\" width=\"269\" height=\"65\" /></div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入数据中每一个数的范围。<br />\n　　例：50个字符以内无空格字符串。</div>\n","gpid":"T410","lanqiaotitle":"9-2 文本加密","memorylimit":"256.0MB","tid":"ADV-225","timelimit":"1.0s","title":"算法提高 9-2 文本加密","src":""},{"checkpoint":"","updatetime":"2016-12-12","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　九宫格。输入1-9这9个数字的一种任意排序，构成3*3二维数组。如果每行、每列以及对角线之和都相等，打印1。否则打印0。</div><div class='pdsec'>样例输出</div><div class='pddata'>与上面的样例输入对应的输出。<br />\n例：<br />\n<img src=\"/RequireFile.do?fid=T57nL8Y9\" width=\"193\" height=\"81\" /></div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入1-9这9个数字的一种任意排序。</div>\n","gpid":"T409","lanqiaotitle":"9-1九宫格","memorylimit":"256.0MB","tid":"ADV-224","timelimit":"1.0s","title":"算法提高 9-1九宫格","src":""},{"checkpoint":"","updatetime":"2016-11-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　设计算法，用户输入合数，程序输出若个素数的乘积。例如，输入6，输出2*3。输入20，输出2*2*5。</div><div class='pdsec'>样例</div><div class='pdcont'>　　与上面的样例输入对应的输出。<br />\n　　例：<br />\n<img src=\"/RequireFile.do?fid=JGqjQ8DY\" width=\"293\" height=\"54\" /><br />\n<img src=\"/RequireFile.do?fid=JAq2yLhh\" width=\"204\" height=\"39\" /></div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入数据中每一个数在int表示范围内。</div>\n","gpid":"T403","lanqiaotitle":"8-1因式分解","memorylimit":"256.0MB","tid":"ADV-223","timelimit":"10.0s","title":"算法提高 8-1因式分解","src":""},{"checkpoint":"","updatetime":"2016-11-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　利用标准库中的cos(x)和fabs(x)函数实现arccos(x)函数，x取值范围是[-1, 1]，返回值为[0, PI]。要求结果准确到小数点后5位。(PI = 3.1415926)<br />\n　　提示：要达到这种程度的精度需要使用double类型。</div><div class='pdsec'>样例输入</div><div class='pddata'>0.5</div><div class='pdsec'>样例输出</div><div class='pddata'><img width=\"284\" height=\"53\" src=\"/RequireFile.do?fid=jRJNyEnF\" /></div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　-1 &lt;= x &lt;= 1, 0 &lt;= arccos(x) &lt;= PI。</div>\n","gpid":"T402","lanqiaotitle":"7-2求arccos值","memorylimit":"256.0MB","tid":"ADV-222","timelimit":"10.0s","title":"算法提高 7-2求arccos值","src":""},{"checkpoint":"","updatetime":"2016-11-09","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　使用宏实现计算球体体积的功能。用户输入半径，系统输出体积。不能使用函数，pi=3.1415926,结果精确到小数点后五位。</div><div class='pdsec'>样例输入</div><div class='pddata'>一个满足题目要求的输入范例。<br />\n例：<br />\n1.0</div><div class='pdsec'>样例输出</div><div class='pddata'>与上面的样例输入对应的输出。<br />\n例：<br />\n<img src=\"/RequireFile.do?fid=d5DamYnR\" width=\"360\" height=\"51\" /></div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入数据中每一个数的范围。<br />\n　　数据表示采用double类型。</div>\n","gpid":"T401","lanqiaotitle":"7-1用宏求球的体积","memorylimit":"256.0MB","tid":"ADV-221","timelimit":"1.0s","title":"算法提高 7-1用宏求球的体积","src":""},{"checkpoint":"组合公式","updatetime":"2016-11-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定n, m，求：<br />\n<br />\n<img src=\"/RequireFile.do?fid=8NbAnATq\" width=\"209\" height=\"84\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入一行，包含两个整数n, m。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行，包含求得的值，由于答案可能非常大，请输出此公式除以987654321的余数。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 1</div><div class='pdsec'>样例输出</div><div class='pddata'>162</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=m&lt;=n&lt;=10^7。</div>\n","gpid":"T397","lanqiaotitle":"组合公式求值","memorylimit":"256.0MB","tid":"ADV-219","timelimit":"1.0s","title":"算法提高 组合公式求值","src":""},{"checkpoint":"递推 矩阵乘法","updatetime":"2016-11-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　已知递推公式：<br />\n<br />\n　　F(n, 1)=F(n-1, 2) + 2F(n-3, 1) + 5,<br />\n<br />\n　　F(n, 2)=F(n-1, 1) + 3F(n-3, 1) + 2F(n-3, 2) + 3.<br />\n<br />\n　　初始值为：F(1, 1)=2, F(1, 2)=3, F(2, 1)=1, F(2, 2)=4, F(3, 1)=6, F(3, 2)=5。<br />\n　　输入n，输出F(n, 1)和F(n, 2)，由于答案可能很大，你只需要输出答案除以99999999的余数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入第一行包含一个整数n。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出两行，第一行为F(n, 1)除以99999999的余数，第二行为F(n, 2)除以99999999的余数。</div><div class='pdsec'>样例输入</div><div class='pddata'>4</div><div class='pdsec'>样例输出</div><div class='pddata'>14<br />\n<br />\n21</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=n&lt;=10^18。</div>\n","gpid":"T396","lanqiaotitle":"递推求值","memorylimit":"256.0MB","tid":"ADV-218","timelimit":"1.0s","title":"算法提高 递推求值","src":""},{"checkpoint":"类与对象","updatetime":"2016-11-03","content":"<div class='pdcont'>　　﻿【﻿题目描述】<br />\n　　实现一个时间类Time。将小时，分钟和秒存储为int型成员变量。要求该类中包含一个构造函数，访问用的函数，一个推进当前时间的函数adv()，一个重新设置当前时间（即将当前时间设为00:00:00）的函数reset()和输出结果函数print()。注意时间按数字式电子表格式显示，即小时、分、秒分别用两位表示，如果其中之一小于10，则前方补0，如22:01:00（中间不含空格），另外按该格式依次输出时、分、秒后，以endl结尾。当输入时间超出合法范围（提示：注意上下界）时，请自动按照24小时制进行转换，请务必注意时分秒为负值时的处理，如输入25:00:61，则输出应为01:01:01，输入-1:-1:-1，应该输出22:58:59。<br />\n　　第一步：依据题意定义Time类<br />\n　　class Time<br />\n　　{<br />\n　　// 请补充<br />\n　　};<br />\n　　第二步：利用如下测试程序对所编写的Time类进行测试。<br />\n　　int main()<br />\n　　{<br />\n　　// 当前时间<br />\n　　int hour, minute, second;<br />\n　　// 时间增量<br />\n　　int incr_hr, incr_min, incr_sec;<br />\n　　cin &gt;&gt; hour &gt;&gt; minute &gt;&gt; second &gt;&gt; incr_hr &gt;&gt; incr_min &gt;&gt; incr_sec;<br />\n　　Time t( hour, minute, second );<br />\n　　t.print();<br />\n　　t.adv( incr_hr, incr_min, incr_sec );<br />\n　　t.print();<br />\n　　t.reset();<br />\n　　t.print();<br />\n　　return 0;<br />\n　　}</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入一行，6个int类型数字，以空格间隔。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出三行时间，时间格式为24小时制，xx:xx:xx，英文标点，不足两位十位数补0。<br />\n　　第一行为初始时间，第二行为adv()后的时间，第三行为reset()后的时间</div><div class='pdsec'>示例1输入</div><div class='pdcont'>　　0 0 0 0 0 -1</div><div class='pdsec'>示例1输出</div><div class='pdcont'>　　00:00:00<br />\n　　23:59:59<br />\n　　00:00:00<br />\n　　示例3：</div><div class='pdsec'>示例2输入</div><div class='pdcont'>　　25 63 61 0 0 1</div><div class='pdsec'>示例2输出</div><div class='pdcont'>　　02:04:01<br />\n　　02:04:02<br />\n　　00:00:00</div><div class='pdsec'>示例3输入</div><div class='pdcont'>　　-50 -24 0 50 45 90</div><div class='pdsec'>示例3输出</div><div class='pdcont'>　　21:36:00<br />\n　　00:22:30<br />\n　　00:00:00</div>\n","gpid":"T395","lanqiaotitle":"c++_ch04_02_修正版","memorylimit":"256.0MB","tid":"ADV-217","timelimit":"1.0s","title":"算法提高 c++_ch04_02_修正版","src":""},{"checkpoint":"","updatetime":"2016-05-09","content":"<div class='pdcont'><b>Problem Description</b><br />\n　　We call a number <i>interesting</i>, if and only if:<br />\n　　1. Its digits consists of only 0, 1, 2 and 3, and all these digits occurred at least once.<br />\n　　2. Inside this number, all 0s occur before any 1s, and all 2s occur before any 3s.<br />\n　　Therefore, the smallest interesting number according to our definition is 2013. There are two more interseting number of 4 digits: 2031 and 2301.<br />\n　　Your task is to calculate the number of interesting numbers of exactly <i>n</i> digits. As the answer might be very large, you only need to output the answer modulo 1000000007.<br />\n<b>Input Format</b><br />\n　　The input has one line consisting of one positive integer <i>n</i> (4 ≤ <i>n</i> ≤ 10^15).<br />\n<b>Output Format</b><br />\n　　The output has just one line, containing the number of interesting numbers of exactly <i>n</i> digits, modulo 1000000007.<br />\n<b>Input Sample</b><br />\n　　4<br />\n<b>Output Sample</b><br />\n　　3</div>\n","gpid":"T388","lanqiaotitle":"Problem S4: Interesting Numbers 加强版","memorylimit":"1.0GB","tid":"ADV-215","timelimit":"1.0s","title":"算法提高 Problem S4: Interesting Numbers 加强版","src":""},{"checkpoint":"线性代数","updatetime":"2016-05-09","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　小明最近在为线性代数而头疼，线性代数确实很抽象（也很无聊），可惜他的老师正在讲这矩阵乘法这一段内容。<br />\n　　当然，小明上课打瞌睡也没问题，但线性代数的习题可是很可怕的。<br />\n　　小明希望你来帮他完成这个任务。<br />\n<br />\n　　现在给你一个ai行aj列的矩阵和一个bi行bj列的矩阵，<br />\n　　要你求出他们相乘的积（当然也是矩阵）。<br />\n　　(输入数据保证aj=bi,不需要判断)</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入文件共有ai+bi+2行，并且输入的所有数为整数（long long范围内）。<br />\n　　第1行：ai 和 aj<br />\n　　第2~ai+2行：矩阵a的所有元素<br />\n　　第ai+3行：bi 和 bj<br />\n　　第ai+3~ai+bi+3行：矩阵b的所有元素</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出矩阵a和矩阵b的积（矩阵c)<br />\n　　（ai行bj列）</div><div class='pdsec'>样例输入</div><div class='pddata'>2 2<br />\n12 23<br />\n45 56<br />\n2 2<br />\n78 89<br />\n45 56</div><div class='pdsec'>样例输出</div><div class='pddata'>1971 2356<br />\n6030 7141</div>\n","gpid":"T380","lanqiaotitle":"矩阵相乘","memorylimit":"256.0MB","tid":"ADV-208","timelimit":"1.0s","title":"算法提高 矩阵相乘","src":"自编"},{"checkpoint":"动态规划","updatetime":"2016-05-09","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　妈妈给小B买了N块糖！但是她不允许小B直接吃掉。<br />\n　　假设当前有M块糖，小B每次可以拿P块糖，其中P是M的一个不大于根号下M的质因数。这时，妈妈就会在小B拿了P块糖以后再从糖堆里拿走P块糖。然后小B就可以接着拿糖。<br />\n　　现在小B希望知道最多可以拿多少糖。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一个整数N</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　最多可以拿多少糖</div><div class='pdsec'>样例输入</div><div class='pddata'>15</div><div class='pdsec'>样例输出</div><div class='pddata'>6</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　N &lt;= 100000</div>\n","gpid":"T376","lanqiaotitle":"拿糖果","memorylimit":"256.0MB","tid":"ADV-205","timelimit":"1.0s","title":"算法提高 拿糖果","src":""},{"checkpoint":"动态规划","updatetime":"2016-01-28","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给n个有序整数对ai bi，你需要选择一些整数对 使得所有你选定的数的ai+bi的和最大。并且要求你选定的数对的ai之和非负，bi之和非负。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行为n，数对的个数<br />\n　　以下n行每行两个整数 ai bi</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出你选定的数对的ai+bi之和</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n-403 -625<br />\n-847 901<br />\n-624 -708<br />\n-293 413<br />\n886 709</div><div class='pdsec'>样例输出</div><div class='pddata'>1715</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=n&lt;=100<br />\n　　-1000&lt;=ai,bi&lt;=1000</div>\n","gpid":"T368","lanqiaotitle":"求最大值","memorylimit":"256.0MB","tid":"ADV-200","timelimit":"1.0s","title":"算法提高 求最大值","src":""},{"checkpoint":"大数乘法","updatetime":"2016-01-27","content":"<div class='pdcont'>　　﻿<br />\n　　当两个比较大的整数相乘时，可能会出现数据溢出的情形。为避免溢出，可以采用字符串的方法来实现两个大数之间的乘法。具体来说，首先以字符串的形式输入两个整数，每个整数的长度不会超过8位，然后把它们相乘的结果存储在另一个字符串当中（长度不会超过16位），最后把这个字符串打印出来。例如，假设用户输入为：62773417和12345678，则输出结果为：774980393241726.<br />\n<br />\n<b>输入：</b><br />\n　　62773417 12345678<br />\n<br />\n<b>输出：</b><br />\n　　774980393241726<i></i></div>\n","gpid":"T364","lanqiaotitle":"P1001","memorylimit":"256.0MB","tid":"ADV-197","timelimit":"1.0s","title":"算法提高 P1001","src":""},{"checkpoint":"链表","updatetime":"2016-01-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有一天，盾神捡到了好多好多五颜六色的珠子！他心想这些珠子这么漂亮，可以做成一条项链然后送给他心仪的女生~于是他用其中一些珠子做成了长度为n的项链。当他准备把项链首尾相接的时候，土方进来了。<br />\n　　“哇这么恶心的项链你也做得出来！！！”<br />\n　　盾神自知审美不是他的长项，于是他很谦虚地请教土方，怎么才能把项链做得漂亮。<br />\n　　“这个嘛~首先你要在这里加上一个这种颜色的珠子，然后在这里去掉这个珠子，然后……，最后你看看是不是漂亮很多咧~”土方一下子说出了m个修改步骤。<br />\n　　盾神觉得这个用人工做太麻烦了，于是交给了你。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行两个数，分别为n，m。<br />\n　　第二行n个数，表示盾神一开始的项链。第i个数表示第i颗珠子的颜色。<br />\n　　接下来m行，为以下形式之一：<br />\n　　ADD P Q：表示在颜色为P的珠子前面加上一个颜色为Q的珠子。<br />\n　　DEL P：表示把颜色为P的珠子去掉，如果它不在端点处，则需要把它旁边的两颗珠子连起来。例如某时刻项链状态为1 4 5 8，则执行DEL 4会变成1 5 8，执行DEL 1会变成4 5 8。<br />\n　　输入保证在每次操作之前，项链有颜色为P的珠子，且任意时刻珠子颜色互不相同。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第一行为一个数len，为做完所有操作后，项链的长度。<br />\n　　第二行len个数，表示此时项链的状态。第i个数表示第i颗珠子的颜色。</div><div class='pdsec'>样例输入</div><div class='pddata'>10 5<br />\n1 2 3 4 5 6 7 8 9 10<br />\nDEL 5<br />\nADD 7 5<br />\nDEL 10<br />\nADD 4 20<br />\nADD 20 12</div><div class='pdsec'>样例输出</div><div class='pddata'>11<br />\n1 2 3 12 20 4 6 5 7 8 9</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　表示颜色的数字不超过10^5的正数，1&lt;=n&lt;=10^4，1&lt;=m&lt;=10^4。</div>\n","gpid":"T360","lanqiaotitle":"盾神与条状项链","memorylimit":"256.0MB","tid":"ADV-193","timelimit":"1.0s","title":"算法提高 盾神与条状项链","src":"程设第7章出题"},{"checkpoint":"循环、枚举","updatetime":"2016-01-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　0、1、2三个数字的全排列有六种，按照字母序排列如下：<br />\n　　012、021、102、120、201、210<br />\n　　输入一个数n<br />\n　　求0~9十个数的全排列中的第n个（第1个为0123456789）。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一行，包含一个整数n</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行，包含一组10个数字的全排列</div><div class='pdsec'>样例输入</div><div class='pddata'>1</div><div class='pdsec'>样例输出</div><div class='pddata'>0123456789</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　0 &lt; n &lt;= 10!</div>\n","gpid":"T352","lanqiaotitle":"排列数","memorylimit":"256.0MB","tid":"ADV-188","timelimit":"1.0s","title":"算法提高 排列数","src":"project euler problem 24改编"},{"checkpoint":"加法","updatetime":"2015-12-18","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　小于10的自然数中有四个数字能除尽3或5（3， 5， 6， 9），它们的和为23。<br />\n　　请计算所有小于1000的自然数中能除尽3或5的数字的合。然后使用标准输出cout，输出你的结果。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　无。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行一个整数，表示你的结果。</div>\n","gpid":"T332","lanqiaotitle":"简单加法","memorylimit":"256.0MB","tid":"ADV-178","timelimit":"1.0s","title":"算法提高 简单加法","src":""},{"checkpoint":"简单排序","updatetime":"2015-12-15","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　﻿输入三个数，比较其大小，并从大到小输出。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一行三个整数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行三个整数，从大到小排序。</div><div class='pdsec'>样例输入</div><div class='pddata'>33 88 77</div><div class='pdsec'>样例输出</div><div class='pddata'>88 77 33</div>\n","gpid":"T329","lanqiaotitle":"三个整数的排序","memorylimit":"256.0MB","tid":"ADV-175","timelimit":"1.0s","title":"算法提高 三个整数的排序","src":""},{"checkpoint":"字符串 模拟","updatetime":"2015-12-11","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　从1999年10月1日开始，公民身份证号码由15位数字增至18位。(18位身份证号码简介)。升级方法为：<br />\n　　1、把15位身份证号码中的年份由2位(7,8位)改为四位。<br />\n　　2、最后添加一位验证码。验证码的计算方案：<br />\n　　将前 17 位分别乘以对应系数 (7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2)  并相加，然后除以 11 取余数，0-10 分别对应 1 0 x 9 8 7 6 5 4 3 2。<br />\n　　请编写一个程序，用户输入15位身份证号码，程序生成18位身份证号码。假设所有要升级的身份证的四位年份都是19××年</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一个15位的数字串，作为身份证号码</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个18位的字符串，作为升级后的身份证号码</div><div class='pdsec'>样例输入</div><div class='pddata'>110105491231002</div><div class='pdsec'>样例输出</div><div class='pddata'>11010519491231002x</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　不用判断输入的15位字符串是否合理</div>\n","gpid":"T325","lanqiaotitle":"身份证号码升级","memorylimit":"256.0MB","tid":"ADV-171","timelimit":"1.0s","title":"算法提高 身份证号码升级","src":"原创"},{"checkpoint":"贪心 快排","updatetime":"2015-12-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　\"嘟嘟嘟嘟嘟嘟<br />\n　　喇叭响<br />\n　　我是汽车小司机<br />\n　　我是小司机<br />\n　　我为祖国运输忙<br />\n　　运输忙\"<br />\n　　这是儿歌“快乐的小司机”。话说现在当司机光有红心不行，还要多拉快跑。多拉不是超载，是要让所载货物价值最大，特别是在当前油价日新月异的时候。司机所拉货物为散货，如大米、面粉、沙石、泥土......<br />\n　　现在知道了汽车核载重量为w，可供选择的物品的数量n。每个物品的重量为gi,价值为pi。求汽车可装载的最大价值。（n&lt;10000,w&lt;10000,0&lt;gi&lt;=100,0&lt;=pi&lt;=100)</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入第一行为由空格分开的两个整数n w<br />\n　　第二行到第n+1行，每行有两个整数，由空格分开，分别表示gi和pi</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　最大价值（保留一位小数）</div><div class='pdsec'>样例输入</div><div class='pddata'>5 36<br />\n99 87<br />\n68 36<br />\n79 43<br />\n75 94<br />\n7 35</div><div class='pdsec'>样例输出</div><div class='pddata'>71.3<br />\n解释：<br />\n先装第5号物品，得价值35，占用重量7<br />\n再装第4号物品，得价值36.346,占用重量29<br />\n最后保留一位小数，得71.3</div>\n","gpid":"T321","lanqiaotitle":"快乐司机","memorylimit":"256.0MB","tid":"ADV-167","timelimit":"1.0s","title":"算法提高 快乐司机","src":"原创"},{"checkpoint":"动态规划","updatetime":"2015-12-01","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：<br />\n<table cellspacing=0 cellpadding=2px style='border-collapse:collapse;' class='table table-striped table-horver'><tbody><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>主件</td><td style='border:solid 1.0pt'>附件</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>电脑</td><td style='border:solid 1.0pt'>打印机，扫描仪</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>书柜</td><td style='border:solid 1.0pt'>图书</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>书桌</td><td style='border:solid 1.0pt'>台灯，文具</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>工作椅</td><td style='border:solid 1.0pt'>无</td></tr></tbody></table><br />\n　　如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。<br />\n　　设第j件物品的价格为v[j]，重要度为w[j]，共选中了k件物品，编号依次为j_1，j_2，……，j_k，则所求的总和为：<br />\n　　v[j_1]*w[j_1]+v[j_2]*w[j_2]+ …+v[j_k]*w[j_k]。（其中*为乘号）<br />\n　　请你帮助金明设计一个满足要求的购物单。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入文件budget.in 的第1行，为两个正整数，用一个空格隔开：<br />\n　　N  m<br />\n　　（其中N（&lt;32000）表示总钱数，m（&lt;60）为希望购买物品的个数。）<br />\n　　从第2行到第m+1行，第j行给出了编号为j-1的物品的基本数据，每行有3个非负整数<br />\n　　v  p  q<br />\n　　（其中v表示该物品的价格（v&lt;10000），p表示该物品的重要度（1~5），q表示该物品是主件还是附件。如果q=0，表示该物品为主件，如果q&gt;0，表示该物品为附件，q是所属主件的编号）</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出文件budget.out只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（&lt;200000）。</div><div class='pdsec'>样例输入</div><div class='pddata'>1000 5<br />\n800 2 0<br />\n400 5 1<br />\n300 5 1<br />\n400 3 0<br />\n500 2 0</div><div class='pdsec'>样例输出</div><div class='pddata'>2200</div>\n","gpid":"T317","lanqiaotitle":"金明的预算方案","memorylimit":"256.0MB","tid":"ADV-164","timelimit":"1.0s","title":"算法提高 金明的预算方案","src":"NOIP 2006 提高组"},{"checkpoint":"","updatetime":"2015-11-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定 <i>N </i>个整数，请你找出这 <i>N </i>个数中最大的那个和最小的那个。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含一个正整数 <i>N</i> 。(1 ≤ <i>N</i> ≤ 10000)。<br />\n　　第二行为 <i>N</i> 个用空格隔开的整数,每个数的绝对值不超过 1000000。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出仅一行,包含两个整数 <i>x</i>,<i>y</i>，<i>x</i> 表示 <i>N</i> 个数中的最大值，<i>y</i> 表示 <i>N</i> 个数中的最小值。<i>x</i>,<i>y</i> 之间用一个空格隔开。</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\n2 0 1 2</div><div class='pdsec'>样例输出</div><div class='pddata'>2 0</div>\n","gpid":"T315","lanqiaotitle":"题目1 最大最小值","memorylimit":"1.0GB","tid":"ADV-162","timelimit":"1.0s","title":"算法提高 题目1 最大最小值","src":""},{"checkpoint":"","updatetime":"2015-11-23","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　L正在出题，新建了一个word文档，想不好取什么名字，身旁一人惊问：“你出的题目叫《新建Microsoft Word文档》吗？”，L大喜，一拍桌子，说：“好，就叫这个名字了。”<br />\n　　仔细观察，当你新建一个word文档时，会得到一个名为“新建 Microsoft Word 文档.doc”的文件，再新建一个，则名为“新建 Microsoft Word 文档(2).doc”，再新建，便是“新建 Microsoft Word 文档(3).doc”。不断新建，编号不断递增。倘若你现在新建了三个文档，然后删除了“新建 Microsoft Word 文档(2).doc”，再新建就又会得到一个“新建 Microsoft Word 文档(2).doc”。<br />\n<br />\n　　严格说，Windows在每次新建文档时，都会选取一个与已有文件编号不重复的最小正整数作为新文档的编号。<br />\n<br />\n　　请编程模拟以上过程，支持以下两种操作<br />\n　　New：新建一个word文档，反馈新建的文档的编号<br />\n　　Delete id：删除一个编号为id的word文档，反馈删除是否成功<br />\n　　初始时一个文件都没有，“新建 Microsoft Word 文档.doc”的编号算作1。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个正整数n表示操作次数，接下来n行，每行表示一个操作。若该行为”New”，则表示新建，为”Delete id”则表示要删除编号为id的文档，其中id为一个正整数。操作按输入顺序依次进行。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于输入的每一行，输出其反馈结果。对于新建操作，输出新建的文档的编号；对于删除操作，反馈删除是否成功：如果删除的文件存在，则删除成功，输出”Successful”，否则输出”Failed”。</div><div class='pdsec'>样例输入</div><div class='pddata'>12<br />\nNew<br />\nNew<br />\nNew<br />\nDelete 2<br />\nNew<br />\nDelete 4<br />\nDelete 3<br />\nDelete 1<br />\nNew<br />\nNew<br />\nNew<br />\nDelete 4</div><div class='pdsec'>样例输出</div><div class='pddata'>1<br />\n2<br />\n3<br />\nSuccessful<br />\n2<br />\nFailed<br />\nSuccessful<br />\nSuccessful<br />\n1<br />\n3<br />\n4<br />\nSuccessful</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　操作次数（即输入的行数）不超过1481<br />\n　　删除编号的数值不超过2012</div>\n","gpid":"T309","lanqiaotitle":"新建Microsoft Word文档","memorylimit":"256.0MB","tid":"ADV-158","timelimit":"1.0s","title":"算法提高 新建Microsoft Word文档","src":""},{"checkpoint":"","updatetime":"2015-11-20","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　第一分钟，上帝说：要有题。于是就有了L，Y，M，C<br />\n　　第二分钟，LYC说：要有向量。于是就有了长度为n写满随机整数的向量<br />\n　　第三分钟，YUHCH说：要有查询。于是就有了Q个查询，查询向量的一段区间内元素的最小值<br />\n　　第四分钟，MZC说：要有限。于是就有了数据范围<br />\n　　第五分钟，CS说：要有做题的。说完众神一哄而散，留你来收拾此题</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行两个正整数n和Q，表示向量长度和查询个数<br />\n　　接下来一行n个整数，依次对应向量中元素：a[0]，a[1]，…，a[n-1]<br />\n　　接下来Q行，每行两个正整数lo，hi，表示查询区间[lo, hi]中的最小值，即min(a[lo],a[lo+1],…,a[hi])。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　共Q行，依次对应每个查询的结果，即向量在对应查询区间中的最小值。</div><div class='pdsec'>样例输入</div><div class='pddata'>7 4<br />\n1 -1 -4 8 1 2 -7<br />\n0 0<br />\n1 3<br />\n4 5<br />\n0 6</div><div class='pdsec'>样例输出</div><div class='pddata'>1<br />\n-4<br />\n1<br />\n-7</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　第一个查询[0,0]表示求min{a[0]}=min{1}=1<br />\n　　第二个查询[1,3]表示求min{a[1],a[2],a[3]}=min{-1,-4,8}=-4<br />\n　　第三个查询[4,5]表示求min{a[4],a[5]}=min{1,2}=1<br />\n　　第四个查询[0,6]表示查询整个向量，求min{a[0..6]}=min{1,-1,-4,8,1,2,-7}=-7</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=n&lt;=1984，1&lt;=Q&lt;=1988，向量中随机整数的绝对值不超过1,000</div>\n","gpid":"T306","lanqiaotitle":"上帝造题五分钟","memorylimit":"256.0MB","tid":"ADV-155","timelimit":"1.0s","title":"算法提高 上帝造题五分钟","src":""},{"checkpoint":"","updatetime":"2015-11-16","content":"<div class='pdcont'>　　金陵十三钗<br />\n　　本题难度：难<br />\n　　本题占分比例：5%</div><div class='pdsec'>问题描述</div><div class='pdcont'>　　在电影《金陵十三钗》中有十二个秦淮河的女人要自我牺牲代替十二个女学生去赴日本人的死亡宴会。为了不让日本人发现，自然需要一番乔装打扮。但由于天生材质的原因，每个人和每个人之间的相似度是不同的。由于我们这是编程题，因此情况就变成了金陵n钗。给出n个女人和n个学生的相似度矩阵，求她们之间的匹配所能获得的最大相似度。<br />\n　　所谓相似度矩阵是一个n*n的二维数组like[i][j]。其中i,j分别为女人的编号和学生的编号，皆从0到n-1编号。like[i][j]是一个0到100的整数值，表示第i个女人和第j个学生的相似度，值越大相似度越大，比如0表示完全不相似，100表示百分之百一样。每个女人都需要找一个自己代替的女学生。<br />\n　　最终要使两边一一配对，形成一个匹配。请编程找到一种匹配方案，使各对女人和女学生之间的相似度之和最大。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个正整数n表示有n个秦淮河女人和n个女学生<br />\n　　接下来n行给出相似度，每行n个0到100的整数，依次对应二维矩阵的n行n列。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　仅一行，一个整数，表示可获得的最大相似度。</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\n97 91 68 14<br />\n8 33 27 92<br />\n36 32 98 53<br />\n73 7 17 82</div><div class='pdsec'>样例输出</div><div class='pddata'>354</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于70%的数据，n&lt;=10<br />\n　　对于100%的数据，n&lt;=13</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　最大相似度为91+92+93+73=354</div>\n","gpid":"T300","lanqiaotitle":"金陵十三钗","memorylimit":"256.0MB","tid":"ADV-151","timelimit":"1.0s","title":"算法提高 金陵十三钗","src":""},{"checkpoint":"字符串处理","updatetime":"2015-11-16","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　右右喜欢听故事，但是右右的妈妈总是讲一些“从前有座山，山里有座庙，庙里有个老和尚给小和尚讲故事，讲的什么呢？从前有座山……”这样循环的故事来搪塞右右。<br />\n　　我们定义，如果一个字符串是以一个或者一个以上的长度为k的重复字符串所连接成的，那么这个字符串就叫做周期为k的串。<br />\n　　例如:<br />\n　　字符串’abcabcabcabc’周期为3，因为它是由4个循环’abc’组成的。它同样是以6为周期（两个重复的’abcabc’）和以12为周期（一个循环’abcabcabcabc’）。<br />\n　　右右现在想给他的朋友大灰狼转述妈妈讲的故事，请帮他写一个程序，可以测定一个字符串的最小周期。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一个最大长度为100的无空格的字符串。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个整数，表示输入的字符串的最小周期。</div><div class='pdsec'>样例输入</div><div class='pddata'>HaHaHa</div><div class='pdsec'>样例输出</div><div class='pddata'>2</div><div class='pdsec'>样例输入</div><div class='pddata'>Return0</div><div class='pdsec'>样例输出</div><div class='pddata'>7</div>\n","gpid":"T297","lanqiaotitle":"周期字串","memorylimit":"256.0MB","tid":"ADV-150","timelimit":"1.0s","title":"算法提高 周期字串","src":""},{"checkpoint":"广搜 bfs 经典问题","updatetime":"2015-11-06","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　学霸抢走了大家的作业，班长为了帮同学们找回作业，决定去找学霸决斗。但学霸为了不要别人打扰，住在一个城堡里，城堡外面是一个二维的格子迷宫，要进城堡必须得先通过迷宫。因为班长还有妹子要陪，磨刀不误砍柴功，他为了节约时间，从线人那里搞到了迷宫的地图，准备提前计算最短的路线。可是他现在正向妹子解释这件事情，于是就委托你帮他找一条最短的路线。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行两个整数n， m，为迷宫的长宽。<br />\n　　接下来n行，每行m个数，数之间没有间隔，为0或1中的一个。0表示这个格子可以通过，1表示不可以。假设你现在已经在迷宫坐标(1,1)的地方，即左上角，迷宫的出口在(n,m)。每次移动时只能向上下左右4个方向移动到另外一个可以通过的格子里，每次移动算一步。数据保证(1,1)，(n,m)可以通过。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第一行一个数为需要的最少步数K。<br />\n　　第二行K个字符，每个字符∈{U,D,L,R},分别表示上下左右。如果有多条长度相同的最短路径，选择在此表示方法下字典序最小的一个。</div><div class='pdsec'>样例输入</div><div class='pddata'>Input Sample 1:<br />\n3 3<br />\n001<br />\n100<br />\n110<br />\n<br />\nInput Sample 2:<br />\n3 3<br />\n000<br />\n000<br />\n000</div><div class='pdsec'>样例输出</div><div class='pddata'>Output Sample 1:<br />\n4<br />\nRDRD<br />\n<br />\nOutput Sample 2:<br />\n4<br />\nDDRR</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　有20%的数据满足：1&lt;=n,m&lt;=10<br />\n　　有50%的数据满足：1&lt;=n,m&lt;=50<br />\n　　有100%的数据满足：1&lt;=n,m&lt;=500。</div>\n","gpid":"T291","lanqiaotitle":"学霸的迷宫","memorylimit":"256.0MB","tid":"ADV-147","timelimit":"1.0s","title":"算法提高 学霸的迷宫","src":""},{"checkpoint":"小教员","updatetime":"2015-11-04","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定N个物品,每个物品有一个重量W和一个价值V.你有一个能装M重量的背包.问怎么装使得所装价值最大.每个物品只有一个.</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含两个整数n, m，分别表示物品的个数和背包能装重量。<br />\n　　以后N行每行两个数Wi和Vi,表示物品的重量和价值</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出1行，包含一个整数，表示最大价值。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 5<br />\n2 3<br />\n3 5<br />\n4 7</div><div class='pdsec'>样例输出</div><div class='pddata'>8</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=N&lt;=200,M&lt;=5000.</div>\n","gpid":"T287","lanqiaotitle":"01背包","memorylimit":"256.0MB","tid":"ADV-144","timelimit":"1.0s","title":"算法提高 01背包","src":""},{"checkpoint":"逻辑推理","updatetime":"2015-10-30","content":"<div class='pdcont'>　　一共有5个红领巾，编号分别为A、B、C、D、E，老奶奶被他们其中一个扶过了马路。<br />\n<br />\n　　五个红领巾各自说话：<br />\n<br />\n　　A ：我和E都没有扶老奶奶<br />\n<br />\n　　B ：老奶奶是被C和E其中一个扶过大街的<br />\n<br />\n　　C ：老奶奶是被我和D其中一个扶过大街的<br />\n<br />\n　　D ：B和C都没有扶老奶奶过街<br />\n<br />\n　　E ：我没有扶老奶奶<br />\n<br />\n<br />\n　　已知五个红领巾中有且只有２个人说的是真话，请问是谁扶这老奶奶过了街？<br />\n<br />\n　　若有多个答案，在一行中输出，编号之间用空格隔开。<br />\n<br />\n<br />\n　　例如<br />\n　　A B C D E（这显然不是正确答案）﻿</div>\n","gpid":"T286","lanqiaotitle":"扶老奶奶过街","memorylimit":"256.0MB","tid":"ADV-143","timelimit":"1.0s","title":"算法提高 扶老奶奶过街","src":""},{"checkpoint":"逻辑题, 第12周","updatetime":"2015-10-29","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　某场比赛过后，你想要知道A~E五个人的排名是什么，于是要求他们每个人说了一句话。（经典的开头……-_-!）得了第1名的人23，说了假话；得了第5名的人不好意思，也说了假话；为了使求解问题简单，第3名同样说了假话。（奇数名次说假话）</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　共5行，各行依次表示A~E说的话。<br />\n　　每行包含一个形如“A&gt;=3”的名次判断，即一个大写字母+关系运算符+一个数字，不包含空格。<br />\n　　大写字母A~E，关系运算&lt;、&lt;=、=、&gt;=、&gt;、!=，数字1~5。注意：等于是“=”不是“==”！</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　可能有多解，请按照字典序输出排名序列，每个解一行<br />\n　　最后一行输出解的数量</div><div class='pdsec'>样例输入</div><div class='pddata'>A=2<br />\nD=5<br />\nE&gt;3<br />\nA&gt;2<br />\nB!=1</div><div class='pdsec'>样例输出</div><div class='pddata'>ACDEB<br />\nAECBD<br />\nBADCE<br />\nBCADE<br />\nBDACE<br />\nCEADB<br />\nCEBDA<br />\n7</div>\n","gpid":"T284","lanqiaotitle":"判断名次","memorylimit":"256.0MB","tid":"ADV-141","timelimit":"1.0s","title":"算法提高 判断名次","src":""},{"checkpoint":"","updatetime":"2015-02-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　已知2011年11月11日是星期五，问YYYY年MM月DD日是星期几？注意考虑闰年的情况。尤其是逢百年不闰，逢400年闰的情况。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入只有一行<br />\n　　YYYY MM DD</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出只有一行<br />\n　　W</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1599 &lt;= YYYY &lt;= 2999<br />\n　　1 &lt;= MM &lt;= 12<br />\n　　1 &lt;= DD &lt;= 31，且确保测试样例中YYYY年MM月DD日是一个合理日期<br />\n　　1 &lt;= W &lt;= 7，分别代表周一到周日</div><div class='pdsec'>样例输入</div><div class='pddata'>2011 11 11</div><div class='pdsec'>样例输出</div><div class='pddata'>5</div>\n","gpid":"T265","lanqiaotitle":"日期计算","memorylimit":"256.0MB","tid":"ADV-127","timelimit":"1.0s","title":"算法提高 日期计算","src":""},{"checkpoint":"动态规划","updatetime":"2015-01-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　生成n个∈[a,b]的随机整数，输出它们的和为x的概率。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一行输入四个整数依次为n，a，b，x，用空格分隔。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行包含一个小数位和为x的概率，小数点后保留四位小数</div><div class='pdsec'>样例输入</div><div class='pddata'>2 1 3 4</div><div class='pdsec'>样例输出</div><div class='pddata'>0.3333</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于50%的数据，n≤5.<br />\n　　对于100%的数据，n≤100,b≤100.</div>\n","gpid":"T259","lanqiaotitle":"概率计算","memorylimit":"256.0MB","tid":"ADV-123","timelimit":"1.0s","title":"算法提高 概率计算","src":""},{"checkpoint":"","updatetime":"2015-01-22","content":"<div class='pdcont'>　　设计复数库，实现基本的复数加减乘除运算。<br />\n　　输入时只需分别键入实部和虚部，以空格分割，两个复数之间用运算符分隔；输出时按a+bi的格式在屏幕上打印结果。参加样例输入和样例输出。<br />\n　　注意考虑特殊情况，无法计算时输出字符串\"error\"。</div><div class='pdsec'>样例输入</div><div class='pddata'>2 4 * -3 2</div><div class='pdsec'>样例输出</div><div class='pddata'>-14-8i</div><div class='pdsec'>样例输入</div><div class='pddata'>3 -2 + -1 3</div><div class='pdsec'>样例输出</div><div class='pddata'>2+1i</div>\n","gpid":"T255","lanqiaotitle":"6-17复数四则运算","memorylimit":"512.0MB","tid":"ADV-120","timelimit":"1.0s","title":"算法提高 6-17复数四则运算","src":""},{"checkpoint":"","updatetime":"2014-12-30","content":"<div class='pdcont'>　　编写一个程序，利用强制类型转换打印元音字母大小写10种形式的ASCII码。<br />\n　　输出的顺序为：大写的字母A，E，I，O，U的ASCII码，小写的字母a，e，i，o，u的ASCII码。所有的ASCII码都用十进制表示.输出10行,每行一个ASCII码，最后输出一个空行。</div>\n","gpid":"T237","lanqiaotitle":"c++_ch02_01","memorylimit":"512.0MB","tid":"ADV-112","timelimit":"1.0s","title":"算法提高 c++_ch02_01","src":""},{"checkpoint":"循环语句 数组操作","updatetime":"2014-11-20","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编写一个程序，读入一组整数（不超过20个），并把它们保存在一个整型数组中。当用户输入0时，表示输入结束。然后程序将把这个数组中的值按逆序重新存放，并打印出来。例如：假设用户输入了一组数据：7 19 -5 6 2 0，那么程序将会把前五个有效数据保存在一个数组中，即7 19 -5 6 2，然后把这个数组中的值按逆序重新存放，即变成了2 6 -5 19 7，然后把它们打印出来。<br />\n　　输入格式：输入只有一行，由若干个整数组成，中间用空格隔开，最末尾的整数为0。<br />\n　　输出格式：输出也只有一行，即逆序排列后的整数，中间用空格隔开，末尾没有空格。<br />\n　　输入输出样例</div><div class='pdsec'>样例输入</div><div class='pddata'>7 19 -5 6 2 0</div><div class='pdsec'>样例输出</div><div class='pddata'>2 6 -5 19 7</div>\n","gpid":"T215","lanqiaotitle":"逆序排列","memorylimit":"512.0MB","tid":"ADV-103","timelimit":"1.0s","title":"算法提高 逆序排列","src":"程序设计公共基础课(谌卫军)"},{"checkpoint":"逻辑判断 循环语句","updatetime":"2014-11-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编写一个程序，读入一组整数（不超过20个），当用户输入0时，表示输入结束。然后程序将从这组整数中，把第二大的那个整数找出来，并把它打印出来。说明：（1）0表示输入结束，它本身并不计入这组整数中。（2）在这组整数中，既有正数，也可能有负数。（3）这组整数的个数不少于2个。<br />\n　　输入格式：输入只有一行，包括若干个整数，中间用空格隔开，最后一个整数为0。<br />\n　　输出格式：输出第二大的那个整数。<br />\n　　输入输出样例</div><div class='pdsec'>样例输入</div><div class='pddata'>5 8 -12 7 0</div><div class='pdsec'>样例输出</div><div class='pddata'>7</div>\n","gpid":"T211","lanqiaotitle":"第二大整数","memorylimit":"512.0MB","tid":"ADV-100","timelimit":"1.0s","title":"算法提高 第二大整数","src":"程序设计公共基础课(谌卫军)"},{"checkpoint":"","updatetime":"2014-11-17","content":"<div class='pdcont'>　　输入一个正整数N (1</div><div class='pdsec'>样例输入</div><div class='pddata'>12</div><div class='pdsec'>样例输出</div><div class='pddata'>6</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　12的约数包括：1,2,3,4,6,12。共6个</div>\n","gpid":"T209","lanqiaotitle":"约数个数","memorylimit":"512.0MB","tid":"ADV-98","timelimit":"1.0s","title":"算法提高 约数个数","src":""},{"checkpoint":"","updatetime":"2014-11-13","content":"<pre class='pddata'>\n编写函数，其功能为把一个十进制数转换为其对应的八进制数。程序读入一个十进制数，调用该函数实现数制转换后，输出对应的八进制数。\n<br /> 样例输入<br /> 9274<br /> 样例输出<br /> 22072\n样例输入<br /> 18<br /> 样例输出<br /> 22\n</pre>\n\n","gpid":"T207","lanqiaotitle":"十进制数转八进制数","memorylimit":"512.0MB","tid":"ADV-97","timelimit":"1.0s","title":"算法提高 十进制数转八进制数","src":""},{"checkpoint":"","updatetime":"2014-11-12","content":"<pre class='pddata'>\n编写函数Normalize，将复数归一化，即若复数为a+bi，归一化结果为a/sqrt(a*a+b*b) + i*b/sqrt(a*a+b*b) 。使用结构体指针类型作为函数参数可能是必要的。其中实部和虚部由键盘输入，输出为归一化结果，如果归一化结果的实部或虚部为小数的要求保留一位小数。\n</pre>\n<pre class='pddata'>\n<br />样例输入:（格式说明：3 4 分别为以空格隔开的实数的实部和虚部） <br />3 4 <br />样例输出:<br />0.6+0.8i\n</pre>\n<pre class='pddata'>\n样例输入: <br />2 5<br />样例输出:<br />0.4+0.9i<br />\n</pre>\n\n","gpid":"T203","lanqiaotitle":"复数归一化","memorylimit":"512.0MB","tid":"ADV-94","timelimit":"1.0s","title":"算法提高 复数归一化","src":""},{"checkpoint":"","updatetime":"2014-04-10","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　对于n个数，从中取出m个数，如何取使得这m个数的乘积最大呢？</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个数表示数据组数<br />\n　　每组输入数据共2行：<br />\n　　第1行给出总共的数字的个数n和要取的数的个数m，1&lt;=n&lt;=m&lt;=15，<br />\n　　第2行依次给出这n个数，其中每个数字的范围满足:a[i]的绝对值小于等于4。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　每组数据输出1行，为最大的乘积。</div><div class='pdsec'>样例输入</div><div class='pddata'>1<br />\n5 5<br />\n1 2 3 4 2</div><div class='pdsec'>样例输出</div><pre class='pddata'>\n<font face=\"Times New Roman\" size=\"3\">48 </font>\n</pre>\n\n","gpid":"T136","lanqiaotitle":"最大乘积","memorylimit":"512.0MB","tid":"ADV-15","timelimit":"1.0s","title":"算法提高 最大乘积","src":""},{"checkpoint":"最小生成树","updatetime":"2013-10-16","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n    给定带权无向图，求出一颗方差最小的生成树。\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n   输入多组测试数据。第一行为N,M，依次是点数和边数。接下来M行，每行三个整数U,V,W，代表连接U,V的边，和权值W。保证图连通。n=m=0标志着测试文件的结束。 \n </div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n    对于每组数据，输出最小方差，四舍五入到0.01。输出格式按照样例。\n</div>\n<div class=\"sec_header\">\n样例输入</div>\n<div class=\"sec_text\">\n4 5<br />\n1 2 1<br />\n2 3 2<br />\n3 4 2<br />\n4 1 1<br />\n2 4 3<br />\n4 6<br />\n1 2 1<br />\n2 3 2<br />\n3 4 3<br />\n4 1 1<br />\n2 4 3<br />\n1 3 3<br />\n0 0\n\n</div>\n<div class=\"sec_header\">\n样例输出</div>\n<div class=\"sec_text\">\nCase 1: 0.22<br />\nCase 2: 0.00\n\t</div>\n<div class=\"sec_header\">\n数据规模与约定</div>\n<div class=\"sec_cont\">\n<p>1&lt;=U,V&lt;=N&lt;=50,N-1&lt;=M&lt;=1000,0&lt;=W&lt;=50。数据不超过5组。</p>\n</div>\n","gpid":"T23","lanqiaotitle":"最小方差生成树","memorylimit":"256.0MB","tid":"ADV-5","timelimit":"1.0s","title":"算法提高 最小方差生成树","src":""},{"checkpoint":"最短路","updatetime":"2013-10-16","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n<p>农夫约翰正在针对一个新区域的牛奶配送合同进行研究。他打算分发牛奶到T个城镇（标号为1..T），这些城镇通过R条标号为（1..R）的道路和P条标号为（1..P）的航路相连。</p>\n<p>每一条公路i或者航路i表示成连接城镇A<sub>i</sub>（1&lt;=A_i&lt;=T）和B<sub>i</sub>（1&lt;=B<sub>i</sub>&lt;=T）代价为C<sub>i</sub>。每一条公路，C<sub>i</sub>的范围为0&lt;=C<sub>i</sub>&lt;=10,000；由于奇怪的运营策略，每一条航路的C<sub>i</sub>可能为负的，也就是-10,000&lt;=C<sub>i</sub>&lt;=10,000。</p>\n<p>每一条公路都是双向的，正向和反向的花费是一样的，都是非负的。</p>\n<p>每一条航路都根据输入的A<sub>i</sub>和B<sub>i</sub>进行从A<sub>i</sub>-&gt;B<sub>i</sub>的单向通行。实际上，如果现在有一条航路是从A<sub>i</sub>到B<sub>i</sub>的话，那么意味着肯定没有通行方案从B<sub>i</sub>回到A<sub>i</sub>。</p>\n<p>农夫约翰想把他那优良的牛奶从配送中心送到各个城镇，当然希望代价越小越好，你可以帮助他嘛？配送中心位于城镇S中（1<=S<=T）。</p>\n\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\t<p>输入的第一行包含四个用空格隔开的整数T，R，P，S。</p>\n\t<p>接下来R行，描述公路信息，每行包含三个整数，分别表示A<sub>i</sub>，B<sub>i</sub>和C<sub>i</sub>。</p>\n\t<p>接下来P行，描述航路信息，每行包含三个整数，分别表示A<sub>i</sub>，B<sub>i</sub>和C<sub>i</sub>。</p>\n</div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\t输出T行，分别表示从城镇S到每个城市的最小花费，如果到不了的话输出NO PATH。\n</div>\n<div class=\"sec_header\">\n样例输入</div>\n<div class=\"sec_text\">\n6 3 3 4<br />\n1 2 5<br />\n3 4 5<br />\n5 6 10<br />\n3 5 -100<br />\n4 6 -100<br />\n1 3 -10\n</div>\n<div class=\"sec_header\">\n样例输出</div>\n<div class=\"sec_text\">\nNO PATH<br />\nNO PATH<br />\n5<br />\n0<br />\n-95<br />\n-100\n\t</div>\n<div class=\"sec_header\">\n数据规模与约定</div>\n<div class=\"sec_cont\">\n<p>对于20%的数据，T&lt;=100，R&lt;=500，P&lt;=500；</p>\n<p>对于30%的数据，R&lt;=1000，R&lt;=10000，P&lt;=3000；</p>\n<p>对于100%的数据，1&lt;=T&lt;=25000，1&lt;=R&lt;=50000，1&lt;=P&lt;=50000。</p>\n</div>\n","gpid":"T22","lanqiaotitle":"道路和航路","memorylimit":"256.0MB","tid":"ADV-4","timelimit":"1.0s","title":"算法提高 道路和航路","src":""},{"checkpoint":"树形动态规划","updatetime":"2013-10-16","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n\t<p>人类在火星上发现了一种新的金属！这些金属分布在一些奇怪的地方，不妨叫它节点好了。一些节点之间有道路相连，所有的节点和道路形成了一棵树。一共有 n 个节点，这些节点被编号为 1~n 。人类将 k 个机器人送上了火星，目的是采集这些金属。这些机器人都被送到了一个指定的着落点， S 号节点。每个机器人在着落之后，必须沿着道路行走。当机器人到达一个节点时，它会采集这个节点蕴藏的所有金属矿。当机器人完成自己的任务之后，可以从任意一个节点返回地球。当然，回到地球的机器人就无法再到火星去了。我们已经提前测量出了每条道路的信息，包括它的两个端点 x 和 y，以及通过这条道路需要花费的能量 w 。我们想花费尽量少的能量采集所有节点的金属，这个任务就交给你了。</p>\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\t<p>第一行包含三个整数 n, S 和 k ，分别代表节点个数、着落点编号，和机器人个数。</p>\n\t<p>接下来一共 n-1 行，每行描述一条道路。一行含有三个整数 x, y 和 w ，代表在 x 号节点和 y 号节点之间有一条道路，通过需要花费 w 个单位的能量。所有道路都可以双向通行。</p>\n</div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\t输出一个整数，代表采集所有节点的金属所需要的最少能量。\n</div>\n<div class=\"sec_header\">\n样例输入</div>\n<div class=\"sec_text\">\n6 1 3<br />\n1 2 1<br />\n2 3 1<br />\n2 4 1000<br />\n2 5 1000<br />\n1 6 1000\n</div>\n<div class=\"sec_header\">\n样例输出</div>\n<div class=\"sec_text\">\n3004\n\t</div>\n<div class=\"sec_header\">\n样例说明</div>\n<div class=\"sec_cont\">\n\t<p>所有机器人在 1 号节点着陆。</p>\n\t<p>第一个机器人的行走路径为 1-&gt;6 ，在 6 号节点返回地球，花费能量为1000。</p>\n\t<p>第二个机器人的行走路径为 1-&gt;2-&gt;3-&gt;2-&gt;4 ，在 4 号节点返回地球，花费能量为1003。</p>\n\t<p>第一个机器人的行走路径为 1-&gt;2-&gt;5 ，在 5 号节点返回地球，花费能量为1001。</p>\n</div>\n<div class=\"sec_header\">\n数据规模与约定</div>\n<div class=\"sec_cont\">\n\t<p>本题有10个测试点。\n\t<p>对于测试点 1~2 ， n &lt;= 10 ， k &lt;= 5 。</p>\n\t<p>对于测试点 3 ， n &lt;= 100000 ， k = 1 。</p>\n\t<p>对于测试点 4 ， n &lt;= 1000 ， k = 2 。</p>\n\t<p>对于测试点 5~6 ， n &lt;= 1000 ， k &lt;= 10 。</p>\n\t<p>对于测试点 7~10 ， n &lt;= 100000 ， k &lt;= 10 。</p>\n\t<p>道路的能量 w 均为不超过 1000 的正整数。</p>\n</div>\n","gpid":"T21","lanqiaotitle":"金属采集","memorylimit":"256.0MB","tid":"ADV-3","timelimit":"1.0s","title":"算法提高 金属采集","src":""},{"checkpoint":"枚举 贪心","updatetime":"2013-10-16","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n\t<p>Ciel有一个N*N的矩阵，每个格子里都有一个整数。</p>\n\t<p>N是一个奇数，设X = (N+1)/2。Ciel每次都可以做这样的一次操作：他从矩阵选出一个X*X的子矩阵，并将这个子矩阵中的所有整数都乘以-1。</p>\n\t<p>现在问你经过一些操作之后，矩阵中所有数的和最大可以为多少。</p>\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\t<p>第一行为一个正整数N。</p>\n\t<p>接下来N行每行有N个整数，表示初始矩阵中的数字。每个数的绝对值不超过1000。</p>\n</div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\t输出一个整数，表示操作后矩阵中所有数之和的最大值。\n</div>\n<div class=\"sec_header\">\n样例输入</div>\n<div class=\"sec_text\">\n3<br />\n-1 -1 1<br />\n-1 1 -1<br />\n1 -1 -1\n</div>\n<div class=\"sec_header\">\n样例输出</div>\n<div class=\"sec_text\">\n9\n\t</div>\n<div class=\"sec_header\">\n数据规模与约定</div>\n<div class=\"sec_cont\">\n\t<p>1 &lt;= N &lt;= 33，且N为奇数。</p>\n</div>\n","gpid":"T20","lanqiaotitle":"矩阵翻转","memorylimit":"256.0MB","tid":"ADV-2","timelimit":"1.0s","title":"算法提高 矩阵翻转","src":""},{"checkpoint":"排序","updatetime":"2013-10-16","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n\t<p>给定平面上n个点。</p>\n\t<p>求两条直线，这两条直线互相垂直，而且它们与x轴的夹角为45度，并且n个点中离这两条直线的曼哈顿距离的最大值最小。</p>\n\t<p>两点之间的曼哈顿距离定义为横坐标的差的绝对值与纵坐标的差的绝对值之和，一个点到两条直线的曼哈顿距离是指该点到两条直线上的所有点的曼哈顿距离中的最小值。</p>\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\t<p>第一行包含一个数n。</p>\n\t<p>接下来n行，每行包含两个整数，表示n个点的坐标（横纵坐标的绝对值小于10<sup>9</sup>）。</p>\n</div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\t输出一个值，表示最小的最大曼哈顿距离的值，保留一位小数。\n</div>\n<div class=\"sec_header\">\n样例输入</div>\n<div class=\"sec_text\">\n4<br />\n1 0<br />\n0 1<br />\n2 1<br />\n1 2\n</div>\n<div class=\"sec_header\">\n样例输出</div>\n<div class=\"sec_text\">\n1.0\n\t</div>\n<div class=\"sec_header\">\n数据规模与约定</div>\n<div class=\"sec_cont\">\n<p>对于30%的数据，n&lt;=100。</p>\n<p>对于另外30%的数据，坐标范的绝对值小于100。</p>\n<p>对于100%的数据，n&lt;=10<sup>5</sup>。</p>\n</div>\n","gpid":"T19","lanqiaotitle":"两条直线","memorylimit":"256.0MB","tid":"ADV-1","timelimit":"1.0s","title":"算法提高 两条直线","src":""},{"checkpoint":"NOIP2013 提高组","updatetime":"2020-03-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　n 个小伙伴(编号从 0 到 n-1)围坐一圈玩游戏。按照顺时针方向给 n 个位置编号,从0 到 n-1。最初,第 0 号小伙伴在第 0 号位置,第 1 号小伙伴在第 1 号位置,......,依此类 推。<br />\n　　游戏规则如下:每一轮第 0 号位置上的小伙伴顺时针走到第 m 号位置,第 1 号位置小 伙伴走到第 m+1 号位置,......,依此类推,第n &minus; m号位置上的小伙伴走到第 0 号位置,第 n-m+1 号位置上的小伙伴走到第 1 号位置,......,第 n-1 号位置上的小伙伴顺时针走到第 m-1 号位置。<br />\n　　现在,一共进行了 10<sup>k</sup> 轮,请问 x 号小伙伴最后走到了第几号位置。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入共 1 行,包含 4 个整数 n、m、k、x,每两个整数之间用一个空格隔开。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出共 1 行,包含 1 个整数,表示 10<sup>k</sup> 轮后 x 号小伙伴所在的位置编号。</div><div class='pdsec'>样例输入</div><div class='pddata'>￼10 3 4 5</div><div class='pdsec'>样例输出</div><div class='pddata'>5</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于 30%的数据,0 &lt; k &lt; 7;<br />\n　　对于 80%的数据,0 &lt; k &lt; 10<sup>7</sup>;<br />\n　　对于 100%的数据,1 &lt; n &lt; 1,000,000,0 &lt; m &lt; n,1 ≤ x ≤ n,0 &lt; k &lt; 10<sup>9</sup>。</div>\n","gpid":"T625","lanqiaotitle":"转圈游戏","memorylimit":"256.0MB","tid":"ADV-329","timelimit":"1.0s","title":"算法提高 转圈游戏","src":"NOIP2013 提高组"},{"checkpoint":"链表","updatetime":"2020-03-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　耶稣有13个门徒，其中有一个就是出卖耶稣的叛徒，请用排除法找出这位叛徒：13人围坐一圈，从第一个开始报号：1，2，3，1，2，3...。凡是报到“3”就退出圈子，最后留在圈子内的人就是出卖耶稣的叛徒请使用双向链表实现编写该程序，依次输出出局人的编号。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　无</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出13行，前12行分别是按顺序出局的人的编号。第13行输出叛徒的编号。</div>\n","gpid":"T624","lanqiaotitle":"找出出卖耶稣的人","memorylimit":"256.0MB","tid":"ADV-328","timelimit":"1.0s","title":"算法提高 找出出卖耶稣的人","src":""},{"checkpoint":"fibonacci","updatetime":"2020-03-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　某天，HWD老师开始研究兔子，因为他是个土豪<br />\n　　，所以他居然一下子买了一个可以容纳10^18代兔子的巨大笼子（好像比我们伟大的地球母亲大一点点？），并开始研究它们，之后，他了解了兔子的繁衍规律：即fibonacci数列。<br />\n　　兔子繁殖了n代后，HWD老师很开心。<br />\n　　但是，HWD老师有密集恐惧症，所以，他只能去卖了兔子，他找到了一个好的雇主，但是这个雇主有强迫症，他只每次收购1007只兔子，HWD老师为了避免自己的密集恐惧症，要尽量多的卖了兔子。<br />\n　　但是即便是密集恐惧症，也打击不了HWD老师研究兔子的决心，他数着数着自己剩下的兔子……</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　HWD老师让兔子繁衍了几代（一个整数，没有其他字符）。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　HWD老师剩余（残余？）的兔子（一个整数，忽略行尾回车及空格）。</div><div class='pdsec'>样例输入</div><div class='pddata'>1</div><div class='pdsec'>样例输出</div><div class='pddata'>1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　兔子的总量最大时小于HWD老师笼子的大小。<br />\n　　f[1]=1，f[2]=1，f[3]=2 ……</div>\n","gpid":"T623","lanqiaotitle":"研究兔子的土豪","memorylimit":"256.0MB","tid":"ADV-327","timelimit":"1.0s","title":"算法提高 研究兔子的土豪","src":"能容纳10^18代兔子的某个星球"},{"checkpoint":"fibonacci 矩阵乘法","updatetime":"2020-03-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　如果你还没有看过研究兔子的土豪，那么请你先去看那道题。<br />\n　　HWD老师研究兔子时的某天，他突然不幸的发作了他的密集恐惧症，于是只能放了他的所有兔子……然后，他还是想去研究兔子，于是捡回了他那个伟大的笼子，又买了许多兔子……他依旧开始研究，发现这两批兔子的繁衍规律完全相同……他就这么让兔子繁衍着，直到某天，他怕他的密集恐惧症重新发作，于是，他又找到了那个雇主，但这个雇主的强迫症加重了，他只每次收购10^9+7只兔子，HWD老师再次尽量多的卖出了他已久的兔子，再次数着剩下陪伴他的它们……<br />\n　　后来，HWD老师知道了两次收购他兔子的那个人其实叫LZH……</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　HWD老师让兔子繁衍了几代（一个整数，没有其他字符）。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　HWD老师剩余（残余？）的兔子（一个整数，忽略行尾回车及空格）。</div><div class='pdsec'>样例输入</div><div class='pddata'>1</div><div class='pdsec'>样例输出</div><div class='pddata'>1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　兔子的总量最大时小于HWD老师笼子的大小。<br />\n　　f[1]=1，f[2]=1，f[3]=2 ……</div>\n","gpid":"T622","lanqiaotitle":"研究兔子的土豪（疯狂雇主）","memorylimit":"256.0MB","tid":"ADV-326","timelimit":"1.0s","title":"算法提高 研究兔子的土豪（疯狂雇主）","src":"可以容纳10^18代兔子的星球"},{"checkpoint":"链表","updatetime":"2020-03-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编写一个程序，建立了一条单向链表，每个结点包含姓名、学号、英语成绩、数学成绩和C++成绩，并通过链表操作平均最高的学生和平均分最低的学生并且输出。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入n+1行，第一行输入一个正整数n，表示学生数量；接下来的n行每行输入5个数据，分别表示姓名、学号、英语成绩、数学成绩和C++成绩。注意成绩有可能会有小数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出两行，第一行输出平均成绩最高的学生姓名。第二行输出平均成绩最低的学生姓名。</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\nyx1     1       45    67    87<br />\nyx2     2       88  90     99</div><div class='pdsec'>样例输出</div><div class='pddata'>yx2<br />\nyx1</div>\n","gpid":"T621","lanqiaotitle":"学生成绩统计","memorylimit":"256.0MB","tid":"ADV-325","timelimit":"1.0s","title":"算法提高 学生成绩统计","src":""},{"checkpoint":"指针","updatetime":"2020-03-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编写程序，输入一个字符串，使用指针逐个逆序输出字符串中所有字符。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入一个字符串</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个与输入相应的逆序字符串</div><div class='pdsec'>样例输入</div><div class='pddata'>一个满足题目要求的输入范例。<br />\n<br />\nabcd</div><div class='pdsec'>样例输出</div><div class='pddata'>与上面的样例输入对应的输出。<br />\n例：<br />\ndcba</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入数据中每一个数的范围。<br />\n　　例：输入的字符串长度小于100</div>\n","gpid":"T620","lanqiaotitle":"使用指针逆序输出","memorylimit":"256.0MB","tid":"ADV-324","timelimit":"1.0s","title":"算法提高 使用指针逆序输出","src":""},{"checkpoint":"指针","updatetime":"2020-03-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编写程序，输入两个字符串，从第一个字符串中删除第二个字符串，输出删除后的字符串。例如输入”abcabcd”和”bc”，则输出”aad”。用指针实现。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入两个字符串ch1和ch2</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出删除ch2后的字符串ch1</div><div class='pdsec'>样例输入</div><div class='pddata'>一个满足题目要求的输入范例。<br />\n例：<br />\nabcabcd<br />\n<br />\nbc</div><div class='pdsec'>样例输出</div><div class='pddata'>与上面的样例输入对应的输出。<br />\n例：<br />\naad</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入数据中每一个数的范围。<br />\n　　输入的字符串长度小于100</div>\n","gpid":"T619","lanqiaotitle":"删除子字符串","memorylimit":"256.0MB","tid":"ADV-323","timelimit":"1.0s","title":"算法提高 删除子字符串","src":""},{"checkpoint":"","updatetime":"2020-03-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　从键盘输入M、N（M、N取值长整范围）两个数，求它们的最小公倍数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入文件只有一行，有两数被空格隔开，分别表示M、N的值。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　只有一个数，即M、N的最小公倍数。</div><div class='pdsec'>样例输入</div><div class='pddata'>15 20</div><div class='pdsec'>样例输出</div><div class='pddata'>60</div>\n","gpid":"T618","lanqiaotitle":"求最小公倍数","memorylimit":"256.0MB","tid":"ADV-322","timelimit":"1.0s","title":"算法提高 求最小公倍数","src":""},{"checkpoint":"排序","updatetime":"2020-03-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤100），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入有2行，第1行为1个正整数，表示所生成的随机数的个数：N<br />\n　　第2行有N个用空格隔开的正整数，为所产生的随机数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出也是2行，第1行为1个正整数M，表示不相同的随机数的个数。第2行为M个用空格隔开的正整数，为从小到大排好序的不相同的随机数。</div><div class='pdsec'>样例输入</div><div class='pddata'>10<br />\n20 40 32 67 40 20 89 300 400 15</div><div class='pdsec'>样例输出</div><div class='pddata'>8<br />\n15 20 32 40 67 89 300 400</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　（N≤100）</div>\n","gpid":"T617","lanqiaotitle":"明明的随机数","memorylimit":"256.0MB","tid":"ADV-321","timelimit":"1.0s","title":"算法提高 明明的随机数","src":"NOIP2006普及组第一题"},{"checkpoint":"","updatetime":"2020-03-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　完成一个程序，该程序计算n以内（包含n）的所有素数之和并返回。注意，提交完整的程序代码。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入一个整数 n；</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出n以前所有素数的和。</div><div class='pdsec'>样例输入</div><div class='pddata'>5</div><div class='pdsec'>样例输出</div><div class='pddata'>10</div>\n","gpid":"T616","lanqiaotitle":"计算素数和","memorylimit":"256.0MB","tid":"ADV-320","timelimit":"1.0s","title":"算法提高 计算素数和","src":""},{"checkpoint":"","updatetime":"2020-03-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给出一个有向图，输出这个图的一个哈密尔顿回路。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含两个整数n, m，分别表示图的点数和边数。<br />\n<br />\n　　接下来m行，每行包含两个整数，表示一条边的起点和终点。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行，包含一个n个整数，表示一条哈密尔顿回路。如果没有回路，输出“No Answer””。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 3<br />\n<br />\n1 2<br />\n<br />\n2 3<br />\n<br />\n3 1</div><div class='pdsec'>样例输出</div><div class='pddata'>1 2 3</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=n&lt;=20，图中没有重边。</div>\n","gpid":"T615","lanqiaotitle":"哈密尔顿回路","memorylimit":"256.0MB","tid":"ADV-319","timelimit":"2.0s","title":"算法提高 哈密尔顿回路","src":""},{"checkpoint":"","updatetime":"2020-03-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　一个有向图，求1到N的最小费用最大流</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行N M，表示点数与边数<br />\n　　接下来M行每行s t c d表示一条从s到t的容量为c费用为d的边</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　最大流与最小费用</div><div class='pdsec'>样例输入</div><div class='pddata'>6 10<br />\n1 2 4 1<br />\n1 3 8 3<br />\n2 3 4 5<br />\n2 4 4 7<br />\n2 5 1 9<br />\n3 4 2 2<br />\n3 5 2 4<br />\n4 6 7 6<br />\n5 4 6 8<br />\n5 6 3 10</div><div class='pdsec'>样例输出</div><div class='pddata'>8 112<br />\n<br />\n数据约定：<br />\nn&lt;=1000 m&lt;=2000</div>\n","gpid":"T614","lanqiaotitle":"费用流裸题","memorylimit":"256.0MB","tid":"ADV-318","timelimit":"1.0s","title":"算法提高 费用流裸题","src":""},{"checkpoint":"状态压缩 动态规划 DP ","updatetime":"2020-03-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有一个m 行n 列的矩形方格棋盘，用1*2 的骨牌(可横放或竖放)完全覆盖，骨牌不能重叠。但是，棋盘中有一些p个位置有破洞，坐标分别为（xi（第xi列），yi（第yi行））,这些位置不能放置骨牌了。请问有多少种不同的覆盖的方法。<br />\n　　请对覆盖方法总数 mod 10007 的值即可。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第 1 行，三个整数数n，m，p，<br />\n　　第 2 — p-1 行，两个整数 xi，yi 。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个整数，总数 mod 10007 的结果。</div><div class='pdsec'>样例输入</div><div class='pddata'>2 3 2<br />\n1 3<br />\n2 3</div><div class='pdsec'>样例输出</div><div class='pddata'>2</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　0&lt;n&lt;=10 , 0&lt;m&lt;=100 ，0&lt;=p&lt;=m*n。</div>\n","gpid":"T613","lanqiaotitle":"多米诺骨牌放置（加强版1）","memorylimit":"256.0MB","tid":"ADV-317","timelimit":"1.0s","title":"算法提高 多米诺骨牌放置（加强版1）","src":""},{"checkpoint":"","updatetime":"2020-03-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　You are given a number of case-sensitive strings of alphabetic characters, find the largest string X, such that either X, or its inverse can be found as a substring of any of the given strings.</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　The first line of the input contains a single integer t (1 &lt;= t &lt;= 10), the number of test cases, followed by the input data for each test case. The first line of each test case contains a single integer n (1 &lt;= n &lt;= 100), the number of given strings, followed by n lines, each representing one string of minimum length 1 and maximum length 100. There is no extra white space before and after a string.</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　There should be one line per test case containing the length of the largest string found.</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n3<br />\nABCD<br />\nBCDFF<br />\nBRCD<br />\n2<br />\nrose<br />\norchid</div><div class='pdsec'>样例输出</div><div class='pddata'>2<br />\n2</div><div class='pdsec'>试题来源</div><div class='pdcont'>　　Tehran 2002 Preliminary</div>\n","gpid":"T612","lanqiaotitle":"Substrings","memorylimit":"256.0MB","tid":"ADV-316","timelimit":"1.0s","title":"算法提高 Substrings","src":""},{"checkpoint":"","updatetime":"2020-03-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　在x轴上有 3 个人，第 i 个人的位置为 xi。最初他们的位置均不同。<br />\n　　每个人可以进行下列三种操作至多各一次：移动；将另一个人举起来；将举起的人扔出一段距离。<br />\n　　操作须遵守下列规则：<br />\n　　1. 每个人只能移动到（或被投掷到）此时没有被人占据的位置而且必须是整数点；<br />\n　　2. 第 i \t个人一次移动的距离不超过 mi；<br />\n　　3. 被举起的人不能进行任何操作；<br />\n　　4. 正在举着别人的人不能移动；<br />\n　　5. 当且仅当两个人 \tA 与 B \t相邻（即距离等于1），且 \tB 没有被其他人举起，且 \tA能操作时，A \t可以举起 B，此时 \tB 自动移动到 \tA 所在的位置；<br />\n　　6. 第 i \t个人的投掷距离不能超过 ti；<br />\n　　7. 可以出现 A \t举起 B \t的同时 C \t举起 A \t的情况。此时 B \t和 A \t都不能操作。<br />\n　　请你计算，根据上述规则，这三个人能够到达的位置坐标的最大值。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入共三行，每行描述一个人的信息。<br />\n　　每一行为三个整数 xi, mi, ti (0 &lt;= xi, mi, ti &lt;= 10)，依次表示这个人的初始坐标，最大移动距离，最大投掷距离。ti = 0 表示将别人举起来后无法扔出。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行，为一个整数，表示三个人的任何一个能到达的坐标的最大值。</div><div class='pdsec'>样例输入</div><div class='pddata'>9 3 3<br />\n4 3 1<br />\n2 3 3</div><div class='pdsec'>样例输出</div><div class='pddata'>15</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　初始时刻 A 在位置 9，B 在 4，C 在 2.<br />\n　　第一步，A 移动到 6，注意移动时可以经过别的人；<br />\n　　第二步，C 移动到位置 5；<br />\n　　第三步，C 举起 B；<br />\n　　第四步，A 举起 C；<br />\n　　第五步，A 用尽全力把 C 扔到位置 9，注意 B 仍然被 C 举着；<br />\n　　第六步，C 用尽全力把 B 扔到到位置 12;<br />\n　　第七步，B 移动到位置 15.</div>\n","gpid":"T611","lanqiaotitle":"Lift and Throw","memorylimit":"128.0MB","tid":"ADV-315","timelimit":"1.0s","title":"算法提高 Lift and Throw","src":"Codeforces"},{"checkpoint":"A+B","updatetime":"2020-03-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输入A,B。<br />\n　　输出A+B。【输入格式】 输入包含两个整数A,B，用一个空格分隔。 输入包含两个整数A,B，用一个空格分隔。<br />\n　　【输出格式】输出一个整数，表示A+B的值。输出一个整数，表示A+B的值。</div><div class='pdsec'>样例输入</div><div class='pddata'>一个满足题目要求的输入范例。<br />\n5 8</div><div class='pdsec'>样例输出</div><div class='pddata'>13</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入数据中每一个数的范围。<br />\n　　-1,000,000,000&lt;=A,B&lt;=1,000,000,000。</div>\n","gpid":"T610","lanqiaotitle":"A+Bproblem","memorylimit":"256.0MB","tid":"ADV-314","timelimit":"1.0s","title":"算法提高 A+Bproblem","src":""},{"checkpoint":"排序","updatetime":"2019-11-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　土豪大学每年都会给学生颁发巨额的特等奖学金，当然，获奖的前提是要足够优秀。这所大学有n名学生，他们中的每个人都会在m门必修课的每门课上获得一个百分制的整数成绩（0-100），到了期末教务长会获得所有学生在所有必修课上的成绩报告，他会从中挑选出最优秀的k位学生，并给他们颁发奖学金。<br />\n　　教务长认为，某个学生只要有一门课不及格（分数＜85），他就丧失了获得奖学金的资格。教务长会给所有科目按照重要性排序，在所有拥有获得奖学金资格的学生中，教务长更喜欢在更重要的科目中取得高分的学生，并依此将学生排序（即对于某两名学生，在最重要的科目中取得更高分的学生排在前面；如果两人在最重要的科目中取得相同的分数，则比较次重要的科目；若再相同则比较第三重要的科目……一直下去）。<br />\n　　以前土豪大学的学生数量并不多，教务长就用纸笔计算谁将获得奖学金；今年大学扩招了，教务长意识到用纸笔计算太复杂了，你能帮他解决这个问题吗？说不定教务长高兴了就给你也发一份奖学金(⊙o⊙)哦！（注意：获奖学生数量可能小于k）</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入数据第一行为三个整数n、m、k，用空格隔开；第二行至第（n+1）行是学号分别为1、2……n的同学的m门课的成绩（m门课已按重要性排序），用空格隔开（输入保证每两人的分数不完全相同）。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行为获奖同学的学号，按排名从前到后排序，用空格隔开。</div><div class='pdsec'>样例输入</div><div class='pddata'>10 2 7<br />\n99 87<br />\n96 79<br />\n93 99<br />\n88 88<br />\n90 87<br />\n90 86<br />\n90 88<br />\n88 90<br />\n91 100<br />\n100 85</div><div class='pdsec'>样例输出</div><div class='pddata'>10 1 3 9 7 5 6</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　0＜n≤1000，0＜m≤100，0＜k≤n</div>\n","gpid":"T532","lanqiaotitle":"特等奖学金","memorylimit":"256.0MB","tid":"ADV-281","timelimit":"1.0s","title":"算法提高 特等奖学金","src":""},{"checkpoint":"循环","updatetime":"2019-11-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　北大附中书院有m个同学，他们每次都很民主地决策很多事情。按罗伯特议事规则，需要一个主持人。同学们民主意识强，积极性高，都想做主持人，当然主持人只有一人。为了选出主持人，他们想到了一个办法并认为很民主。方法是：<br />\n　　大家围成一圈，从1到m为每个同学编号。然后从1开始报数， 数到n的出局。剩下的同学从下位开始再从1开始报数。最后剩下来的就是主持人了。现在已经把同学从1到m编号，并约定报数为n的出局，请编程计算一下，哪个编号的同学将会成为主持人。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一行，由空格分开的两个整数m n。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个整数，表示主持人的编号</div><div class='pdsec'>样例输入</div><div class='pddata'>15 3</div><div class='pdsec'>样例输出</div><div class='pddata'>5</div><div class='pdsec'>样例输入</div><div class='pddata'>200 55</div><div class='pdsec'>样例输出</div><div class='pddata'>93</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　10000&gt;m&gt;0; 100&gt;n&gt;0;<br />\n　　时间限制1.0秒</div>\n","gpid":"T531","lanqiaotitle":"书院主持人","memorylimit":"256.0MB","tid":"ADV-280","timelimit":"1.0s","title":"算法提高 书院主持人","src":""},{"checkpoint":"日期","updatetime":"2019-02-13","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　研究组正在开发一个计算机程序，这个程序会从一个服务获得历史股票市场价格数据。而这个服务每提供一天的股市数据，都要收取一个固定的费用。这个研究组检查了过去请求的价格数据，发现有着大量的重复，也就浪费了不少的研究经费。所以新的程序需要维护一个表来保存研究组成员曾经请求过的所有价格数据。当需要一段新的价格数据时，只有曾经没有请求过的会从服务获得，从而减少研究开销。<br />\n　　你的任务是完成一个程序来判断是否需要从服务请求新的价格数据。程序的输入包括所有过去请求过的价格数据的日期区间，和现在需要的日期区间。这个程序需要输出必须从服务获得的数据的日期区间。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　有多组测试数据。每组测试数据以两个非负整数 NX 和 NR 开始，（0 &lt;= NX, NR &lt;= 100）。NX 是已获取过的日期区间数，NR 是现在需要的日期区间数。接下去的输入是 NX + NR 对日期。每对日期的第一个日期都一定小于等于第二个日期。前面的 NX 对日期表示已获取过的日期区间，后 NR 对表示现在需要的日期区间。<br />\n　　最后一组测试数据后，以两个零终结输入。<br />\n　　每个输入日期都会以 YYYYMMDD 的形式给定。YYYY 是年份（1700 到 2100），MM 代表月份（01 到 12），而 DD 表示日（在给定的年份、月份允许的范围内）。月份 04、06、09、11 有 30 天，而 01、03、05、07、08、10、12 有 31 天，除了闰年，02 月有 28 天，而闰年则为 29 天。如果年份能被 4 整除并且不是一个世纪年（100 的倍数），或者是 400 的倍数时，可以判定这年是闰年。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组测试数据，首先显示测试数据编号（1，2，...），紧接着是一个表，内容是必须从服务获得数据的日期区间，每行一个。以下面样例显示的美国日期格式输出。当没有价格数据需要从服务获取时明确地说明（如样例）。如果两个日期区间是连续的或者重叠的，将它们合并为一个。如果一个日期区间里只有一天，只需将其显示出来，而不是显示包括两个相同日期的日期区间。以日期顺序显示日期区间，从最早的日期开始。</div><div class='pdsec'>样例输入</div><div class='pddata'>1 1<br />\n19900101 19901231<br />\n19901201 20000131<br />\n0 3<br />\n19720101 19720131<br />\n19720201 19720228<br />\n19720301 19720301<br />\n1 1<br />\n20010101 20011231<br />\n20010515 20010901<br />\n0 0</div><div class='pdsec'>样例输出</div><div class='pddata'>Case 1:<br />\n____1/1/1991 to 1/31/2000<br />\n<br />\nCase 2:<br />\n____1/1/1972 to 2/28/1972<br />\n____3/1/1972<br />\n<br />\nCase 3:<br />\n____No additional quotes are required.<br />\n<br />\n（为防止被格式化掉我用 `_` 代表空格，即实际输出应使用四个空格）</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　0 &lt;= NX, NR &lt;= 100<br />\n<br />\n　　年份范围为 1700 年到 2100 年。<br />\n<br />\n　　测试数据组数 &lt;= 100</div>\n","gpid":"T516","lanqiaotitle":"Intersecting Dates","memorylimit":"256.0MB","tid":"ADV-274","timelimit":"2.0s","title":"算法提高 Intersecting Dates","src":"ACM/ICPC World Finals 2004 E"},{"checkpoint":"枚举、二分图最优匹配","updatetime":"2019-02-13","content":"<div class='pdcont'>　　The Great Wall Game</div><div class='pdsec'>问题描述</div><div class='pdcont'>　　小华和小沈发明了一个简单的棋盘游戏，他们称之为“长城游戏”。这个游戏需要一个n*n的网格和n颗石子。这些石子随机地放在网格的方格之中，一个格子中最多放一颗石子。每一次移动，可以将任意一颗石子移动到上下左右相邻的空方格之中。游戏的目标是用最少的移动步数，使得n颗石子构成“一堵墙”——排成一条水平、竖直或斜的直线。<br />\n　　例如图1(a)中n=5的情况，我们可以移动6步使得所有石子排成如图1(b)中所示的一条斜线。没有比这个更少的步数能使这5颗石子排成一条直线了（但是，另一个6步的移动方法是将所有石子移动到第3列排成一条直线）。<br />\n<img src=\"/RequireFile.do?fid=jetmnebM\" width=\"400\" height=\"150\" /><br />\n<br />\n<br />\n　　图1. n=5的情况，从(a)开始移动6步得到(b)<br />\n<br />\n　　现在的问题是，小华和小沈不知道对于一个给定的初始棋盘，达到目标需要移动的最小步数。他们想要你写一个程序能够实现对于任意一个给定的初始状态，求出将所有石子排成一条直线所需要的最小步数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入由多组数据组成。每组数据第一行包含一个整数n，1&lt;=n&lt;=15。接下来n行，每行包含两个数分别表示每颗石子所在的行和列。行和列的编号如上图。输入数据最后一行包含一个数0表示结束。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每一组数据，输出数据的编号和将所有n颗石子排成一条直线所需的最小移动步数。按照样例中的输出格式输出。每组数据之后输出一个空行。</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n1 2 2 4 3 4 5 1 5 3<br />\n2<br />\n1 1 1 2<br />\n3<br />\n3 1 1 2 2 2<br />\n0</div><div class='pdsec'>样例输出</div><div class='pddata'>Board 1: 6 moves required.<br />\n<br />\nBoard 2: 0 moves required.<br />\n<br />\nBoard 3: 1 moves required.</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=n&lt;=15<br />\n　　测试数据组数&lt;=500</div>\n","gpid":"T514","lanqiaotitle":"The Great Wall Game","memorylimit":"256.0MB","tid":"ADV-273","timelimit":"1.0s","title":"算法提高 The Great Wall Game","src":"ACM/ICPC World Finals 2005 H"},{"checkpoint":"","updatetime":"2019-01-29","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　数组A中共有n个元素，初始全为0。你可以对数组进行两种操作：1、将数组中的一个元素加1；2、将数组中所有元素乘2。求将数组A从初始状态变为目标状态B所需要的最少操作数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个正整数n表示数组中元素的个数<br />\n<br />\n　　第二行n个正整数表示目标状态B中的元素</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行表示最少操作数</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n<br />\n7 8</div><div class='pdsec'>样例输出</div><div class='pddata'>7</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=50，B[i]&lt;=1000</div>\n","gpid":"T508","lanqiaotitle":"change","memorylimit":"256.0MB","tid":"ADV-272","timelimit":"1.0s","title":"算法提高 change","src":"by ryz"},{"checkpoint":"阿尔法乘积","updatetime":"2019-01-14","content":"<div class='pdcont'>　　计算一个无符号整数的阿尔法乘积。对于一个无符号整数x来说，它的阿尔法乘积是这样来计算的：如果x是一个个位数，那么它的阿尔法乘积就是它本身；否则的话，x的阿尔法乘积就等于它的各位非0的数字相乘所得到的那个整数的阿尔法乘积。例如，4018224312的阿尔法乘积等于8，它是经过以下的几个步骤计算出来的：<br />\n　　4018224312&agrave;4*1*8*2*2*4*3*1*2&agrave;3072<br />\n　　3072&agrave;3*7*2&agrave;42<br />\n　　42&agrave;4*2&agrave;8<br />\n<b>输入：</b><br />\n　　4018224312<br />\n<b>输出：</b><br />\n　　8</div>\n","gpid":"T505","lanqiaotitle":"P0404","memorylimit":"256.0MB","tid":"ADV-269","timelimit":"1.0s","title":"算法提高 P0404","src":""},{"checkpoint":"数列问题","updatetime":"2019-01-14","content":"<div class='pdcont'>　　编写一个程序，计算以下的数列：<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n　　要求：用户输入n(0&lt;=n&lt;=15)，然后程序输出第n个元素的值。<br />\n<b>输入：</b><br />\n　　1<br />\n<b>输出：</b><br />\n　　3</div>\n","gpid":"T504","lanqiaotitle":"P0403","memorylimit":"256.0MB","tid":"ADV-268","timelimit":"1.0s","title":"算法提高 P0403","src":""},{"checkpoint":"猴子吃桃问题","updatetime":"2019-01-14","content":"<div class='pdcont'>　　猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第十天早上想在吃时就只剩下一个桃子了。求第一天共摘了多少桃子。<br />\n　　（下面的不是正确答案）<br />\n<b>输出：</b><br />\n　　8</div>\n","gpid":"T503","lanqiaotitle":"P0402","memorylimit":"256.0MB","tid":"ADV-267","timelimit":"1.0s","title":"算法提高 P0402","src":""},{"checkpoint":"1的个数","updatetime":"2019-01-14","content":"<div class='pdcont'>　　输入一个无符号整数x，输出x的二进制表示中1的个数.<br />\n<b>输入：</b><b></b><br />\n　　76584<br />\n<b>输出：</b><b></b><br />\n　　7</div>\n","gpid":"T502","lanqiaotitle":"P0401","memorylimit":"256.0MB","tid":"ADV-266","timelimit":"1.0s","title":"算法提高 P0401","src":""},{"checkpoint":"最小生成树","updatetime":"2018-10-22","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　新奥德卫莱城市委员会计划建造一个连接系统来连接所有市中心的建筑，这样人们从一个建筑去另一个建筑时就不用走到外面了。你要写一个程序来帮忙确定建造方案。<br />\n　　新奥德卫莱市是正方形网状布局，每个建筑物占着一些连通的格子，两个有建筑物的格子如果有角接触就算相连，不需要连接道路。道路只能在正方形的边上建造，并且只能是直线且连接两个建筑。<br />\n　　给你一个建筑示意图，你要算出连接所有建筑的最小道路数。如果这是不可能的，找出最少的无法连接的建筑群数。在可连接所有建筑物的情况下，如果多种方案道路数都是最小的，选择在网格中道路总长度最小的方案。道路可以互相穿过，但在这种情况下道路被判定互不相干，之间无法连接。<br />\n　　下图说明了4种可能的城市配置。城市1包含5个建筑，被4条道路连接起来，总长度为4。城市2中，因没有建筑共享网格线所以无法建立道路。在城市3中，因为只有1个建筑所以我们不需要道路。在城市4中，最好方案是用1条长度为1的道路连接两个城市，剩下两个不连通的建筑群（一个是两个建筑，一个是一个建筑）。<br />\n　　左上是城市1 ，中上是建路后的城市1 ，右上是不能建路的城市2，左下是不需要建路的城市3，中下是城市4，右下是建路后的城市4。<br />\n<img src=\"/RequireFile.do?fid=YDT57G6M\" width=\"444\" height=\"200\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含多座城市，每个城市的描述第一行有2个整数r和c（1&lt;=r,c&lt;=50），表示这个城市的南北距离和东西距离，之后接着r行，每行有c个“#”或“.”，每个字符表示网格中的一个格子。“#”表示那个格子中有建筑，“.” 表示那个格子中没有建筑。数据的最后一个城市是由两个0组成。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每个城市，像样例那样输出两到三行。第一行是城市编号。如果城市只有少于两个建筑，就在第二行输出“No bridges are needed.”。如果城市有两个及以上个建筑且任意两个建筑都不能被连接，就在第二行输出“No bridges are possible.”。否则，就在第二行输出“N bridges of total length  L”，其中N是道路数，L是最优方案的道路长度。（如果N是1，就用bridge代替bridges）。如果最终方案剩下了多个建筑群，在第三行输出建筑群数。<br />\n　　每组数据间用空行隔开。见下面样例。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 5<br />\n#...#<br />\n..#..<br />\n#...#<br />\n3 5<br />\n##...<br />\n.....<br />\n....#<br />\n3 5<br />\n#.###<br />\n#.#.#<br />\n###.#<br />\n3 5<br />\n#.#..<br />\n.....<br />\n....#<br />\n0 0</div><div class='pdsec'>样例输出</div><div class='pddata'>City 1<br />\n4 bridges of total length 4<br />\n<br />\nCity 2<br />\nNo bridges are possible.<br />\n2 disconnected groups<br />\n<br />\nCity 3<br />\nNo bridges are needed.<br />\n<br />\nCity 4<br />\n1 bridge of total length 1<br />\n2 disconnected groups</div>\n","gpid":"T498","lanqiaotitle":"Building Bridges","memorylimit":"256.0MB","tid":"ADV-263","timelimit":"1.0s","title":"算法提高 Building Bridges","src":"ACM/ICPC World Finals 2003 A"},{"checkpoint":"trie floyd","updatetime":"2018-10-22","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　和程序员一样，你也听说过正则表达式和上下文无关文法吧。有很多种方法生成小写字母的字符串集合（从另一方面叫做形式语言）。还有更多其他不为人知的方法生成语言，比如树邻接语法、上下文有关文法和无限制语法。这个问题用一种新的方法生成语言：后缀替换法。<br />\n　　一个后缀替换法由起始字符串S和一些后缀替换规则组成。每个规则是由X→Y的形式给出，其中X和Y是等长的由字母构成的字符串。这个规则表示如果你现在的字符串后缀（最右的字符）是X，你就可以用Y替代它。这个规则可以无限次使用。<br />\n　　举个例子，假如有4个规则A→B,AB→BA,AA→CC,CC→BB，你就可以通过三步把AA变成BB：AA→AB（用A→B规则），AB→BA（用AB→BA规则），BA→BB（用A→B规则），但你也可以用两步更快的完成：AA→CC（用AA→CC规则），CC→BB（用CC→BB规则）。<br />\n　　你要写一个程序通过后缀替换规则和字符串T确定起始字符串S能否变成T，如果可能，求最小步数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入文件包含多组数据，每组数据第一行包括2个等长字符串S和T（S和T长度在1到20之间，由空格隔开），以及一个整数NR(0&lt;=NR&lt;=100)，代表规则数，之后NR行每行包含两个等长字符串X和Y（X和Y长度在1到20之间，由空格隔开），代表X→Y是一种规则。字符串区分大小写，文件最后一行由一个点结尾。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组数据，输出数据编号（从1开始）和从S到T的最少步数，如果无法转换，就输出“No solution”。按照示例的格式输出。</div><div class='pdsec'>样例输入</div><div class='pddata'>AA BB 4<br />\nA B<br />\nAB BA<br />\nAA CC<br />\nCC BB<br />\nA B 3<br />\nA C<br />\nB C<br />\nc B<br />\n.</div><div class='pdsec'>样例输出</div><div class='pddata'>Case 1: 2<br />\nCase 2: No solution</div>\n","gpid":"T497","lanqiaotitle":"Suffix-Replacement Grammars","memorylimit":"512.0MB","tid":"ADV-262","timelimit":"3.0s","title":"算法提高 Suffix-Replacement Grammars","src":"ACM/ICPC World Finals 2009 K"},{"checkpoint":"搜索 数论","updatetime":"2018-10-22","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　一个最基本的算数法则就是大于1的整数都能用1个或多个素数相乘的形式表示出来。当然，可以安排出多种的质因子排列方案，例如：10=2*5=5*2 20=5*2*2=2*5*2=2*2*5<br />\n　　让我们用f(k)表示k的质因子排列方案数，如f(10)=2，f(20)=3。<br />\n　　给你一个正整数n，至少有一个k使得f(k)=n，我们想知道最小的k是多少。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入文件至多有1000组数据，每组数据单独成行上，包含一个正整数n（n&lt;2^63）。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组数据，输出他的问题n和最小的满足f(k)=n的k（k&gt;1），数据保证k&lt;2^63。</div><div class='pdsec'>样例输入</div><div class='pddata'>1<br />\n2<br />\n3<br />\n105</div><div class='pdsec'>样例输出</div><div class='pddata'>1 2<br />\n2 6<br />\n3 12<br />\n105 720</div>\n","gpid":"T496","lanqiaotitle":"Factors","memorylimit":"256.0MB","tid":"ADV-261","timelimit":"1.0s","title":"算法提高 Factors","src":"ACM/ICPC World Finals 2013 D"},{"checkpoint":"计算几何 模拟","updatetime":"2018-03-09","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　为了避免空中相撞，大部分商业航班都被地面航空管制中心使用雷达跟踪其位置来监控。在这个问题中，你会被给予一组飞机和一组控制中心的信息，并计算出飞机是如何被控制中心监控的（这句话的意思参考输入描述：即计算恰好被K个控制中心监控的飞机数目），飞机的位置用(x,y)坐标表示，基于此题的目的，无视飞机的高度（海拔）。<br />\n　　一个给定的控制中心能够监控的飞机数量因设备和工作人员的改变而时刻变化。在任一时刻，每一个控制中心会尽可能地监控更多的飞机，它会按照如下优先级选择其监控的飞机：1.离这个控制中心欧几里得距离比较近的优于比较远的。2.若两架飞机到控制中心的距离相同，那么选择其中往北更远的(y坐标轴正方向)。3.如果两架飞机的距离和y坐标都相同，优先选择往东更远的（x坐标正方向）。（补充说明：也就是说在距离相同的情况下，先比较y坐标，y坐标大的优先级高，若y坐标依旧相同，x坐标大的优先级高。数据会保证没有任意两个飞机的坐标相同。）<br />\n　　在任意时刻，每一个控制中心都有一个圆形“控制范围”，其半径等于其所监控的最远的那架飞机的距离。所有在控制范围内的飞机都被该控制中心监控，但是在控制范围边界上的飞机可能或可能不被控制中心监控，这取决于控制中心的容量和以上列出的优先级。<br />\n　　你不会被告知控制中心的位置,取而代之的，对于每个控制中心，你会被告知它当前监控的飞机个数，以及其监控范围边界上的两点，用这些信息，你能计算出控制中心的位置，以及决定哪些飞机被其监控。如果数据包含多种可能的监控范围，你应该选择包含了靠北最远的那架飞机的，通过先选择靠北最远的再选择靠东最远的打破平局（——这段话的意思你可以这么认为：如果有多种可能的控制范围以及对应的控制中心位置满足输入要求，那么我们这么来判定：将飞机按照y坐标从大到小，y坐标相同的按照x从大到小排序，然后依次考虑，如果有架飞机在控制范围A内，而其不在控制范围B内，则我们会选择A而不是B。注意，若两个控制范围监控的飞机的集合相同，可以任意选择一个，因为这不影响答案）。<br />\n　　下面这张图展示了两个控制中心和四架飞机的情况。每个控制中心用一个圆形控制区域和这个区域中的两个点表示，用A和B标记。P1，P2，P3，P4标记了四架飞机。在这个例子中，飞机P1和P4都被一个单独的控制中心监视，而P3被两个控制中心监控，但P2却没有被任何一个控制中心监控。<br />\n<img src=\"/RequireFile.do?fid=j4y8jqGt\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含多组测试数据，每个数据第一行包括两个正整数NP(0&lt;NP&lt;100)和NC(0&lt;NC&lt;10)，分别表示了飞机的个数和控制中心的个数。接下来NP行，每行两个浮点数表示一架飞机的(x,y)坐标。再接下来NC行，每行描述一个控制中心。首先是一个位于0到NP的正整数（包含0和NP），表示被该控制中心监控的飞机个数，然后是两对浮点数表示监控范围边界上的两个位置的(x,y)坐标（两个位置不会相同，而且也不会与飞机坐标重合）。注意：若两个点之间的距离小于0.00001，你应该将其视为一个点。<br />\n　　输入以两个0结束。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组数据，计算出被0个控制中心监控的飞机个数，被1个控制中心监控的飞机个数等等，直到被NC个控制中心监控的飞机个数。首先输出数据组号，然后接下来NC+1个数，序列中第i<sup>th</sup>数表示被i-1个控制中心监控的飞机个数。如果某个控制中心不存在相符合的监控范围，那么输出\"Impossible\"而不是相应的序列。使用样例中给定的输出格式，然后每组数据之后都要输出一个空行。<br />\n　　（关于输出格式，请注意冒号之后有两个空格，每个序列中每两个数之间有两个空格，序列的行末有两个空格，Impossible后没有空格，每组数据输出占两行。）</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n4  2<p> </p>\n3.0  0.0<p> </p>\n0.0  0.0<p> </p>\n1.6  2.8<p> </p>\n2.0  1.0<p> </p>\n2  1.0  2.0  2.0  0.0<p> </p>\n2  2.0  2.0  4.0  2.0<p> </p>\n2  1<p> </p>\n0.0  0.5<p> </p>\n0.0  -0.5<p> </p>\n0   -1.0  0.0  1.0  0.0<p> </p>\n0  0\n</pre>\n<div class='pdsec'>样例输出</div><div class='pddata'>Trial 1:  1  2  1<br />\n<br />\nTrial 2:  Impossible</div><div class='pdsec'>题外话</div><div class='pdcont'>　　由于无法确定比赛时的题意到底是什么，所以我选择了自认为最接近原题意的方式。<br />\n　　注意UVA和LA上的数据与这儿是不同的，要通过那儿的数据，首先，在多个控制范围中选择的时候，应该要优先选择半径最小的。第二，UVA上的数据要求考虑这样一种控制范围：那就是在控制范围的边界上没有被控制的点，却存在飞机。所以按照其理解方式，允许出现只控制了0架飞机的情况，只要刚好有个控制范围内部没有飞机但边界上有飞机即可。不过在这儿要求控制范围内必须有一架飞机！<br />\n　　感谢董宏华神犇的指导。</div>\n","gpid":"T493","lanqiaotitle":"Air Traffic Control","memorylimit":"256.0MB","tid":"ADV-260","timelimit":"1.0s","title":"算法提高 Air Traffic Control","src":"ACM/ICPC World Finals 2004 J"},{"checkpoint":"树 动态规划","updatetime":"2018-03-09","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　和很多现代化的城市一样，斯德哥尔摩有一个发达的公共交通系统。而斯德哥尔摩公共交通的核心就是地铁。一份地铁的拓扑地图里有不同的地铁线路，以及他们之间的连接方式，如下图。在这个问题中，你可以假定地铁的地图一定是树形的，尽管斯德哥尔摩的地铁实际上并非确实如此，例如图中蓝色和绿色的线路形成了一个环。<br />\n<img src=\"/RequireFile.do?fid=j9qF9fhB\" width=\"400\" height=\"291\" /><br />\n　　地铁的拓扑图并不关心地铁系统的几何性质，比如说不同地铁站之间的距离（以及相应的旅行时间）。虽然斯德哥尔摩的大部分学生都知道，“Tekniska Hogskolan” (皇家理工学院) 和 “Universitetet” (斯德哥尔摩大学)相隔是非常远的，但是如上这幅图中却没有体现出来。<br />\n　　为了丰富这张地图，你要写一个程序，计算出任意相邻地铁站之间所需的旅行时间。幸运的是，那些旅行时间是已知的，所以不需要你亲自去测量。但问题是，实际测量出来的时间是以秒为单位，而画在地图上的时间却是以分钟为单位，而且必须是整数，所以需要你给出一个时间的估计。<br />\n　　一种自然的估计时间的方法可能是简单地将所有的旅行时间转往离其最近的整数取整。但是这有可能导致巨大的累计误差。在斯德哥尔摩的地图上，这种估计方法会导致在某两个地铁站之间的旅行时间的估计与实际时间出现一个将近15分钟的偏差。为了避免这个，你的程序需要选择一些相邻地铁站之间的旅行时间向上取整，其余的向下取整，从而使得点对之间最大的累计误差最小。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含多组数据。每组数据最开始是一个整数N(1≤N≤100)，为地铁站的个数。这N个地铁站用正整数1到N标记。接下来N-1行包含了三个整数a,b,t(1≤a,b≤n,1≤t≤300)，表示地铁站a和站b是相邻的，而且在它们之间旅行的时间花费是t秒。为了简化问题，忽略地铁在地铁站停留的时间。<br />\n　　输入以EOF结束。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组数据，输出数据组号（从1开始标号），然后输出对相邻地铁站之间的旅行时间进行舍入之后，两两地铁站之间旅行时间误差的最大值所能取到的最小值。具体参照样例所给定的格式。</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n2 <p> </p>\n1 2 110 <p> </p>\n4 <p> </p>\n1 2 40 <p> </p>\n2 3 40 <p> </p>\n3 4 40 <p> </p>\n4 <p> </p>\n1 2 90 <p> </p>\n1 3 90 <p> </p>\n1 4 90 <p> </p>\n</pre>\n<div class='pdsec'>样例输出</div><pre class='pddata'>\nCase 1: 10 <p> </p>\nCase 2: 40 <p> </p>\nCase 3: 60\n</pre>\n\n","gpid":"T492","lanqiaotitle":"Subway Timing","memorylimit":"256.0MB","tid":"ADV-259","timelimit":"3.0s","title":"算法提高 Subway Timing","src":"ACM/ICPC World Finals 2009 J"},{"checkpoint":"二分 贪心 暴力","updatetime":"2018-03-09","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　如果你认为参加一个编程比赛让你感到有压力，那么请你想象你是一个空中交通管制员。因为人命关天，所以一个空中交通管制员必须在时刻变化的环境中专注于任务，解决不可预知的事件。<br />\n　　让我们将目光转向飞机的着陆流程。飞机进入目的地飞航情报区之后，就会报告自己的位置、方向和速度，然后管制员就需要制定计划让所有飞机按指令安全着陆。一般来说，连续的两次着陆之间间隔时间越长，就越安全。因为这些额外的时间能够让工程师有机会对天气变化以及其他突发事件作出反应。<br />\n　　幸运的是，有一部分计划的制定可以自动化——这就是你来这里的原因。你会得到有关飞机着陆的脚本。每一个飞机都有一个安全着陆时间窗。你算出的指令必须要符合每个飞机的时间窗。另外，飞机的着陆时间点要尽量均匀，使得连续两次着陆的最小间隔尽量大。例如，如果三架飞机分别着陆于10:00am、10:05am、10:15am，那么最小间隔是五分钟，在头两架飞机之间。所有间隔不一定一样，但是最小的间隔要尽量大。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　多组数据。每个数据第一行为一个整数n，为飞机架数。接下来n行，每行两个整数a[i]，b[i]表示这架飞机只能在闭区间[a[i],b[i]]间降落。a[i]和b[i]的单位是分钟。输入的最后一行是一个零。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组数据，先输出第几组，然后输出最小间隔，单位为分和秒，舍入到最近的整数。格式参见样例。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n0 10<br />\n5 15<br />\n10 15<br />\n2<br />\n0 10<br />\n10 20<br />\n0</div><div class='pdsec'>样例输出</div><div class='pddata'>Case 1: 7:30<br />\nCase 2: 20:00</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　20% n&lt;=5<br />\n　　100% 2&lt;=n&lt;=8, 0&lt;=a[i], b[i]&lt;=1440, 数据组数不大于20.</div>\n","gpid":"T490","lanqiaotitle":"A Careful Approach","memorylimit":"256.0MB","tid":"ADV-258","timelimit":"1.0s","title":"算法提高 A Careful Approach","src":"ACM/ICPC World Finals 2009 A"},{"checkpoint":"网络流","updatetime":"2018-02-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　一个间谍从你的陷阱中逃出来了，干掉了你的警卫，并且带走了你毁灭世界的计划。你的糟糕的行动由此受到了威胁。现在你需要在他逃出基地之前抓到他。<br />\n　　你的基地由一系列房间和连接它们的双向隧道组成，隧道只在房间处相交。每个房间都配有监控摄像，使你能在任意时刻了解间谍所处的位置。另外，每条隧道里都装有遥控炸药，触发后可以永久毁坏该隧道。间谍在隧道中移动极快，因此你不可能把他困在炸毁的一条隧道中，但你可以炸毁一些隧道，使他无法逃出基地。<br />\n　　显然，间谍不可能逃出基地。所以你的目标是在困住他的同时炸毁最少的隧道，因为之后的重建非常昂贵。找到一种策略，使得在最坏情况下需要炸毁的隧道数最小。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含多组数据。每组数据的第一行包含两个整数R, T，分别表示房间的隧道的数量。接下来T行，每行两个整数a, b(0 &lt;= a, b &lt;= R)，表示隧道两端的房间编号。形如\"0 x\"或\"x 0\"的输入表示联通房间x和基地外部的隧道。<br />\n　　间谍从1出发，你需要阻止他到达点0（基地外部）。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对第i组输入，输出\"Case $i: ${ans}\\n\\n\"，其中${ans}表示对应的答案。<br />\n　　参见样例输出的格式。</div><div class='pdsec'>样例输入</div><div class='pddata'>4 6<br />\n1 2<br />\n1 3<br />\n2 4<br />\n3 4<br />\n4 0<br />\n4 0<br />\n4 6<br />\n1 2<br />\n1 3<br />\n1 4<br />\n2 0<br />\n3 0<br />\n4 0<br />\n0 0</div><div class='pdsec'>样例输出</div><div class='pddata'>Case 1: 2<br />\n<br />\nCase 2: 2<br />\n<br />\n如你所见, 输出的最后有一个空行。</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1 &lt;= R &lt;= 50, 1 &lt;= T &lt;= 1000。<br />\n　　每个测试点至多包含五组数据。</div>\n","gpid":"T486","lanqiaotitle":"Tunnels","memorylimit":"256.0MB","tid":"ADV-257","timelimit":"1.0s","title":"算法提高 Tunnels","src":"ACM/ICPC World Finals 2007 J"},{"checkpoint":"状态压缩动态规划 记忆化搜索","updatetime":"2018-01-10","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　每天，巧克力在它的许多形式上被全世界数百万人分享。它是一个真正普遍的糖果，实际上在世界上每个国家都能得到。<br />\n　　你发现唯一比吃巧克力更好的事情是把它分享给朋友。不幸的是，你的朋友非常挑剔，有着不同的胃口：有的喜欢让你提供较多的巧克力，而其他的喜欢让你提供较少的巧克力。你发现当他们的要求可以相互叠加时，这个事情就变得越来越难决断。现在是写一个程序来一次性完全解决这个问题的时间！<br />\n　　你的巧克力是矩形的。巧克力由同样大小的矩形块组成。你可以沿着巧克力中行或者列的分割线将巧克力分成两块来分享你的巧克力。你可以重复地用同样手段将分成的小块继续分割。你的每个朋友坚持要得到巧克力中的一个矩形部分，这个部分包含一个确定地小块数。你也有些坚持心：如果这块巧克力能全部分给你的朋友，不剩下任何部分，你才会分割你的巧克力。<br />\n　　例如图9表示将一个由3×4个小块组成巧克力块分割3次，分成各自包含6、3、2、1个小块的4部分的一种方法。（这相当于输入样例中第一个测试数据。）<br />\n<img width=\"824\" height=\"172\" src=\"/RequireFile.do?fid=nD72F7DN\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入数据包含多组测试数据，每组测试数据描述一个要分享的巧克力块。每组测试数据的第一行包含一个整数n(1&lt;=n&lt;=15)，表示巧克力需要分割成的块数。第二行包含两个整数x、y，表示巧克力块的两个方向上的长度。第三行包含n个正整数，表示n个部分各自需要包含的小块数。<br />\n　　输入数据终止于只包含整数0的一行。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组测试数据，先输出它的测试点编号。然后输出将巧克力按照指定的方法分割是否有可能：如果可能，输出“Yes”，否则输出“No”。按照输出样例中的格式输出。</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\n3 4<br />\n6 3 2 1<br />\n2<br />\n2 3<br />\n1 5<br />\n0</div><div class='pdsec'>样例输出</div><div class='pddata'>Case 1: Yes<br />\nCase 2: No</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于40%的数据，1&lt;=n&lt;=5，1&lt;=x,y&lt;=10；<br />\n　　对于全部的数据，1&lt;=n&lt;=15，1&lt;=x,y&lt;=100，输入文件保证测试点个数不超过10。</div>\n","gpid":"T479","lanqiaotitle":"Sharing Chocolate","memorylimit":"128.0MB","tid":"ADV-255","timelimit":"1.0s","title":"算法提高 Sharing Chocolate","src":"ACM/ICPC World Finals 2010 J"},{"checkpoint":"搜索 alphabeta剪枝","updatetime":"2018-01-05","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Axel和Birgit喜欢玩这样的一种纸牌游戏：他们建造一个由纸牌组成的房子，当他们添加纸牌到房子的时候，会获得（或失去）游戏的分数。由于他们都有一双灵巧的手，纸牌组成的房子是不会倒塌的。他们使用半副标准纸牌。一副标准的纸牌有4种花色，2种是红色，2种是黑色。Axel和Birgit只使用2种花色，1红1黑。每种花色有13个等级。我们使用记号1R，2R，…，13R，1B，2B，…，13B来表示等级和颜色。<br />\n　　开始前，玩家要选择半副标准纸牌的一个子集，子集中所有纸牌的最大等级是M。洗完选出的纸牌后，他们从牌堆的最上面拿出8张，从左到右连续地放置它们形成4个“山峰”。举个例子，如果M=13而且前10张纸牌（26张的前10张）是：<br />\n　　6B 3R 5B 2B 1B 5R 13R 7B 11R 1R …<br />\n　　那么这个游戏开始的时候就像图7所展示的那样。<br />\n<img width=\"402\" height=\"166\" src=\"/RequireFile.do?fid=E9Fd7h43\" /><br />\n<br />\n<br />\n　　剩下的纸牌正面朝上被放置成一排。<br />\n　　每个玩家被认定一种颜色，红色或黑色。Birgit总被认定是黑色，Axel总被认定是红色。第一张用于组成山峰和山谷的纸牌的颜色决定了哪个玩家先开始。图7的那个例子，Birgit先开始，因为第一张纸牌是6B。<br />\n　　玩家交替进行操作。一步操作包括从一排纸牌的最前面抽取一张纸牌然后进行下列的一条：<br />\n　　1．持有这张纸牌直到下次操作（这是一张“被持有的纸牌”）。<br />\n　　2．用刚抽取的纸牌或被持有的纸牌覆盖在两个山峰之间的山谷，形成一个“基底”。如果还剩下一张牌，那么这张牌就被持有。<br />\n　　3．把2张纸牌放在基底上面，形成一个山峰（其中一张纸牌一定是一张被“持有”的纸牌）。<br />\n　　不是所有的选择总是可行的。任何时候最多持有1张纸牌，所以第一个选择只有当这个玩家没有持有纸牌时才可行。<br />\n　　因为排成一排的纸牌是正面朝上，所以两个玩家在纸牌被抽取前就事先知道纸牌的顺序。<br />\n　　如果玩家通过添加了一个基底组成了一个向下的三角形，或者通过添加了一个山峰组成了一个向上的三角形，那么玩家的分数就会像下面描述的那样更新。组成三角形的3张纸牌的等级之和将被增加到那个颜色与3张纸牌的多数颜色相等的那个玩家的分数上。如果在游戏中没有组成三角形，两个玩家的分数保持不变。<br />\n　　图7的那个例子，如果Birgit放置她的纸牌（11R）到中间的山谷上，她将获得14分。如果她放置她的纸牌到左边的山谷上，Axel获得19分。如果她放置她的纸牌到右边的山谷上，Axel获得29分。<br />\n　　如果在某步操作结束后没有纸牌等待被抽取，这个游戏就结束了。如果某个玩家在这个时候持有纸牌，那个玩家的分数将会增加（或减少）这张纸牌的等级如果这张纸牌的颜色与玩家颜色相同（不同）。<br />\n　　当这个游戏结束后，分数低的玩家将要支付一定数量的瑞典克朗给另一个玩家，数量等同于两个玩家的分数差。如果是平局，就不用支付。<br />\n　　你必须写一个程序读入一副被洗过的牌堆和一个玩家的名字，然后找出这个玩家最多能赢多少（或者最少能输多少），假设另一个玩家总是采取最优策略。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　读入包含多组测试数据代表多个游戏。每组测试数据包含一个名字（Axel或者Birgit），然后会有1个最大的等级M（5 ≤ M ≤ 13），紧接着有2M张纸牌的等级和颜色，按在牌堆中的位置给出。每一个等级（从1到M）和颜色的组合在序列中只会出现一次。初始序列的前8张按抽出的顺序从左到右组成山峰，剩下的显示了纸牌的顺序。<br />\n　　包含单词End的一行紧跟在最后一组数据后面。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每个测试数据，输出数据的编号（从1开始），这组数据中玩家的名字，和这个玩家赢或输了多少分数。如果是平局，指出是平局而不是输出数字。参照样例输出的格式。</div><div class='pdsec'>样例输入</div><div class='pddata'>Axel<br />\n5<br />\n1R 2R 3R 4R 5R 5B 4B 3B 2B 1B<br />\nBirgit<br />\n5<br />\n1R 2R 3R 4R 5R 5B 4B 3B 2B 1B<br />\nBirgit<br />\n5<br />\n1R 1B 3R 4R 5R 5B 4B 3B 2R 2B<br />\nEnd</div><div class='pdsec'>样例输出</div><div class='pddata'>Case 1: Axel wins 1<br />\nCase 2: Birgit loses 1<br />\nCase 3: Axel and Birgit tie</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　5 ≤ M ≤ 13；<br />\n　　每个测试点包含不超过5组测试数据。</div>\n","gpid":"T477","lanqiaotitle":"House of Cards","memorylimit":"256.0MB","tid":"ADV-254","timelimit":"1.0s","title":"算法提高 House of Cards","src":"ACM/ICPC World Finals 2009 G"},{"checkpoint":"暴力 几何","updatetime":"2018-01-05","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　格林维尔的市议会最近对改善城市道路景观进行了投票。为了让城市增添一丝绿色，市议会决定在主要的大街两旁种树。由于想要初步预算这个城市改善计划的费用，市议会想要知道会种多少树。种树的时候有以下两条限制：<br />\n　　● 在一条大街上，每两棵树之间的距离至少为 50 米。这是为了给树提供充足的生长空间，同时把费用控制在合理的范围内。<br />\n　　●  出于安全考虑，树与它所在的大街上十字路口的距离应该不少于 25 米。这是为了保证司机能够轻松地看到其他靠近十字路口的人。交通安全决不能因为能见度降低而被削弱。<br />\n<br />\n　　在这个项目中的所有大街都是笔直不弯曲的。<br />\n<br />\n　　市议会想知道在这两个条件下能种的树有几棵。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个整数 n，表示地图中大街的数量。接下来 n 行，每行四个整数 x1, y1, x2, y2，表示一条从 (x1, y1) 到 (x2,y2) 的线段，描述一条大街。每条大街长度都是正数，且每个端点只落在一条大街上。<br />\n<br />\n　　对于一条大街，相邻的十字路口或端点的距离不会是 25 的倍数。更准确地，他们的距离与 25 的倍数的差不少于 0.001。在每个十字路口，恰好只会有两条大街交叉。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出在上述特定条件下最多能种的树的棵树。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n0 40 200 40<br />\n40 0 40 200<br />\n0 200 200 0</div><div class='pdsec'>样例输出</div><div class='pddata'>13</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\n0 30 230 30<br />\n0 200 230 200<br />\n30 0 30 230<br />\n200 0 200 230</div><div class='pdsec'>样例输出</div><div class='pddata'>20</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n0 1 121 1<br />\n0 0 121 4<br />\n0 4 121 0</div><div class='pdsec'>样例输出</div><div class='pddata'>7</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　30%的数据 n = 2。<br />\n<br />\n　　另 30%的数据 0 ≤ x1, y1, x2, y2 ≤ 100。<br />\n<br />\n　　100%的数据 n ≤ 100,0 ≤ x1, y1, x2, y2 ≤ 100000。</div>\n","gpid":"T476","lanqiaotitle":"Tree-Lined Streets","memorylimit":"256.0MB","tid":"ADV-253","timelimit":"1.0s","title":"算法提高 Tree-Lined Streets","src":"ACM/ICPC World Finals 2004 H"},{"checkpoint":"计算几何","updatetime":"2017-12-29","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　一个高新技术公司研制了一种绝缘的新材料，这种材料由晶体和晶体赖以生长的网格矩形组成，网格上生长点的间隔距离为1cm。晶体就是由这些生长点为向外生长，直到生长出直径为1cm的一个圆。<br />\n　　应用这种新材料需要将网格切割成块。在切割中存在一个问题，在切割过程中一些晶体可能被破坏。当晶体圆片被切割，并且切割不过圆片的中心时，晶体的绝缘性能被破坏（切割线与晶体圆片相切时，仍不破坏晶体的绝缘性能）。<br />\n<img width=\"406\" height=\"108\" src=\"/RequireFile.do?fid=rmbTNNER\" /><br />\n　　于是，一个材料块的有效容量就是其包含的未被破坏的晶体（或晶体的一部分）的总面积。下图给出了一个实例，阴影部分是未被破坏的晶体。<br />\n<img width=\"366\" height=\"306\" src=\"/RequireFile.do?fid=6R7qdR7f\" /><br />\n　　你的任务就是测量统计一个给定材料块的有效容量。<br />\n　　注意：任何不经过圆心的割线都会使被割的圆完全失效。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包括一组多边形的顶点序列。每一个描述多边形的数据包括一个正整数N，表示顶点总数。以下有N行，每行两个整数x和y，表示一个顶点。所有顶点按照顺时针排列，并且坐标的绝对值不超过250。当N=0时表示输入结束。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每一个有效的多边形，输出其有效容量，精确到小数点后3位。</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n0 2<br />\n3 5<br />\n6 3<br />\n6 0<br />\n1 0<br />\n0</div><div class='pdsec'>样例输出</div><div class='pddata'>15.315</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于100%的测试点，N &lt;= 25，数据组数T &lt;= 5，每个顶点坐标的绝对值P &lt;= 250。</div>\n","gpid":"T469","lanqiaotitle":"Crystal clear","memorylimit":"256.0MB","tid":"ADV-249","timelimit":"3.5s","title":"算法提高 Crystal clear","src":"ACM/ICPC World Finals 1998 A"},{"checkpoint":"搜索 剪枝","updatetime":"2017-12-29","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　“哈佛结构”是指一台拥有多个分散内存用于记录指令与数据的计算机。这个术语起源于“哈佛马克1号”计算机。它由IBM于1944年制造，用纸带记录指令，用继电器来储存数据。<br />\n　　一些最新的单片机使用了“哈佛结构”（当然没有用纸带和继电器）。数据是由“内存库”来组织，每个“内存库”拥有相同数量的数据。每一个访问数据的指令都由2个数控制。一个数a（非0即1）。如果a为0，那么访问的是0号“内存库”。如果a为1则访问BSR（bank select register “内存库”选择寄存器）中选择的“内存库”。另一个数f表示访问该“内存库”的第f个变量。我们假设每一个指令花费相同的时间运行。另外还有一个可以设定BSR值的命令。<br />\n　　举例来说，假设有4个“内存库”，每个“内存库”有8个字节。为了访问位置5（0号“内存库”第5个变量），我们有两种方法。第一种，使用指令a=0，f=5。第二种，先将BSR的值设为0，然后使用指令a=1，f=5。第一种方法更快，因为它不需要花费时间设置BSR。<br />\n　　现在假设（还是刚才的“内存库”）我们要访问位置20（2号“内存库”第4个变量）。现在只有1种方法能够访问。将BSR的值设为2（除非BSR原来就是2），然后用指令a=1，f=4。<br />\n　　一个程序是一个操作的序列，每个操作是：<br />\n　　●一个变量访问操作，写作Vi，i是一个正整数。<br />\n　　●一个循环操作，写作 Rn &lt;program&gt; E，n是一个正整数，&lt;program&gt;是一个任意的程序。这个操作等价于依次执行n遍&lt;program&gt;。<br />\n　　你的工作是决定一个程序最小的运行时间。更确切的说，给出“内存库”的个数和大小，需要执行的程序，输出为了执行这个程序最小的指令数（包括数据访问指令和设定BSR的指令）。为了完成这个，你必须设定一个变量到“内存库”的映射，使得这个程序运行时间最短，并且输出这个时间（也就是程序运行的指令数）。开始的时候BSR的值为undefined，直到一条命令显式的设定了它的值。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　每组输入包含一个case，两行。第一行两个整数b和s，1≤b≤13代表“内存库”的个数，1≤s≤13代表每个“内存库”的大小（即能储存的变量数）。第二行是一个非空程序，最多有1000个元素（每个Rn，Vi，E都算1个元素）。<br />\n　　保证：<br />\n　　在循环Rn中，循环次数1≤n≤10^6。<br />\n　　在循环Rn &lt;program&gt; E中, &lt;program&gt;非空。<br />\n　　在数据访问Vi中，1≤i≤min(b*s,13)。<br />\n　　程序访问变量的次数不超过10^12次。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出运行该程序最少需要的指令数。</div><div class='pdsec'>样例输入</div><div class='pddata'>1 2<br />\nV1 V2 V1 V1 V2</div><div class='pdsec'>样例输出</div><div class='pddata'>5</div><div class='pdsec'>样例输入</div><div class='pddata'>2 1<br />\nV1 V2 V1 V1 V2</div><div class='pdsec'>样例输出</div><div class='pddata'>6</div><div class='pdsec'>样例输入</div><div class='pddata'>1 2<br />\nR10 V1 V2 V1 E</div><div class='pdsec'>样例输出</div><div class='pddata'>30</div><div class='pdsec'>样例输入</div><div class='pddata'>4 1<br />\nV1 R2 V2 V4 R2 V1 E V3 E</div><div class='pdsec'>样例输出</div><div class='pddata'>17</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　见输入格式。</div>\n","gpid":"T468","lanqiaotitle":"Harvard","memorylimit":"256.0MB","tid":"ADV-248","timelimit":"10.0s","title":"算法提高 Harvard","src":"ACM/ICPC World Finals 2013 E"},{"checkpoint":"枚举、计算几何","updatetime":"2017-12-29","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　\"眼球风暴\"是当下非常流行的一个游戏。在这个游戏中，玩家需要从一张近视图中识别出图中的物体是什么。比如，一张看起来像是锥形蜡笔的图可能是一个新开的蜡笔盒的图的一部分。下图展示了一个例子，左边的是给出的谜题，而右边则是解答。<br />\n<img src=\"/RequireFile.do?fid=rjT7YaTj\" width=\"585\" height=\"284\" /><br />\n　　图1，一个“眼球风暴”的给出的谜题和解答。（软盘）<br />\n　　你需要做的事是检验一个简化的“眼球风暴”的问题。我们会给你两张图，每张图都是一些线段的集合，且每条线段都是垂直于坐标轴的，并且每条线段都包括它的两个端点。<br />\n　　你需要确定第一张图是不是第二张图的某个部分的放大图。所有的线段都被认为是无宽度的。你需要保证，在第一张图中某条线段的端点在放大前一定是第二张图中某条线段的端点。<br />\n<img src=\"/RequireFile.do?fid=EFDLdFGH\" width=\"621\" height=\"286\" /><br />\n　　图2，第一张图是第二张图中画虚线区域放大三倍后的图。<br />\n　　坐标的单位和比例在同一张图内是一样的。一张图内的单位和比例不一定和另外一张图是一样的。第一张图的大小至少应该是原图中该部分的1倍。对于图2，你应该判定第一张图是第二张图的一部分。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行有两个整数N、M，分别代表第一张图中的线段数量和第二张图中的线段数量。<br />\n　　接下来4*(N+M)个实数，每四个数分别代表一条线段的两个端点的坐标。前4*N个实数代表第一张图的N条线段，剩下的数代表第二张图的M条线段。所有的实数不会超过三位小数。所有的线段长度至少为0.005，线段之间不会覆盖只会相交。数据保证给出的N条线段不同向的线段间至少有一个交点。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　如果第一张图能够在第二张图中找到并且满足上述所有要求，那么输出“valid puzzle”，否则输出“impossible”。数据保证如果第一张图在第二张图中能够被找到，那么不被包括在答案矩形中的线段至少距离矩形0.005。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 12<br />\n9 8 7.5 8 1.5 8 1.5 3.5<br />\n0 5 9 5<br />\n4 2 8 2 5 7 2 7 10 6 8 6 8 7 8 4<br />\n1 9 8 9<br />\n9 3 7 3 4 10 4 5<br />\n4 2 4 4 5 8 5 7 3 6 6 6 0 3 3 3 5 1 5 3</div><div class='pdsec'>样例输出</div><div class='pddata'>valid puzzle</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于20%的数据，N,M&lt;=5。<br />\n　　对于40%的数据，N,M&lt;=20。<br />\n　　对于100%的数据，N,M&lt;=50，坐标范围在-1000到1000之间。</div>\n","gpid":"T466","lanqiaotitle":"Eyeball Benders","memorylimit":"256.0MB","tid":"ADV-247","timelimit":"1.0s","title":"算法提高 Eyeball Benders","src":"ACM/ICPC World Finals 2005 A"},{"checkpoint":"枚举 高精度","updatetime":"2017-12-20","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　好莱坞最新的剧院“the Atheneum of Culture and Movies”拥有一个由计算机控制的成千上万个灯泡组成的巨型荧幕。每行灯泡都用由电脑操作的一系列开关控制。不幸的是，电工接错了开关的型号，并且今天晚上就是ACM的开幕式。你需要写个程序让这些开关正确的运作。<br />\n　　荧幕的一排有n个灯泡，它们被n个开关控制。灯泡和开关都从左至右依次编号为1到n。每个灯泡要么是开的，要么是关的。每组输入数据含有一排灯泡的起始状态和目标状态。<br />\n　　最初的计划是让一个开关控制一个灯泡。但是电工的失误导致了每个开关控制2或3个灯泡，如图1所示。最左边的开关（i=1）控制最左边的两个灯泡（1和2）；最右边的灯泡（i=n）控制最右边的两个灯泡（n-1和n）。剩下的开关（1&lt;i&lt;n）控制3个灯泡i-1，i和i+1。（特别的，如果只有1个灯泡，那么就只有1个开关控制那唯一的灯泡。）也就是说，如果灯泡1是开的，灯泡2是关的，转换开关1则会导致灯泡1关上，灯泡2打开。最少的代价是指将这一排灯泡从初始状态转换到最终状态所需要转换的最少的开关数。<br />\n　　你可以将一排开关的状态表示为二进制数，0表示关，1表示开。举例来说，01100表示一排5个灯泡，其中第二个和第三个是开的。如果要把这个状态转化到10000，可以转换开关1、4、5，或者转换开关2。<br />\n　　你需要写个程序来决定最少转换哪些开关使得这排灯泡从初始状态变为目标状态。有些初始状态和目标状态是无解的。为了压缩数据，我们用10进制来输入。也就是说，01100和10000将用12和16来表示。<br />\n<img src=\"/RequireFile.do?fid=mrtN894H\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入数据有多个case。每个case一行，2个非负整数，其中至少有一个是整数，并且不超过100个数字。第一个数字表示开始状态，第二个数字表示目标状态。这些数字化为2进制后表示一行灯泡的状态，1是开，0是关。<br />\n　　为了避免二进制数中出现前导0的问题，数据保证第一个灯泡要么在起始状态是亮的，要么是在目标状态是亮的（或者都是亮的）。输入保证没有多余的空格，输入的10进制数中没有前导0，两个数由一个空格隔开。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对每个case，输出一行。包括case编号和一个十进制数。这个十进制数表示在最小代价下，需要转换的开关的状态。也就是说如果把这个数转为2进制后，最右边的位（最低位）代表第n个开关的状态，1表示开关转换过，0表示没有。如果无解，输出“impossible”。如果有多组解，输出转成十进制后最小的那一个。<br />\n　　在每个case间输出一个空行，用输出样例显示的格式输出。</div><div class='pdsec'>样例输入</div><div class='pddata'>12 16<br />\n1 1<br />\n3 0<br />\n30 5<br />\n7038312 7427958190<br />\n4253404109 657546225<br />\n0 0</div><div class='pdsec'>样例输出</div><div class='pddata'>Case Number 1: 8<br />\n<br />\nCase Number 2: 0<br />\n<br />\nCase Number 3: 1<br />\n<br />\nCase Number 4: 10<br />\n<br />\nCase Number 5: 2805591535<br />\n<br />\nCase Number 6: impossible</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　case的数量不超过30组，其余见输入格式。</div>\n","gpid":"T465","lanqiaotitle":"Light Bulbs","memorylimit":"256.0MB","tid":"ADV-246","timelimit":"1.0s","title":"算法提高 Light Bulbs","src":"ACM/ICPC World Finals 2003 B"},{"checkpoint":"网络流 KM算法","updatetime":"2017-12-15","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　第一次加利福尼亚整体会议在1979年于旧金山举行。“加利福尼亚的”是一个轻微的夸大，因为23个参加者实际上都住在旧金山。几年后，在1987年，会议是真正的“加利福尼亚的”了，337个参加者从该州的各个地方来。自从那时起，参加者的数目像芯片尺寸那样增长。在1993年，会议被重新命名为“美国整体会议”（有2549个参加者），第二次重新命名（被重新命名为“世界整体会议”）是在1997年之后，当时参加者的数量增加到9973人。在对词语“银河”是否有排除银河外的生命形式的意味这一问题的一些讨论后，会议在2003年得到了它现在的名字（银河整体会议）。第二年，所有注册了的参加者仍然是地球上的，虽然一些参加者积极地汇报，说已经感觉到有地球外的生命出席。<br />\n　　专题讨论会的数量随着参加者的数量的增长而增长。对于即将开始的会议，组织方必须面对一些务实但是非常讨厌的时间安排的问题。对于2005年的这次会议而言，寄宿地点决定同时提供的专题讨论会不能超过1000个。然而他们必须租他们能够拿到的每个大厅或者教室。这些房间中的某一些只在一个受限制的时间段是可以用的。<br />\n　　在第一天的上午，公开会议在一个足球馆内举行。到了下午，参加者出席专题讨论会。然后，组织方的工作人员有一个所有专题讨论会的列表，和每个房间能够容纳的人数，并且每个具体房间可以使用的时间一定是清楚的。有了这些信息，工作人员必须将每个专题讨论会安排到一个在可容纳人数和时间上都足够的房间中。因为这个问题不一定能够解决，足球馆内提供了帐篷，供不能容纳到房间中的人使用。这些帐篷可以容纳足够多的人，但是它们有令人不愉快的热量和噪声。因此组织方的工作人员希望时间表能够最小化需要安排到帐篷中的专题讨论会的数量（即不能安排到房间中的专题讨论会的数量）。如果有多种答案能够最小化需要安排到帐篷中的专题讨论会的数量，工作人员希望最小化需要参加帐篷中的专题讨论会的参加者的数量。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入文件包含多组测试数据。每个测试数据由两部分组成：专题讨论会的列表和租到的房间的列表。<br />\n　　专题讨论会列表以一行（包含一个整数w(0&lt;w&lt;=1000)，表示专题讨论会的数量）。<br />\n　　接下来的w行，每行2个整数，描述一个专题讨论会。第一个数p表示参加者的人数(0&lt;p&lt;=100)。第二个数d表示专题讨论会持续的时间(0&lt;d&lt;=300)，以分钟计。为了你的方便，专题讨论会其他的细节被省略。所有的专题讨论会在14:00开始。<br />\n　　租到的房间的列表以一行（包含一个整数r(0&lt;r&lt;=1000)，表示租到的房间的数量）。<br />\n　　接下来的r行，每行1个整数s和一个形如hh:mm的字符串，描述一个租到的房间。整数s表示房间可以容纳的人数(0&lt;p&lt;=100)。形如hh:mm的字符串表示房间必须腾空的时间，以24小时制表示，其中hh表示小时，mm表示分钟。所有的房间从14:00开始可以使用。所有的房间必须腾空的时间在14:01到23:59之间（包括14:01和23:59）。<br />\n　　输入文件以一个数字0结束。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于输入中的每个测试数据，必须输出一行，包括两个整数，需要安排到帐篷中的专题讨论会的数量和需要参加帐篷中的专题讨论会的参加者的数量。注意按照输出样例中的个数输出。</div><div class='pdsec'>样例输入</div><div class='pddata'>1<br />\n20 60<br />\n1<br />\n30 16:00<br />\n2<br />\n20 60<br />\n50 30<br />\n1<br />\n30 14:50<br />\n0</div><div class='pdsec'>样例输出</div><div class='pddata'>Trial 1: 0 0<br />\nTrial 2: 2 70</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于30%的数据，p&lt;=5，r&lt;=5；<br />\n　　对于70%的数据，p&lt;=100，r&lt;=100；<br />\n　　对于全部的数据，0&lt;p&lt;=1000，0&lt;r&lt;=1000，每个测试点中测试数据不超过5组。</div>\n","gpid":"T438","lanqiaotitle":"Workshops","memorylimit":"128.0MB","tid":"ADV-245","timelimit":"10.0s","title":"算法提高 Workshops","src":"ACM/ICPC World Finals 2005 I"},{"checkpoint":"线段树","updatetime":"2017-12-15","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　在2011年ACM-ICPC World Finals上的一次游览中，你碰到了一个埃及古墓。<br />\n　　不幸的是，你打开了坟墓之后，才发现这是一个坏主意：突然之间，原本空无一物的沙漠上已经爬满了暴躁的木乃伊。（如果你也沉睡几千年而突然被惊醒，你也会变得如此暴躁的。）（幸运的是，当你做完这道题的时候，你醒来了，发现你在弗罗里达的酒店里。那些木乃伊只是一场梦。）<br />\n　　面对这一大堆疯狂的木乃伊，你唯一的机会就是试图在他们抓到你之前逃跑。问题是：假如你与木乃伊永不疲倦，那么经过多长时间你会被木乃伊抓到？<br />\n　　我们把沙漠看成一个正方形的网格，你与木乃伊轮流移动（你走出第一步）。轮到你时，你可以移动到相邻的8个格子之一，或者站着不动。轮到木乃伊时，每个木乃伊会移动到其相邻的格子之一，使得他与你的欧几里得距离尽量小（假设你与木乃伊都站在格子的中心位置）。允许多个木乃伊同时占据同一个格子。<br />\n　　在每个单位时间内，你先做出移动，然后木乃伊做出移动。如果你与任何一个木乃伊站在同一位置，你会被抓住。当然，你试图尽量长时间避免被抓住。经过多少单位时间你会被抓住呢？<br />\n　　下图描述了你被4个木乃伊追逐的例子。H代表你的初始位置，而M代表木乃伊的初始位置。以你的初始位置为原点，则经过4个单位时间后，你被初始位置为(3,4)的木乃伊抓住。<br />\n<img src=\"/RequireFile.do?fid=mQ6GmaLR\" width=\"320\" height=\"320\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入文件包含若干组数据。每组数据的第一行为一个数n(0≤n≤10^5)，表示沙漠中木乃伊的个数。接下来n行，每行两个整数x y，表示初始时在(x,y)有一个木乃伊。x,y的绝对值均不超过10^6。你的初始位置是(0,0)，保证一开始这里没有木乃伊。<br />\n　　输入文件以一行-1结束。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组测试数据，输出一行，包括它的编号和被抓住经过的最长时间（即你做出决策的次数）；或输出\"never\"，如果你有办法永远不被抓住。<br />\n　　请以样例输出的格式输出数据。</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\n-3 5<br />\n3 4<br />\n-6 -2<br />\n1 -5<br />\n1<br />\n0 -1<br />\n-1</div><div class='pdsec'>样例输出</div><div class='pddata'>Case 1: 4<br />\nCase 2: never</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于20%的数据，n≤100；对于50%的数据，n≤1000；对于100%的数据，n≤10^5，每个输入文件只有1组数据。</div>\n","gpid":"T437","lanqiaotitle":"Mummy Madness","memorylimit":"256.0MB","tid":"ADV-244","timelimit":"1.0s","title":"算法提高 Mummy Madness","src":"ACM/ICPC World Finals 2011 I"},{"checkpoint":"事件点、最小生成树","updatetime":"2017-12-15","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　这是2112年，人类已经征服了太阳系。太空游侠队已经在任何大块岩石上建立了基地（即使不适宜居住）。你作为小行星通讯部门的一员，工作是确保所有太空游侠小行星基地都能尽可能廉价地与其他小行星基地交流。你可以建立从每个基地到另外所有基地的直接交流连接，但那可能过分昂贵。相反，你想要建立最少数量的连接从而每个人都可以发送信息给其他所有人，信息可能通过一个或多个基地中转。建立任何连接的费用与它连接的两个基地之间的（欧几里德）距离成比例，所以这个问题看起来不怎么难。<br />\n　　但这只是一个小小的困难。小行星有一个运动的趋势，所以两个当前很接近的基地在将来不一定还是很接近。因此随着时间流逝，你一定会乐意转换你的交流连接，从而在任何时候你都拥有最廉价的中继系统。转换这些连接花费时间和金钱，所以你对于了解将要执行多少次转换很感兴趣。<br />\n　　一些假设让这个任务更简单。每个小行星可以视为一个点。小行星总是以固定的速度沿直线运动。没有小行星会和其他小行星相撞。此外，任何在时刻t(t≥0)变得最优的中继系统在任何时刻s(s满足t&lt;s&lt;t+10^-6)时是独一无二最优的。初始最优的中继系统也是独一无二的。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　每组数据（tsinsen上的数据均为单组数据）以包含一个整数n的一行开始，其中n表示小行星基地的数量。<br />\n　　接下来n行，每行包含6个整数x,y,z,vx,vy,vz，前三个表示这个小行星的初始位置，后三个表示小行星在x,y,z三维上的速度（单位空间每单位时间）。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组数据，输出一行，包含数据编号和中继系统需要被建立或修改的次数。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n0 0 0 0 0 0<br />\n5 0 0 0 0 0<br />\n10 1 0 -1 0 0<br />\n4<br />\n0 0 0 1 0 0<br />\n0 1 0 0 -1 0<br />\n1 1 1 3 1 1<br />\n-1 -1 2 1 -1 -1</div><div class='pdsec'>样例输出</div><div class='pddata'>Case 1: 3<br />\nCase 2: 3</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　5%的数据满足n=2。<br />\n　　15%的数据满足n&lt;10。<br />\n　　另10%的数据满足 所有点运动方向和速度一致。<br />\n　　另5%的数据满足 只有一个点与其他点的运动方向和速度不同。<br />\n　　100%的数据满足n≤50,-150≤x,y,z≤150,-100≤vx,vy,vz≤100。</div>\n","gpid":"T435","lanqiaotitle":"Asteroid Rangers","memorylimit":"256.0MB","tid":"ADV-243","timelimit":"2.0s","title":"算法提高 Asteroid Rangers","src":"ACM/ICPC World Finals 2012 A"},{"checkpoint":"模拟","updatetime":"2017-12-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Code-11是一种主要用来将标签编码为条形码的编码方式。被编码的字符被限制为0-9和'-'号，以及一种特殊的符号：开始和结束标志（开始标志出现在Code-11编码的最前面而结束标志出现在最后面）。<br />\n　　Code-11的编码会独立的编码每一个字符。一个字符会由5个相邻的区域来编码。每个区域可能是深色和浅色中的一种，相邻的两个区域的颜色一定不同，每次编码的第一个区域的颜色一定是深色的。每个区域的宽度也不是一定的，我们将宽度总共分为两种，用0表示一个窄的区域，用1表示一个宽的区域。<br />\n<table cellspacing=0 cellpadding=2px style='border-collapse:collapse;' class='table table-striped table-horver'><tbody><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>字符</td><td style='border:solid 1.0pt'>编码</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>0</td><td style='border:solid 1.0pt'>00001</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>1</td><td style='border:solid 1.0pt'>10001</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>2</td><td style='border:solid 1.0pt'>01001</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>3</td><td style='border:solid 1.0pt'>11000</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>4</td><td style='border:solid 1.0pt'>00101</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>5</td><td style='border:solid 1.0pt'>10100</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>6</td><td style='border:solid 1.0pt'>01100</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>7</td><td style='border:solid 1.0pt'>00011</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>8</td><td style='border:solid 1.0pt'>10010</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>9</td><td style='border:solid 1.0pt'>10000</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>-</td><td style='border:solid 1.0pt'>00100</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>开始/结束标志</td><td style='border:solid 1.0pt'>00110</td></tr></tbody></table><br />\n　　因此，字符1被编码后就会表示成为深色的宽区域，浅色的窄区域，深色的窄区域，浅色的窄区域，深色的宽区域这五个区域。并且，在编码后两个相邻的字符各自编码出来的五个区域之间需要用一个浅色的窄区域将它们隔开。这个浅色的窄区域的唯一功能就是分割两个字符编码出来的区域。<br />\n　　Code-11这种编码方式可以简化我们的编码和解码过程，因为他仅需要区分窄区域和宽区域，并且提高了对低打印水平的容忍度。<br />\n　　为了能够检验编码中出现的错误，Code-11在编码时会用到两个检验字符C和K，并且会把C和K插入到原串的末尾再进行编码（在结束标志之前）。假设需要被编码的串有n个字符，分别是c1、c2……cn，那么检验字符C的值就应该是sigma( ( ( n - i ) mod 10 + 1 ) * w ( c [i] ) ) mod 11(1&lt;=i&lt;=n)。其中，w(c[i])是字符c[i]的权重。如果c[i]是0、1、2、……9这些字符，那么c[i]的权重就是0、1、2、……9。如果c[i]是'-'，那么c[i]的权重就是10。（注意mod的运算优先级比+高）<br />\n　　与此对应的检验字符K的值是sigma( ( ( n - i + 1) mod 9 +1 ) * w ( c [i] ) ) mod 11(1&lt;=i&lt;=n+1)，其中c[n+1]即为检验字符C。举个例子，假设需要被编码的字符串是123-45，那么我们有C=5和K=2，所以最终需要被编码的字符串是123-4552，并且有一个开始标志和结束标志分别在头部和尾部。<br />\n　　一般的简单的条形码读取器会包含数百个小型的CCD传感器，这些CCD传感器会识别出深色和浅色区域以及每一块的宽度。利用这些信息，解码器就会将解码得到被编码之前的信息。由于条形码的方向不是固定的，所以无论读取器是正着扫描的条形码还是倒着扫描的，解码器都需要能够解码。<br />\n　　你的任务是解码一个被Code-11编码过的条形码。你能够知道每一块区域的宽度，并且宽的区域的宽度是窄的区域的宽度的两倍。但是由于打印设备的不完美，所以读取的区域宽度可能跟实际的宽度有5%的误差。在数据当中不会有编码前长度为0的字符串。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个正整数N，代表被编码后的条形码的区域个数。<br />\n　　接下来N个正整数，每行最多十个正整数，代表条形码每个区域的宽度。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　如果该条形码无法被成功解码，输出\"bad code\"。<br />\n　　如果该条形码能被成功解码但是检验字符C的值不正确，输出\"bad C\"。<br />\n　　如果该条形码能被成功解码且检验字符C的值正确但检验字符K的值不正确，输出\"bad K\"。<br />\n　　如果该条形码能被成功解码且两个检验字符均是正确的，输出不包含检验字符和起始结束标志的原字符串。</div><div class='pdsec'>样例输入</div><div class='pddata'>59<br />\n10 20 20 10 10 10 20 10 10 20<br />\n10 10 10 10 20 10 20 10 10 10<br />\n20 10 20 10 20 10 20 10 10 10<br />\n10 10 20 10 10 10 10 10 10 20<br />\n20 10 20 10 10 20 10 10 20 10<br />\n10 10 20 10 10 20 20 10 10</div><div class='pdsec'>样例输出</div><div class='pddata'>123-45</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于100%的数据，N&lt;=150，所有的宽度&lt;=250。</div>\n","gpid":"T432","lanqiaotitle":"Barcodes","memorylimit":"256.0MB","tid":"ADV-242","timelimit":"1.0s","title":"算法提高 Barcodes","src":"ACM/ICPC World Finals 2010 B"},{"checkpoint":"计算几何 实现","updatetime":"2017-12-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　等高线图可以描绘一个区域的地势。等高线图上的等高线代表等高海拔。比如，一张等高线图上可能有一条线代表海拔100米的区域，另一条代表海拔200米的区域等等。<br />\n　　等高线图绘制协会（Association for Contour Mapping，简称ACM）需要程序读取从卫星获取的海拔信息并绘制等高线图。ACM尤其关注每张地图上所有等高线的长度之和。海拔信息的形式为一个整数序列，依次代表在一条从西往东的扫描线上取的等距离的点的海拔。扫描线间距的取值使得测量区域内所有不在边缘的每个测高点都有6个其他的测高点离它最近，而且相互等距（这里忽视海拔高度），如图1和图2所示。<br />\n<img src=\"/RequireFile.do?fid=yrT7FH9b\" width=\"683\" height=\"281\" /><br />\n　　ACM的做法是，用线段连接每个点与距其最近的所有点，构造出许多三角形，并用这些三角形来估计实际地形。每个三角形会被视为一个平面，由其三个顶点的坐标和海拔确定。如果把三角形投影到海平面上，这些三角形会是等边三角形。<br />\n　　在上图中，黑色的数字代表海拔信息，红色虚线和数字代表等高线。图1中有一条海拔为5的等高线。图2中在海拔为6和9之处分别有一条等高线。等高线可以穿过三角形的内部或者紧贴三角形的一边。<br />\n　　由于测高点的特殊选取方式，编号为偶数的扫描线较之于编号为奇数的扫描线上会多取一个测高点。图中最上面的一条线是第一条扫描线。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入第一行有4个整数s、p、d和h。<br />\n　　s代表扫描线的条数。<br />\n　　p代表编号为奇数的扫描线上的测高点数，编号为偶数的扫描线上有p+1个测高点。<br />\n　　d代表无视海拔时，每个测高点与距其最近的测高点的距离（即三角形的边长）。<br />\n　　h代表等高线的海拔间隔。在最后的等高线图中，在所有海拔为h的整数倍的地方都会有一条等高线。注意一张地图上同一海拔的等高线可能有多条。当一整块区域水平时，只在边界处有等高线（见图2中海拔为9的等高线）。<br />\n　　接下来共s行，每行描述一条扫描线。对于奇数行，每行含有p个整数，从左到右表示扫描线上测高点的数据。对于偶数行，每行含有p+1个整数，从左到右表示扫描线上测高点的数据。每个数字都是不超过10^6的非负整数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个整数，表示绘制的等高线图上所有等高线的长度之和，四舍五入到最近的整数。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 2 5 5<br />\n1 1<br />\n1 9 1<br />\n1 1</div><div class='pdsec'>样例输出</div><div class='pddata'>15</div><div class='pdsec'>样例输入</div><div class='pddata'>4 4 5 3<br />\n5 7 7 5<br />\n5 9 9 9 5<br />\n9 9 9 9<br />\n7 9 9 9 7</div><div class='pdsec'>样例输出</div><div class='pddata'>54</div><div class='pdsec'>样例输入</div><div class='pddata'>4 3 5 5<br />\n0 5 5<br />\n0 0 0 5<br />\n0 10 0<br />\n0 0 0 20</div><div class='pdsec'>样例输出</div><div class='pddata'>88</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于10%的数据，s = 2，p = 1。<br />\n　　对于30%的数据，保证图中所有等高线的海拔相同。<br />\n　　对于60%的数据，保证任意测高点的海拔都不是h的整数倍。<br />\n　　对于100%的数据，2 ≤ s ≤ 100，1 ≤ p ≤ 100，1 ≤ d ≤ 10，1 ≤ h ≤ 1000。</div>\n","gpid":"T431","lanqiaotitle":"Contour Mapping","memorylimit":"256.0MB","tid":"ADV-241","timelimit":"1.0s","title":"算法提高 Contour Mapping","src":"ACM/ICPC World Finals 2010 F"},{"checkpoint":"计算几何","updatetime":"2017-12-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　公寓建设管理公司（Apartment Construction Management, 简称ACM）在上海郊区新建了几栋高层公寓楼。由于经济增长极为迅速，ACM期望通过出租房屋获得客观的利润。ACM打广告宣称他们的公寓比附近其他的公寓都要好，因为他们的公寓采光更好。没有其他的建筑物阻挡阳光直射到ACM的公寓楼上。<br />\n　　ACM想要证明自己的广告没有虚假成分，于是他们决定告诉潜在住户们每栋楼的采光究竟怎样。为了给消费者们有代表性的数据，公司决定将2005年4月5日的阳光直射时长写入广告。在那一天，上海于早上5点37分日出，于下午6点17分日落。<br />\n<br />\n<img src=\"/RequireFile.do?fid=rGGY5m39\" width=\"666\" height=\"193\" /><br />\n<br />\n　　如上图所示，公寓楼从东至西排列，每栋楼有若干层，每层有一间公寓。公寓门牌号的后两位代表楼栋编号，最东侧的楼编号为01，从东至西编号递增。门牌号的其他所有位则代表楼层，1为一层，2为二层，以此类推。<br />\n　　太阳从东方升起，以恒定角速度划过天空，然后从西方落下。阴影仅由楼房投射出（也即，每栋楼可以投影到一栋或者多栋其他的楼房上）。当一间公寓的整块东侧或西侧外墙被太阳直射，或者当太阳处于公寓正上方时，我们就认为公寓受到太阳直射。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入含有若干组测试数据。一组测试数据首先含有一行，包括一个整数n，代表公寓楼的数量。接下来一行有两个整数w和h，分别代表一间公寓的宽度（东-西方向）和高度，单位为米。接下来一行有2n-1个整数，记作m(1), d(1), m(2), d(2), ... , d(n-1),m(n)。m(i)为编号为i的公寓楼的层数，d(i)为编号为i和i+1的公寓楼之间的距离，单位为米。<br />\n　　接下来的一行包含若干整数，以0结尾。每个整数代表求编号为这个整数的公寓的太阳直射时间。输入的最后一行仅包含一个整数0，你不需要处理这一行。<br />\n　　最多含有10组测试数据。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每组数据，输出数据组数的编号。然后对于每个询问，用24小时格式输出太阳直射时间的起止时刻。所有时间向下取整到秒。允许输出与答案有最大1秒的误差。如果输入中含有不存在的公寓的编号，请将其指出。请按照样例输出中的格式输出。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n6 4<br />\n5 6 3 3 4<br />\n302 401 601 303 0<br />\n4<br />\n5 3<br />\n4 5 7 8 5 4 3<br />\n101 302 503 0<br />\n0</div><div class='pdsec'>样例输出</div><div class='pddata'>Apartment Complex: 1<br />\nApartment 302: 10:04:50 - 13:23:47<br />\nApartment 401: 05:37:00 - 17:13:57<br />\nApartment 601: Does not exist<br />\nApartment 303: 09:21:19 - 18:17:00<br />\nApartment Complex: 2<br />\nApartment 101: 05:37:00 - 12:53:32<br />\nApartment 302: 09:08:55 - 14:52:47<br />\nApartment 503: 09:01:12 - 18:17:00</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　记Q为询问个数。<br />\n　　对于30%的数据，1 ≤ n ≤ 10，1 ≤ m(i) &lt; 10。<br />\n　　对于60%的数据，Q ≤ 10。<br />\n　　对于100%的数据，1 ≤ n &lt; 100，1 ≤ m(i) &lt; 100，1 ≤ d(i), w, h ≤ 100，Q ≤ 1000。</div>\n","gpid":"T430","lanqiaotitle":"Lots of Sunlight","memorylimit":"256.0MB","tid":"ADV-240","timelimit":"1.0s","title":"算法提高 Lots of Sunlight","src":"ACM/ICPC World Finals 2005 E"},{"checkpoint":"模拟 条件判断","updatetime":"2017-11-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　我们用0表示林丹，1表示李宗伟。<br />\n<br />\n　　输入数据中每行会给出一个0或者1，表示对应选手得1分。<br />\n<br />\n　　当一方得分达到21分时，只要该方与对方分差超过1分，该方即胜出。<br />\n<br />\n　　你需要输出最后获胜选手的代号。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　若干行每行一个0或者1。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行一个0或者1表示胜者。</div><div class='pdsec'>样例输入</div><div class='pddata'>1<br />\n1<br />\n1<br />\n1<br />\n1<br />\n1<br />\n1<br />\n1<br />\n1<br />\n1<br />\n1<br />\n1<br />\n1<br />\n1<br />\n1<br />\n1<br />\n1<br />\n1<br />\n1<br />\n1<br />\n1</div><div class='pdsec'>样例输出</div><div class='pddata'>1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入数据可能存在多余信息，选手需要在第一次出现胜者时马上输出。<br />\n　　读入可以使用while (cin &gt;&gt; x){}，该代码块会在读入所有数据后执行完毕。</div>\n","gpid":"T424","lanqiaotitle":"林丹大战李宗伟","memorylimit":"256.0MB","tid":"ADV-236","timelimit":"1.0s","title":"算法提高 林丹大战李宗伟","src":"程序设计基础"},{"checkpoint":"循环 取余","updatetime":"2017-11-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定n和m以及p，保证n&gt;=m，求(n!-m!)对p取余的结果。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一行三个正整数n,m,p。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行一个非负整数表示结果。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 2 10</div><div class='pdsec'>样例输出</div><div class='pddata'>4</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n,m&lt;=20，p&lt;=10000.</div>\n","gpid":"T422","lanqiaotitle":"阶乘差","memorylimit":"256.0MB","tid":"ADV-235","timelimit":"1.0s","title":"算法提高 阶乘差","src":"程序设计基础"},{"checkpoint":"字符串 循环","updatetime":"2017-11-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个字符串，你需要从第start位开始每隔step位输出字符串对应位置上的字符。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个只包含小写字母的字符串。<br />\n<br />\n　　第二行两个非负整数start和step，意义见上。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行，表示对应输出。</div><div class='pdsec'>样例输入</div><div class='pddata'>abcdefg<br />\n2 2</div><div class='pdsec'>样例输出</div><div class='pddata'>ceg</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　start从0开始计数。<br />\n　　字符串长度不超过100000。</div><div class='pdsec'>提示</div><div class='pdcont'>　　读入上有问题，可以参照字符串进位。<br />\n　　尝试不要出现以下代码：for (int i = 0; i &lt; (int) S.size(); ++i)</div>\n","gpid":"T420","lanqiaotitle":"字符串跳步","memorylimit":"256.0MB","tid":"ADV-234","timelimit":"1.0s","title":"算法提高 字符串跳步","src":"程序设计基础"},{"checkpoint":"","updatetime":"2017-01-18","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　扑克牌排序：构造扑克牌数组，对扑克牌进行排序。排序原则如下：数字从小到大是2-10、J、Q、K和A，花色从小到大是方块（diamond）、梅花（club）、红桃（heart）、黑桃（spade）。两张牌比较时先看数字，数字相同时看花色。要求对输入的扑克牌进行从小到大排序。<br />\n　　输入五张牌（表示黑桃2、红桃3、黑桃3、方块A和梅花J）： 2 s 3 h 3 s A d J c<br />\n　　输出结果应为：2 s  3 h 3 s J c A d数组长度固定为5。</div><div class='pdsec'>样例输出</div><div class='pddata'>与上面的样例输入对应的输出。<br />\n例：<br />\n<img src=\"/RequireFile.do?fid=T9mNjTr7\" width=\"296\" height=\"56\" /></div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入数据中每一个数的范围。</div>\n","gpid":"T416","lanqiaotitle":"12-2扑克排序","memorylimit":"256.0MB","tid":"ADV-231","timelimit":"1.0s","title":"算法提高 12-2扑克排序","src":""},{"checkpoint":"","updatetime":"2016-12-12","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　为库设计新函数DelPack，删除输入字符串中所有的重复元素。不连续的重复元素也要删除。<br />\n　　要求写成函数，函数内部使用指针操作。</div><div class='pdsec'>样例输入</div><div class='pddata'>1223445667889</div><div class='pdsec'>样例输出</div><div class='pddata'>13579</div><div class='pdsec'>样例输入</div><div class='pddata'>else</div><div class='pdsec'>样例输出</div><div class='pddata'>ls</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　字符串数组最大长度为100。</div>\n","gpid":"T413","lanqiaotitle":"11-2删除重复元素","memorylimit":"256.0MB","tid":"ADV-228","timelimit":"10.0s","title":"算法提高 11-2删除重复元素","src":""},{"checkpoint":"堆","updatetime":"2016-11-03","content":"<div class='pdcont'>　　为了吸引更多的顾客，某商场决定推行有奖抽彩活动。“本商场每日将产生一名幸运顾客，凡购买30元以上商品者均有机会获得本商场提供的一份精美礼品。”该商场的幸运顾客产生方式十分奇特：每位顾客可至抽奖台抽取一个幸运号码，该商场在抽奖活动推出的第i天将从所有顾客中（包括不在本日购物满30元者）挑出幸运号第i小的顾客作为当日的幸运顾客。该商场的商品本就价廉物美，自从有奖活动推出后，顾客更是络绎不绝，因此急需你编写一个程序，为他解决幸运顾客的产生问题。<br />\n<b> </b><br />\n<b>【输入数据】</b><br />\n　　第1行一个整数N，表示命令数。<br />\n　　第2~N+1行，每行一个数，表示命令。如果x&gt;=0，表示有一顾客抽取了号码x；如果x=-1，表示傍晚抽取该日的幸运号码。<br />\n<b>【输出数据】</b><br />\n　　对应各命令-1输出幸运号码；每行一个号码。(两个相同的幸运号看作两个号码)</div><div class='pdsec'>样例输入</div><div class='pddata'>6<br />\n3<br />\n4<br />\n-1<br />\n-1<br />\n3<br />\n-1</div><div class='pdsec'>样例输出</div><div class='pddata'>3<br />\n4<br />\n4</div><div class='pdsec'>解释</div><div class='pdcont'>　　只关注获奖的号码是多少，每个号码可以获奖多次。</div><div class='pdsec'>数据规模及约定</div><div class='pdcont'>　　共10组数据。<br />\n　　对100%的数据，N=10^6所有命令为-1或int范围内的非负数，前i的命令中-1的数量不超过[i/2]（向下取整）。</div>\n","gpid":"T398","lanqiaotitle":"幸运顾客","memorylimit":"256.0MB","tid":"ADV-220","timelimit":"2.0s","title":"算法提高 幸运顾客","src":""},{"checkpoint":"","updatetime":"2016-11-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　已知2007年1月1日为星期一。设计一函数按照下述格式打印2007年以后（含）某年某月的日历，2007年以前的拒绝打印。为完成此函数，设计必要的辅助函数也是必要的。</div><div class='pdsec'>样例输入</div><div class='pddata'>一个满足题目要求的输入范例。<br />\n例：<br />\n<br />\n2050 3</div><div class='pdsec'>样例输出</div><div class='pddata'>与上面的样例输入对应的输出。<br />\n例：<br />\n<br />\n<br />\n<img src=\"/RequireFile.do?fid=343gYg6N\" /></div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入数据中每一个数的范围。<br />\n　　例：年 2007-3000，月：1-12。</div>\n","gpid":"T394","lanqiaotitle":"5-3日历","memorylimit":"256.0MB","tid":"ADV-216","timelimit":"1.0s","title":"算法提高 5-3日历","src":""},{"checkpoint":"","updatetime":"2016-05-09","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　接受用户输⼊的数值，输出以该值为半径的(1)圆面积，(2)球体表面积，(3)球体体积。pi 取值3.1415926536 ，结果保留10位小数，每一列占20个字符，左对齐。</div><div class='pdsec'>样例输入</div><div class='pddata'>一个满足题目要求的输入范例。<br />\n例：<br />\n1</div><div class='pdsec'>样例输出</div><div class='pddata'>与上面的样例输入对应的输出。<br />\n例：(第一行1是输入，第二行是输出)<br />\n<img src=\"/RequireFile.do?fid=ANQFDtrQ\" width=\"675\" height=\"93\" /></div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　所有结果在double类型的表示范围内。</div>\n","gpid":"T387","lanqiaotitle":"3-3求圆面积表面积体积","memorylimit":"256.0MB","tid":"ADV-214","timelimit":"1.0s","title":"算法提高 3-3求圆面积表面积体积","src":""},{"checkpoint":"","updatetime":"2016-05-09","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　见计算机程序设计基础（乔林）P50第5题。<br />\n　　接受两个数，一个是用户一年期定期存款金额，一个是按照百分比格式表示的利率，计算一年期满后的本金与利息总额。说明：(1)  存款金额以人民币元为单位，精确到分；(2)  输入利率时不输入百分号，例如利率为3.87%，用户直接输入3.87；(3)  按照国家法律，存储利息所得需缴纳5%的所得税，计算结果时应当扣除所得税。(4)  显示的结果精确到人民币分。<br />\n　　注意：数据须用float表示；计算结果须保存到一个float变量中，再用printf输出。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一行，以一个空格隔开的两个浮点数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个浮点数。</div><div class='pdsec'>样例输入</div><div class='pddata'>5000.00 5.00</div><div class='pdsec'>样例输出</div><div class='pddata'>5237.50</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入数据中每一个数的范围。本金&lt;100000000，利息&lt;100</div>\n","gpid":"T386","lanqiaotitle":"3-2求存款","memorylimit":"256.0MB","tid":"ADV-213","timelimit":"1.0s","title":"算法提高 3-2求存款","src":""},{"checkpoint":"","updatetime":"2016-05-09","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编写一个程序，接受用户输入的10个整数，输出它们的和。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　要求用户的输出满足的格式。<br />\n　　例：输出1行，包含一个整数，表示所有元素的和。</div><div class='pdsec'>样例输入</div><div class='pddata'>1 2 3 4 5 6 7 8 9 10</div><div class='pdsec'>样例输出</div><div class='pddata'>55</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入数据中每一个数的范围。<br />\n　　例：输入数&lt;100000。</div>\n","gpid":"T385","lanqiaotitle":"3-1课后习题2","memorylimit":"256.0MB","tid":"ADV-212","timelimit":"1.0s","title":"算法提高 3-1课后习题2","src":""},{"checkpoint":"","updatetime":"2016-05-09","content":"<div class='pdcont'>　　基于例子3 ，写一个程序，实现整数求和:</div><div class='pdsec'>样例输入</div><div class='pddata'>3 4</div><div class='pdsec'>样例输出</div><div class='pddata'>7</div>\n","gpid":"T383","lanqiaotitle":"2-2整数求和","memorylimit":"256.0MB","tid":"ADV-211","timelimit":"1.0s","title":"算法提高 2-2整数求和","src":""},{"checkpoint":"","updatetime":"2016-05-09","content":"<div class='pdsec'>样例输出</div><div class='pddata'>**********************<br />\n* My first C program *<br />\n**********************</div>\n","gpid":"T382","lanqiaotitle":"2-1屏幕打印","memorylimit":"256.0MB","tid":"ADV-210","timelimit":"1.0s","title":"算法提高 2-1屏幕打印","src":""},{"checkpoint":"循环，输出","updatetime":"2016-05-09","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输出1~100间的质数并显示出来。注意1不是质数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　每行输出一个质数。<br />\n　　2<br />\n　　3<br />\n　　...<br />\n　　97</div>\n","gpid":"T381","lanqiaotitle":"c++_ch02_04","memorylimit":"256.0MB","tid":"ADV-209","timelimit":"1.0s","title":"算法提高 c++_ch02_04","src":""},{"checkpoint":"递归","updatetime":"2016-05-09","content":"<div class='pdcont'>　　最长字符序列</div><div class='pdsec'>问题描述</div><div class='pdcont'>　　设x(i), y(i), z(i)表示单个字符，则X={x(1)x(2)……x(m)}，Y={y(1)y(2)……y(n)}，Z={z(1)z(2)……z(k)},我们称其为字符序列，其中m,n和k分别是字符序列X，Y，Z的长度，括号()中的数字被称作字符序列的下标。<br />\n　　如果存在一个严格递增而且长度大于0的下标序列{i<sub>1</sub>,i<sub>2</sub>……i<sub>k</sub>}，使得对所有的j=1,2,……k，有x(i<sub>j</sub>)=z(j)，那么我们称Z是X的字符子序列。而且，如果Z既是X的字符子序列又是Y的字符子序列，那么我们称Z为X和Y的公共字符序列。<br />\n　　在我们今天的问题中，我们希望计算两个给定字符序列X和Y的最大长度的公共字符序列，这里我们只要求输出这个最大长度公共子序列对应的长度值。<br />\n　　举例来说，字符序列X=abcd，Y=acde，那么它们的最大长度为3，相应的公共字符序列为acd。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入一行，用空格隔开的两个字符串</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出这两个字符序列对应的最大长度公共字符序列的长度值</div><div class='pdsec'>样例输入</div><div class='pddata'>aAbB aabb</div><div class='pdsec'>样例输出</div><div class='pddata'>2</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入字符串长度最长为100，区分大小写。</div>\n","gpid":"T378","lanqiaotitle":"最长字符序列","memorylimit":"256.0MB","tid":"ADV-207","timelimit":"1.0s","title":"算法提高 最长字符序列","src":""},{"checkpoint":"高精度 精度估计","updatetime":"2016-05-09","content":"<div class='pdsec'>目前已AC者</div><div class='pdcont'>　　刘啸宇<br />\n　　章放</div><div class='pdsec'>问题描述</div><div class='pdcont'>　　在当今的大数据时代，超大数的高精度计算已经成为众多领域的热门研究之一。现在T校也想在此领域有所造诣已造福于全社会，然而由于时间有限，所以短时间内难以找出大数计算的通用算法，于是学校找到了同学中的“神霸”——你来帮忙，并仅要求你能在数并不算大的时候给出结果。又出于某种特殊需要，也并不要求你给出数的全部结果，而只是要求结果的前10位（注意不是后10位），并考虑到2的幂次的特殊性和典型性，所以要你计算的数均为2的幂次。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一个自然数n。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　2的n次幂的前10位。</div><div class='pdsec'>样例1 输入</div><div class='pdcont'>　　60</div><div class='pdsec'>样例1 输出</div><div class='pdcont'>　　1152921504</div><div class='pdsec'>样例2 输入</div><div class='pdcont'>　　60000</div><div class='pdsec'>样例2 输出</div><div class='pdcont'>　　6305794870</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　0&lt;=n&lt;=10000000</div><div class='pdsec'>注释</div><div class='pdcont'>　　=。=</div>\n","gpid":"T377","lanqiaotitle":"不大的数","memorylimit":"8.0MB","tid":"ADV-206","timelimit":"300ms","title":"算法提高 不大的数","src":"原创 by 章放"},{"checkpoint":"快速幂","updatetime":"2016-05-09","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定A, B, P，求(A^B) mod P。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入共一行。<br />\n　　第一行有三个数，N, M, P。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出共一行，表示所求。</div><div class='pdsec'>样例输入</div><div class='pddata'>2 5 3</div><div class='pdsec'>样例输出</div><div class='pddata'>2</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　共10组数据<br />\n　　对100%的数据，A, B为long long范围内的非负整数，P为int内的非负整数。</div>\n","gpid":"T375","lanqiaotitle":"快速幂","memorylimit":"256.0MB","tid":"ADV-204","timelimit":"1.0s","title":"算法提高 快速幂","src":""},{"checkpoint":"DFS","updatetime":"2016-05-09","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　规则同8皇后问题，但是棋盘上每格都有一个数字，要求八皇后所在格子数字之和最大。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一个8*8的棋盘。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　所能得到的最大数字和</div><div class='pdsec'>样例输入</div><div class='pddata'>1  2  3  4  5  6  7  8<br />\n9 10 11 12 13 14 15 16<br />\n17 18 19 20 21 22 23 24<br />\n25 26 27 28 29 30 31 32<br />\n33 34 35 36 37 38 39 40<br />\n41 42 43 44 45 46 47 48<br />\n48 50 51 52 53 54 55 56<br />\n57 58 59 60 61 62 63 64</div><div class='pdsec'>样例输出</div><div class='pddata'>260</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　棋盘上的数字范围0~99</div>\n","gpid":"T374","lanqiaotitle":"8皇后·改","memorylimit":"256.0MB","tid":"ADV-203","timelimit":"1.0s","title":"算法提高 8皇后·改","src":""},{"checkpoint":"DP","updatetime":"2016-05-09","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定两个字符串，寻找这两个字串之间的最长公共子序列。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入两行，分别包含一个字符串，仅含有小写字母。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　最长公共子序列的长度。</div><div class='pdsec'>样例输入</div><div class='pddata'>abcdgh<br />\naedfhb</div><div class='pdsec'>样例输出</div><div class='pddata'>3</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　最长公共子序列为a，d，h。</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　字串长度1~1000。</div>\n","gpid":"T373","lanqiaotitle":"最长公共子序列","memorylimit":"256.0MB","tid":"ADV-202","timelimit":"1.0s","title":"算法提高 最长公共子序列","src":""},{"checkpoint":"","updatetime":"2016-01-28","content":"<div class='pdcont'>　　最新的火星探测机器人curiosity被困在了一个二维迷宫里，迷宫由一个个方格组成。<br />\n　　共有四种方格：<br />\n　　‘.’  代表空地，curiosity可以穿过它<br />\n　　‘#’ 代表障碍物，不可穿越，不可停留<br />\n　　‘S’ 代表curiosity的起始位置<br />\n　　‘T’  代表curiosity的目的地<br />\n　　NASA将会发送一系列的命令给curiosity，格式如下：“LRUD”分别代表向左，向右，向上，向下走一步。由于地球和火星之间最近时也有55000000km！所以我们必须提前判断这一系列的指令会让curiosity最终处在什么样的状态，请编程完成它。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行是一个整数T，代表有几个测试样例<br />\n　　每个测试样例第一行是一个整数N（1&lt;=N&lt;=50））代表迷宫的大小（N*N）。随后的N行每行由N个字符串组成，代表迷宫。接下来的一行是一个整数Q，代表有多少次询问，接下来的Q行每行是一个仅由“LRUD”四个字母的组成的字符串，字符转长度小于1000.</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每个询问输出单独的一行：<br />\n　　“I get there!”：执行给出的命令后curiosity最终到达了终点。<br />\n　　“<b>I have no idea!</b>”：执行给出的命令后curiosity未能到达终点。<br />\n　　“I am dizzy!”：curiosity在执行命令的过程中撞到了障碍物。<br />\n　　“<b>I am out!</b>”：代表curiosity在执行命令的过程中走出了迷宫的边界。<br />\n<b>Sample Input </b><br />\n　　2<br />\n　　2<br />\n　　S.<br />\n　　#T<br />\n　　2<br />\n　　RD<br />\n　　DR<br />\n　　3<br />\n　　S.#<br />\n　　.#.<br />\n　　.T#<br />\n　　3<br />\n　　RL<br />\n　　DDD<br />\n　　DDRR<br />\n<b>Sample Output</b><br />\n　　I get there!<br />\n　　I am dizzy!<br />\n　　I have no idea!<br />\n　　I am out!<br />\n　　I get there!</div>\n","gpid":"T369","lanqiaotitle":"我们的征途是星辰大海","memorylimit":"256.0MB","tid":"ADV-201","timelimit":"1.0s","title":"算法提高 我们的征途是星辰大海","src":""},{"checkpoint":"贪心","updatetime":"2016-01-28","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有n个点和m个区间，点和区间的端点全部是整数，对于点a和区间[b,c]，若a&gt;=b且a&lt;=c，称点a满足区间[b,c]。<br />\n　　求最小的点的子集，使得所有区间都被满足。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行两个整数n m<br />\n　　以下n行 每行一个整数，代表点的坐标<br />\n　　以下m行 每行两个整数，代表区间的范围</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行，最少的满足所有区间的点数，如无解输出-1。</div><div class='pdsec'>样例输入</div><div class='pddata'>5 5<br />\n2<br />\n6<br />\n3<br />\n8<br />\n7<br />\n2 5<br />\n3 4<br />\n3 3<br />\n2 7<br />\n6 9</div><div class='pdsec'>样例输出</div><div class='pddata'>2</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=n,m&lt;=10000<br />\n　　0&lt;=点和区间的坐标&lt;=50000</div>\n","gpid":"T367","lanqiaotitle":"线段和点","memorylimit":"256.0MB","tid":"ADV-199","timelimit":"1.0s","title":"算法提高 线段和点","src":""},{"checkpoint":"网络警察","updatetime":"2016-01-27","content":"<div class='pdcont'>　　作为一名网络警察，你的任务是监视电子邮件，看其中是否有一些敏感的关键词。不过，有些狡猾的犯罪嫌疑人会改变某些单词的字母顺序，以逃避检查。请编写一个程序，发现这种调整过顺序的关键词。程序的输入有两行，第一行是关键词列表，第二行是待检查的句子。程序的输出为在该句子中所找到的经过顺序调整的关键词。（单词全部为小写，单词之间以一个空格分隔，每一行的单词个数不限）<br />\n<br />\n<b>输入：</b><br />\n　　guns mines missiles<br />\n　　aameric ssell snug dan iimsssle ot sit neeemis<br />\n<b> </b><br />\n<b>输出：</b><br />\n　　guns missiles</div>\n","gpid":"T365","lanqiaotitle":"P1003","memorylimit":"256.0MB","tid":"ADV-198","timelimit":"1.0s","title":"算法提高 P1003","src":""},{"checkpoint":"","updatetime":"2016-01-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　小明的花店新开张，为了吸引顾客，他想在花店的门口摆上一排花，共m盆。通过调查顾客的喜好，小明列出了顾客最喜欢的n种花，从1到n标号。为了在门口展出更多种花，规定第i种花不能超过a<sub>i</sub>盆，摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。<br />\n　　试编程计算，一共有多少种不同的摆花方案。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含两个正整数n和m，中间用一个空格隔开。<br />\n　　第二行有n个整数，每两个整数之间用一个空格隔开，依次表示a<sub>1</sub>、a<sub>2</sub>、……a<sub>n</sub>。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出只有一行，一个整数，表示有多少种方案。<b>注意：因为方案数可能很多，请输出方案数对</b><b>1000007</b><b>取模的结果。</b></div><div class='pdsec'>样例输入</div><div class='pddata'>2 4<br />\n3 2</div><div class='pdsec'>样例输出</div><div class='pddata'>2</div><div class='pdsec'>输入输出样例说明</div><div class='pdcont'>　　有2种摆花的方案，分别是(1，1，1，2)， (1，1，2，2)。括号里的1和2表示两种花，比如第一个方案是前三个位置摆第一种花，第四个位置摆第二种花。</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于20%数据，有 0&lt;n≤8，0&lt;m≤8，0≤a<sub>i</sub>≤8；<br />\n　　对于50%数据，有0&lt;n≤20，0&lt;m≤20，0≤a<sub>i</sub>≤20；<br />\n　　对于100%数据，有0&lt;n≤100，0&lt;m≤100，0≤ a<sub>i</sub>≤100。</div>\n","gpid":"T363","lanqiaotitle":"摆花","memorylimit":"128.0MB","tid":"ADV-196","timelimit":"1.0s","title":"算法提高 摆花","src":"NOIP2012 普及组"},{"checkpoint":"","updatetime":"2016-01-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有一位使者要游历各国，他每到一个国家，都能学到一种文化，但他不愿意学习任何一种文化超过一次（即如果他学习了某种文化，则他就不能到达其他有这种文化的国家）。不同的国家可能有相同的文化。不同文化的国家对其他文化的看法不同，有些文化会排斥外来文化（即如果他学习了某种文化，则他不能到达排斥这种文化的其他国家）。<br />\n　　现给定各个国家间的地理关系，各个国家的文化，每种文化对其他文化的看法，以及这位使者游历的起点和终点（在起点和终点也会学习当地的文化），国家间的道路距离，试求从起点到终点最少需走多少路。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行为五个整数N，K，M，S，T，每两个整数之间用一个空格隔开，依次代表国家个数（国家编号为1到N），文化种数（文化编号为1到K），道路的条数，以及起点和终点的编号（保证S不等于T）；<br />\n　　第二行为N个整数，每两个整数之间用一个空格隔开，其中第i个数C<sub>i</sub>，表示国家i的文化为C<sub>i</sub>。<br />\n　　接下来的K行，每行K个整数，每两个整数之间用一个空格隔开，记第i行的第j个数为a<sub>ij</sub>，a<sub>ij</sub>= 1表示文化i排斥外来文化j（i等于j时表示排斥相同文化的外来人），a<sub>ij</sub>= 0表示不排斥（注意i排斥j并不保证j一定也排斥i）。<br />\n　　接下来的M行，每行三个整数u，v，d，每两个整数之间用一个空格隔开，表示国家u与国家v有一条距离为d的可双向通行的道路（保证u不等于v，两个国家之间可能有多条道路）。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出只有一行，一个整数，表示使者从起点国家到达终点国家最少需要走的距离数（如果无解则输出-1）。</div><div class='pdsec'>样例输入</div><div class='pddata'>2 2 1 1 2<br />\n1 2<br />\n0 1<br />\n1 0<br />\n1 2 10</div><div class='pdsec'>样例输出</div><div class='pddata'>-1</div><div class='pdsec'>输入输出样例说明</div><div class='pdcont'>　　由于到国家2必须要经过国家1，而国家2的文明却排斥国家1的文明，所以不可能到达国家2。</div><div class='pdsec'>样例输入</div><div class='pddata'>2 2 1 1 2<br />\n1 2<br />\n0 1<br />\n0 0<br />\n1 2 10</div><div class='pdsec'>样例输出</div><div class='pddata'>10</div><div class='pdsec'>输入输出样例说明</div><div class='pdcont'>　　路线为1 -&gt; 2。</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于20%的数据，有2≤N≤8，K≤5；<br />\n　　对于30%的数据，有2≤N≤10，K≤5；<br />\n　　对于50%的数据，有2≤N≤20，K≤8；<br />\n　　对于70%的数据，有2≤N≤100，K≤10；<br />\n　　对于100%的数据，有2≤N≤100，1≤K≤100，1≤M≤                                                  N^2，1≤k<sub>i</sub>≤K，1≤u, v≤N，1≤d≤1000，S≠T，1 ≤S, T≤N。</div>\n","gpid":"T362","lanqiaotitle":"文化之旅","memorylimit":"128.0MB","tid":"ADV-195","timelimit":"1.0s","title":"算法提高 文化之旅","src":"NOIP2012 普及组"},{"checkpoint":"贪心","updatetime":"2016-01-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　最近的m天盾神都去幼儿园陪小朋友们玩去了~<br />\n　　每个小朋友都拿到了一些积木，他们各自需要不同数量的积木来拼一些他们想要的东西。但是有的小朋友拿得多，有的小朋友拿得少，有些小朋友需要拿到其他小朋友的积木才能完成他的大作。如果某个小朋友完成了他的作品，那么他就会把自己的作品推倒，而无私地把他的所有积木都奉献出来；但是，如果他还没有完成自己的作品，他是不会把积木让出去的哟~<br />\n　　盾神看到这么和谐的小朋友们感到非常开心，于是想帮助他们所有人都完成他们各自的作品。盾神现在在想，这个理想有没有可能实现呢？于是把这个问题交给了他最信赖的你。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行为一个数m。<br />\n　　接下来有m组数据。每一组的第一行为n，表示这天有n个小朋友。接下来的n行每行两个数，分别表示他现在拥有的积木数和他一共需要的积木数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出m行，如果第i天能顺利完成所有作品，输出YES，否则输出NO。</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n2<br />\n2 2<br />\n1 3<br />\n3<br />\n1 5<br />\n3 3<br />\n0 4</div><div class='pdsec'>样例输出</div><div class='pddata'>YES<br />\nNO</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=n&lt;=10000，1&lt;=m&lt;=10。</div>\n","gpid":"T361","lanqiaotitle":"盾神与积木游戏","memorylimit":"256.0MB","tid":"ADV-194","timelimit":"1.0s","title":"算法提高 盾神与积木游戏","src":"程设第10章出题"},{"checkpoint":"递归 排序","updatetime":"2016-01-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有一天，他在宿舍里无意中发现了一个天平！这个天平很奇怪，有n个完好的砝码，但是没有游码。盾神为他的发现兴奋不已！于是他准备去称一称自己的东西。他准备好了m种物品去称。神奇的是，盾神一早就知道这m种物品的重量，他现在是想看看这个天平能不能称出这些物品出来。但是盾神稍微想了1秒钟以后就觉得这个问题太无聊了，于是就丢给了你。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行为两个数，n和m。<br />\n　　第二行为n个数，表示这n个砝码的重量。<br />\n　　第三行为m个数，表示这m个物品的重量。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出m行，对于第i行，如果第i个物品能被称出，输出YES否则输出NO。</div><div class='pdsec'>样例输入</div><div class='pddata'>4 2<br />\n1 2 4 8<br />\n15 16</div><div class='pdsec'>样例输出</div><div class='pddata'>YES<br />\nNO</div><div class='pdsec'>样例输入</div><div class='pddata'>4 1<br />\n10 7 1 19<br />\n6</div><div class='pdsec'>样例输出</div><div class='pddata'>YES</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=n&lt;=24, 1&lt;=m&lt;=10.</div>\n","gpid":"T359","lanqiaotitle":"盾神与砝码称重","memorylimit":"256.0MB","tid":"ADV-192","timelimit":"1.0s","title":"算法提高 盾神与砝码称重","src":"2字班小教员出题"},{"checkpoint":"链表 文件","updatetime":"2016-01-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　小弱T在闲暇的时候会和室友打扑克，输的人就要负责洗牌。虽然小弱T不怎么会洗牌，但是他却总是输。<br />\n　　渐渐地小弱T发现了一个规律：只要自己洗牌，自己就一定会输。所以小弱T认为自己洗牌不够均匀，就独创了一种小弱洗牌法。<br />\n　　小弱洗牌法是这样做的：先用传统洗牌法将52张扑克牌（1到K各四张，除去大小王）打乱，放成一堆，然后每次从牌堆顶层拿一张牌。如果这张牌的大小是P（1到K的大小分别为1到13），那么就把这张牌插入到当前手中第P张牌的后面。如果当前手中不足P张牌，那么就把这张牌放在最后。<br />\n　　现在给你一对已经被打乱的牌，请你用小弱洗牌法进行洗牌，然后输出最后生成的序列。<br />\n　　注意：小弱可能在第一次洗牌时弄丢了某些牌，这时请你输出一个-1来提醒他牌的数目不够。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　测试数据的输入含N个用空格隔开的字符串表示牌堆从顶至底的每张扑克（1到K中的某个）。可能有多行。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　如果N为52，输出用小弱洗牌法洗牌后的序列，每个字符串用空格隔开。<br />\n　　否则请输出一个-1.</div><div class='pdsec'>样例输入</div><div class='pddata'>4 6 K Q 5 1 Q 9 7 9 K 3 J 1 2 3 5<br />\n2<br />\n3 5 7 Q 7 10 8 4 9 7 8 9 4<br />\n10 6 2 8 2 10 10 Q 5 K J 1<br />\nJ 8 3 K 4 1 6 J 6</div><div class='pdsec'>样例输出</div><div class='pddata'>4 1 1 1 3 4 6 6 2 2 2 5 J 3 8 4 4 6 K J 8 J 10 10 K Q 2 5 7 8 10 9 3 7 9 8 7 1 10 5 6 3 Q K Q 5 Q 7 9 9 J K</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　保证每个字符串都为1 2 3 4 5 6 7 8 9 10 J Q K中的一个。</div>\n","gpid":"T358","lanqiaotitle":"洗牌","memorylimit":"256.0MB","tid":"ADV-191","timelimit":"1.0s","title":"算法提高 洗牌","src":""},{"checkpoint":"","updatetime":"2016-01-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　师座这天在程序设计课上学了指针和结构体以后，觉得自己可以轻松的写出操作系统，为了打败大微软帝国，他给这个系统起了个响亮的名字“操师座系统”，你是师座手下的首席架构师，被要求写这个操作系统的文件系统部分，要求如下：<br />\n　　这个文件系统有的所有文件都有一个独一无二的文件名，除此之外分为两类文件，一类文件是数据存储文件，它可以存储一个字符串信息，另一类文件是快捷方式，它会指向另一个文件，有可能是数据块也有可能是快捷方式。<br />\n　　.<br />\n　　这个文件系统支持3条命令：<br />\n　　1.创建命令：create &lt;FileName&gt; &lt;FileType&gt; &lt;FileInfo&gt;<br />\n　　这个命令的意思是，创建一个文件名为&lt;FileName&gt;，文件类型为&lt;FileType&gt;，文件信息为&lt;FileInfo&gt;，文件类型为0或者1,0表示数据块，1表示快捷方式，如果是数据块，那么&lt;FileInfo&gt;表示储存的字符串，如果这是一个快捷方式，&lt;FileInfo&gt;表示指向的文件的名称，如果当前已存在名为&lt;FileName&gt;的文件，则更新这个文件的信息。<br />\n　　.<br />\n　　2.打开命令：open &lt;FileName&gt;<br />\n　　这个命令是打开文件名为&lt;FileName&gt;的文件，如果这是一个快捷方式，则会打开这个快捷方式指向的文件，直到打开一个数据块时，显示这个数据块储存的信息并换行。<br />\n　　.<br />\n　　3.退出命令：exit<br />\n　　得到这个命令以后，你的程序需要安全终止。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　若干条命令构成，最后一条命令必然为exit。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出每次使用open命令的显示结果。</div><div class='pdsec'>样例输入</div><div class='pddata'>create shizuo 0 lu<br />\ncreate lyf 0 luoyuf<br />\ncreate p1 1 shizuo<br />\nopen p1<br />\ncreate p2 1 p1<br />\nopen p2<br />\ncreate p1 1 lyf<br />\nopen p2<br />\nexit</div><div class='pdsec'>样例输出</div><div class='pddata'>lu<br />\nlu<br />\n<br />\nluoyuf</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　总命令条数不超过1000条。<br />\n　　保证&lt;FileName&gt;，&lt;FileType&gt;，&lt;FileInfo&gt;不包含空格和不合法字符，每个长度不超过20个字符。</div><div class='pdsec'>提示</div><div class='pdcont'>　　尽量让程序高效。<br />\n　　并不需要一开始读入所有的命令，可以读一条命令处理一条命令，就像平时操作命令行一样，可以体现一种在线操作的特点。</div><div class='pdsec'>来源</div><div class='pdcont'>　　by tff,ld</div>\n","gpid":"T354","lanqiaotitle":"师座操作系统","memorylimit":"256.0MB","tid":"ADV-190","timelimit":"1.0s","title":"算法提高 师座操作系统","src":""},{"checkpoint":"循环、排序","updatetime":"2016-01-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　192这个数很厉害，用它分别乘以1、2、3，会得到：<br />\n　　192 x 1 = 192<br />\n　　192 x 2 = 384<br />\n　　192 x 3 = 576<br />\n　　把这三个乘积连起来，得到192384576，正好是一个1~9的全排列<br />\n　　我们把上面的运算定义为连接乘积：<br />\n　　m x (1 ... n) = k（其中m &gt; 0 且 n &gt; 1，对于上例，m = 192、n = 3、k = 192384576）<br />\n　　即k是把m分别乘以1到n的乘积连接起来得到的，则称k为m和n的连接乘积。<br />\n　　按字典序输出所有不同的连接乘积k，满足k是1~9的全排列</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　每个k占一行</div><div class='pdsec'>样例输出</div><div class='pddata'>显然，结果中应包含一行：<br />\n192384576</div>\n","gpid":"T353","lanqiaotitle":"连接乘积","memorylimit":"256.0MB","tid":"ADV-189","timelimit":"1.0s","title":"算法提高 连接乘积","src":"project euler problem 38改编"},{"checkpoint":"循环、枚举","updatetime":"2016-01-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　勾股数是一组三个自然数，a &lt; b &lt; c，以这三个数为三角形的三条边能够形成一个直角三角形<br />\n　　输出所有a + b + c &lt;= 1000的勾股数<br />\n　　a小的先输出；a相同的，b小的先输出。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　每行为一组勾股数，用空格隔开</div><div class='pdsec'>样例输出</div><div class='pddata'>例如，结果的前三行应当是<br />\n3 4 5<br />\n5 12 13<br />\n6 8 10</div>\n","gpid":"T351","lanqiaotitle":"勾股数","memorylimit":"256.0MB","tid":"ADV-187","timelimit":"1.0s","title":"算法提高 勾股数","src":"project euler problem 10改编"},{"checkpoint":"循环、排序","updatetime":"2016-01-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　7254是一个不寻常的数，因为它可以表示为7254 = 39 x 186，这个式子中1~9每个数字正好出现一次<br />\n　　输出所有这样的不同的式子（乘数交换被认为是相同的式子）<br />\n　　结果小的先输出；结果相同的，较小的乘数较小的先输出。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　每一行输出一个式子，式子中的等号前后空格、乘号（用字母x代表）前后空格<br />\n　　较小的乘数写在前面</div><div class='pdsec'>样例输出</div><div class='pddata'>问题中的式子在结果中会出现一行如下：<br />\n7254 = 39 x 186</div>\n","gpid":"T350","lanqiaotitle":"排列式","memorylimit":"256.0MB","tid":"ADV-186","timelimit":"1.0s","title":"算法提高 排列式","src":"project euler problem 32改编"},{"checkpoint":"循环、枚举","updatetime":"2016-01-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　对一个数十进制表示时的每一位数字乘五次方再求和，会得到一个数的五次方数<br />\n　　例如：1024的五次方数为1+0+32+1024=1057<br />\n　　有这样一些神奇的数，它的五次方数就是它自己，而且这样的数竟然只有有限多个<br />\n　　从小到大输出所有这样的数</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　每个数独立一行输出</div><div class='pdsec'>样例输出</div><div class='pddata'>10<br />\n200<br />\n3000</div>\n","gpid":"T349","lanqiaotitle":"五次方数","memorylimit":"256.0MB","tid":"ADV-185","timelimit":"1.0s","title":"算法提高 五次方数","src":"project euler problem 30改编"},{"checkpoint":"循环、筛法","updatetime":"2016-01-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　﻿输入一个自然数n，求小于等于n的素数之和</div><div class='pdsec'>样例输入</div><div class='pddata'>2</div><div class='pdsec'>样例输出</div><div class='pddata'>2</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　测试样例保证 2 &lt;= n &lt;= 2,000,000</div>\n","gpid":"T348","lanqiaotitle":"素数求和","memorylimit":"256.0MB","tid":"ADV-184","timelimit":"1.0s","title":"算法提高 素数求和","src":"project euler problem 10改编"},{"checkpoint":"数组","updatetime":"2016-01-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　小朋友排成一排，老师给他们分苹果。<br />\n　　小朋友从左到右标号1..N。有M个老师，每次第i个老师会给第Li个到第Ri个，一共Ri-Li+1个小朋友每人发Ci个苹果。<br />\n　　最后老师想知道每个小朋友有多少苹果。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行两个整数N、M，表示小朋友个数和老师个数。<br />\n　　接下来M行，每行三个整数Li、Ri、Ci，意义如题目表述。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行N个数，第i个数表示第i个小朋友手上的水果。</div><div class='pdsec'>样例输入</div><div class='pddata'>5 3<br />\n1 2 1<br />\n2 3 2<br />\n2 5 3</div><div class='pdsec'>样例输出</div><div class='pddata'>1 6 5 3 3</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　40%的数据，N、M≤1 000。<br />\n　　100%的数据，N、M≤100 000，1≤Li≤Ri≤N，0≤Ci≤100。</div>\n","gpid":"T345","lanqiaotitle":"分苹果","memorylimit":"256.0MB","tid":"ADV-183","timelimit":"1.0s","title":"算法提高 分苹果","src":""},{"checkpoint":"测试","updatetime":"2016-01-04","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　数据很多，但我们经常只取前几名，比如奥运只取前3名。现在我们有n个数据，请按从大到小的顺序，输出前10个名数据。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　两行。<br />\n　　第一行一个整数n，表示要对多少个数据<br />\n　　第二行有n个整数，中间用空格分隔。表示n个数据。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行，按从大到小排列的前10个数据，每个数据之间用一个空格隔开。</div><div class='pdsec'>样例输入</div><div class='pddata'>26<br />\n54 27 87 16 63 40 40 22 61 6 57 70 0 42 11 50 13 5 56 7 8 86 56 91 68 59</div><div class='pdsec'>样例输出</div><div class='pddata'>91 87 86 70 68 63 61 59 57 56</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　10&lt;=n&lt;=200,各个整数不超出整型范围</div>\n","gpid":"T342","lanqiaotitle":"前10名","memorylimit":"256.0MB","tid":"ADV-182","timelimit":"1.0s","title":"算法提高 前10名","src":""},{"checkpoint":"测试","updatetime":"2016-01-04","content":"<div class='pdcont'>　　将一个正整数N(1&lt;N&lt;32768)分解质因数，把质因数按从小到大的顺序输出。最后输出质因数的个数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一行，一个正整数</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　两行，第一行为用空格分开的质因数<br />\n　　第二行为质因数的个数</div><div class='pdsec'>样例输入</div><div class='pddata'>66</div><div class='pdsec'>样例输出</div><div class='pddata'>2 3 113</div><div class='pdsec'>样例输入</div><div class='pddata'>90</div><div class='pdsec'>样例输出</div><div class='pddata'>2 3 3 5<br />\n4</div><div class='pdsec'>样例输入</div><div class='pddata'>37</div><div class='pdsec'>样例输出</div><div class='pddata'>37<br />\n1</div>\n","gpid":"T341","lanqiaotitle":"质因数2","memorylimit":"256.0MB","tid":"ADV-181","timelimit":"1.0s","title":"算法提高 质因数2","src":""},{"checkpoint":"测试","updatetime":"2015-12-25","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　陶陶家的院子里有一棵苹果树，每到秋天树上就会结出n个苹果。苹果成熟的时候，陶陶就会跑去摘苹果。陶陶有个30厘米高的板凳，当她不能直接用手摘到苹果的时候，就会踩到板凳上再试试。<br />\n　　现在已知n个苹果到地面的高度，以及陶陶把手伸直的时候能够达到的最大高度。假设她碰到苹果，苹果就会掉下来。请帮陶陶算一下,经过她的洗劫后，苹果树上还有几个苹果。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包括两行数据。第一行只包括两个正整数n(5&lt;=n&lt;=200)和m(60&lt;=m&lt;=200),表示苹果数目和桃桃伸手可达到的高度（以厘米为单位）。第二行包含n个100到200之间（包括100和200）的整数（以厘米为单位）分别表示苹果到地面的高度，两个相邻的整数之间用一个空格隔开。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出包括一行，这一行只包含一个整数，表示陶陶不能够摘到的苹果的数目。</div><div class='pdsec'>样例输入</div><div class='pddata'>10 110<br />\n100 200 150 140 129 134 167 198 200 111</div><div class='pdsec'>样例输出</div><div class='pddata'>5<br />\n﻿</div>\n","gpid":"T337","lanqiaotitle":"陶陶摘苹果2","memorylimit":"256.0MB","tid":"ADV-180","timelimit":"1.0s","title":"算法提高 陶陶摘苹果2","src":""},{"checkpoint":"整除","updatetime":"2015-12-18","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个二元一次方程组，形如：<br />\n　　a * x + b * y = c;<br />\n　　d * x + e * y = f;<br />\n　　x,y代表未知数，a, b, c, d, e, f为参数。<br />\n　　求解x,y</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含六个整数: a, b, c, d, e, f;</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出为方程组的解，两个整数x, y。</div><div class='pdsec'>样例输入</div><div class='pddata'>例：<br />\n3 7 41 2 1 9</div><div class='pdsec'>样例输出</div><div class='pddata'>例：<br />\n2 5</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　0 &lt;= a, b, c, d, e, f &lt;= 2147483647</div>\n","gpid":"T333","lanqiaotitle":"解二元一次方程组","memorylimit":"256.0MB","tid":"ADV-179","timelimit":"1.0s","title":"算法提高 解二元一次方程组","src":""},{"checkpoint":"初等数学","updatetime":"2015-12-18","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　银行近期推出了一款新的理财计划“重复计息储蓄”。储户只需在每个月月初存入固定金额的现金，银行就会在每个月月底根据储户账户内的金额算出该月的利息并将利息存入用户账号。现在如果某人每月存入k元，请你帮他计算一下，n月后，他可以获得多少收益。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入数据仅一行，包括两个整数k(100&lt;=k&lt;=10000)、n(1&lt;=n&lt;=48)和一个小数p(0.001&lt;=p&lt;=0.01)，分别表示每月存入的金额、存款时长、存款利息。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出数据仅一个数，表示可以得到的收益。</div><div class='pdsec'>样例输入</div><div class='pddata'>1000 6 0.01</div><div class='pdsec'>样例输出</div><div class='pddata'>213.53</div>\n","gpid":"T331","lanqiaotitle":"理财计划","memorylimit":"256.0MB","tid":"ADV-177","timelimit":"1.0s","title":"算法提高 理财计划","src":""},{"checkpoint":"循环 if判断","updatetime":"2015-12-18","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　陶陶家的院子里有一棵苹果树，每到秋天树上就会结出n个苹果。苹果成熟的时候，陶陶就会跑去摘苹果。陶陶有个30厘米高的板凳，当她不能直接用手摘到苹果的时候，就会踩到板凳上再试试。<br />\n　　现在已知n个苹果到地面的高度，以及陶陶把手伸直的时候能够达到的最大高度，请帮陶陶算一下她能够摘到的苹果的数目。假设她碰到苹果，苹果就会掉下来。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包括两行数据。第一行只包括两个正整数n(5&lt;=n&lt;=200)和m(100&lt;=m&lt;=150),表示苹果数目和桃桃伸手可达到的高度（以厘米为单位）。第二行包含n个100到200之间（包括100和200）的整数（以厘米为单位）分别表示苹果到地面的高度，两个相邻的整数之间用一个空格隔开。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出包括一行，这一行只包含一个整数，表示陶陶能够摘到的苹果的数目。</div><div class='pdsec'>样例输入</div><div class='pddata'>10 110<br />\n<br />\n<br />\n100 200 150 140 129 134 167 198 200 111</div><div class='pdsec'>样例输出</div><div class='pddata'>5<br />\n﻿</div>\n","gpid":"T330","lanqiaotitle":"陶陶摘苹果","memorylimit":"256.0MB","tid":"ADV-176","timelimit":"1.0s","title":"算法提高 陶陶摘苹果","src":""},{"checkpoint":"输入输出语法","updatetime":"2015-12-15","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　按格式格式读入一个3位的整数、一个实数、一个字符 。<br />\n　　并按格式输出 一个整数占8位左对齐、一个实数占8位右对齐、一个字符 ，并用|隔开。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　见题面</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　见题面</div><div class='pdsec'>样例输入</div><div class='pddata'>123456.789|a</div><div class='pdsec'>样例输出</div><div class='pddata'>123     |   456.8|a</div>\n","gpid":"T328","lanqiaotitle":"输入输出格式练习","memorylimit":"256.0MB","tid":"ADV-174","timelimit":"1.0s","title":"算法提高 输入输出格式练习","src":"自编"},{"checkpoint":"字符串 if流","updatetime":"2015-12-15","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　by ZBY... :) 淘淘拿到了一份名单，他想对上面的名字进行处理，挑出一些特殊的名字，他请你来帮忙。<br />\n　　淘淘关注以下名字：<br />\n　　如果这个名字是“WYS”，他希望你的程序输出“KXZSMR”。<br />\n　　如果这个名字是“CQ”，他希望你的程序输出“CHAIQIANG”。<br />\n　　如果这个名字是“LC“，他希望你的程序输出“DRAGONNET”。<br />\n　　如果这个名字是“SYT”或“SSD”或“LSS”或“LYF”，他希望你的程序输出“STUDYFATHER”。<br />\n　　如果这个名字与上述任意名字都不相同，他希望你的程序输出“DENOMINATOR”。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行有一个整数N，表示淘淘手中名单里的人数。<br />\n　　接下来N行，每行有一个字符串，即名单里的人名。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出N行，每行输出每个人名的判断结果。</div><div class='pdsec'>样例输入</div><div class='pddata'>9<br />\nWYS<br />\nCQ<br />\nWYS<br />\nLC<br />\nSYT<br />\nSSD<br />\nLSS<br />\nLYF<br />\nZBY</div><div class='pdsec'>样例输出</div><div class='pddata'>KXZSMR<br />\nCHAIQIANG<br />\nKXZSMR<br />\nDRAGONNET<br />\nSTUDYFATHER<br />\nSTUDYFATHER<br />\nSTUDYFATHER<br />\nSTUDYFATHER<br />\nDENOMINATOR</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于 50% 数据，N &lt;= 1000，且名单中的名字仅可能为“WYS”,“CQ”,“LC”三者之一，没有其他的名字。<br />\n　　对于 100% 数据，N &lt;= 10000，人名仅由大写字母组成，长度不超过5。</div>\n","gpid":"T327","lanqiaotitle":"淘淘的名单","memorylimit":"8.0MB","tid":"ADV-173","timelimit":"100ms","title":"算法提高 淘淘的名单","src":""},{"checkpoint":"排序","updatetime":"2015-12-11","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　安全局搜索到了一批(n个)身份证号码，希望按出生日期对它们进行从大到小排序，如果有相同日期，则按身份证号码大小进行排序。身份证号码为18位的数字组成，出生日期为第7到第14位</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个整数n，表示有n个身份证号码<br />\n　　余下的n行，每行一个身份证号码。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　按出生日期从大到小排序后的身份证号，每行一条</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n466272307503271156<br />\n215856472207097978<br />\n234804580401078365<br />\n404475727700034980<br />\n710351408803093165</div><div class='pdsec'>样例输出</div><div class='pddata'>404475727700034980<br />\n234804580401078365<br />\n215856472207097978<br />\n710351408803093165<br />\n466272307503271156</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=100000</div>\n","gpid":"T326","lanqiaotitle":"身份证排序","memorylimit":"256.0MB","tid":"ADV-172","timelimit":"1.0s","title":"算法提高 身份证排序","src":""},{"checkpoint":"循环 递归","updatetime":"2015-12-11","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　任意一个四位数，只要它们各个位上的数字是不全相同的，就有这样的规律：<br />\n　　1)将组成该四位数的四个数字由大到小排列，形成由这四个数字构成的最大的四位数；<br />\n　　2)将组成该四位数的四个数字由小到大排列，形成由这四个数字构成的最小的四位数(如果四个数中含有0，则得到的数不足四位)；<br />\n　　3)求两个数的差，得到一个新的四位数(高位零保留)。<br />\n　　重复以上过程，最后一定会得到的结果是6174。<br />\n　　比如：4312 3087 8352 6174，经过三次变换，得到6174</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一个四位整数，输入保证四位数字不全相同</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个整数，表示这个数字经过多少次变换能得到6174</div><div class='pdsec'>样例输入</div><div class='pddata'>4312</div><div class='pdsec'>样例输出</div><div class='pddata'>3</div>\n","gpid":"T324","lanqiaotitle":"数字黑洞","memorylimit":"256.0MB","tid":"ADV-170","timelimit":"1.0s","title":"算法提高 数字黑洞","src":""},{"checkpoint":"拓扑排序","updatetime":"2015-12-08","content":"<div class='pdsec'>试题</div><div class='pdcont'>　　有Ｎ个士兵(1≤Ｎ≤26)，编号依次为Ａ,Ｂ,Ｃ,…，队列训练时，指挥官要把一些士兵从高到矮一次排成一行，但现在指挥官不能直接获得每个人的身高信息，只能获得“P1比P2高”这样的比较结果(P1、P2∈Ａ,Ｂ,Ｃ,…,Ｚ,记为 P1&gt;P2)，如”Ａ&gt;Ｂ”表示Ａ比Ｂ高。<br />\n　　请编一程序，根据所得到的比较结果求出一种符合条件的排队方案。<br />\n　　（注：比较结果中没有涉及的士兵不参加排队）</div><div class='pdsec'>输入要求</div><div class='pdcont'>　　比较结果从文本文件中读入（文件由键盘输入），每个比较结果在文本文件中占一行。</div><div class='pdsec'>输出要求</div><div class='pdcont'>　　若输入数据无解，打印“No Answer!”信息，否则从高到矮一次输出每一个士兵的编号，中间无分割符，并把结果写入文本文件中，文件由键盘输入：</div><div class='pdsec'>样例输入</div><div class='pddata'>A&gt;B<br />\nB&gt;D<br />\nF&gt;D</div><div class='pdsec'>样例输出</div><div class='pddata'>AFBD</div>\n","gpid":"T323","lanqiaotitle":"士兵排队问题","memorylimit":"256.0MB","tid":"ADV-169","timelimit":"1.0s","title":"算法提高 士兵排队问题","src":"CTSC1996"},{"checkpoint":"动态规划","updatetime":"2015-12-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有一只特别贪吃的大嘴,她很喜欢吃一种小蛋糕,而每一个小蛋糕有一个美味度,而大嘴是很傲娇的,一定要吃美味度和刚好为m的小蛋糕,而且大嘴还特别懒,她希望通过吃数量最少的小蛋糕达到这个目的.所以她希望你能设计一个程序帮她决定要吃哪些小蛋糕.</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　先输入一行包含2个整数m、n,表示大嘴需要吃美味度和为m的小蛋糕,而小蛋糕一共有n种,下面输入n行,每行2个整数,第一个表示该种小蛋糕的美味度,第二个表示蛋糕店中该种小蛋糕的总数</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行包含一个整数表示大嘴最少需要吃的小蛋糕数量,若大嘴无法通过吃小蛋糕达到m的美味度和,则输出\"&gt;&lt;“.</div><div class='pdsec'>样例输入</div><div class='pddata'>10 2<br />\n4 1<br />\n2 10</div><div class='pdsec'>样例输出</div><div class='pddata'>4</div><div class='pdsec'>样例输入</div><div class='pddata'>10 2<br />\n4 1<br />\n7 3</div><div class='pdsec'>样例输出</div><div class='pddata'>&gt;&lt;</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　m ≤ 20000,小蛋糕总数量≤50.</div>\n","gpid":"T322","lanqiaotitle":"贪吃的大嘴","memorylimit":"256.0MB","tid":"ADV-168","timelimit":"1.0s","title":"算法提高 贪吃的大嘴","src":"北大附中模块考试"},{"checkpoint":"动规 最长不降序列","updatetime":"2015-12-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　如果有人认为吃东西只需要嘴巴，那就错了。<br />\n　　都知道舌头有这么一个特性，“由简入奢易，由奢如简难”（据好事者考究，此规律也适合许多其他情况）。具体而言，如果是甜食，当你吃的食物不如前面刚吃过的东西甜，就很不爽了。<br />\n　　大宝是一个聪明的美食家，当然深谙此道。一次他来到某小吃一条街，准备从街的一头吃到另一头。为了吃得爽，他大费周章，得到了各种食物的“美味度”。他拒绝不爽的经历，不走回头路而且还要爽歪歪（爽的次数尽量多）。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　两行数据。<br />\n　　第一行为一个整数n，表示小吃街上小吃的数量<br />\n　　第二行为n个整数，分别表示n种食物的“美味度”</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个整数，表示吃得爽的次数</div><div class='pdsec'>样例输入</div><div class='pddata'>10<br />\n3 18 7 14 10 12 23 41 16 24</div><div class='pdsec'>样例输出</div><div class='pddata'>6</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　美味度为0到100的整数<br />\n　　n&lt;1000</div>\n","gpid":"T320","lanqiaotitle":"聪明的美食家","memorylimit":"256.0MB","tid":"ADV-166","timelimit":"1.0s","title":"算法提高 聪明的美食家","src":"原创"},{"checkpoint":"回溯 递推 递归","updatetime":"2015-12-02","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　大家都知道\"超级玛丽\"是一个很善于跳跃的探险家，他的拿手好戏是跳跃，但它一次只能向前跳一步或两步。有一次，他要经过一条长为n的羊肠小道，小道中有m个陷阱，这些陷阱都位于整数位置，分别是a<sub>1</sub>,a<sub>2</sub>,....a<sub>m</sub>，陷入其中则必死无疑。显然，如果有两个挨着的陷阱，则玛丽是无论如何也跳过不去的。<br />\n　　现在给出小道的长度n，陷阱的个数及位置。求出玛丽从位置1开始，有多少种跳跃方法能到达胜利的彼岸（到达位置n）。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行为两个整数n,m<br />\n　　第二行为m个整数，表示陷阱的位置</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个整数。表示玛丽跳到n的方案数</div><div class='pdsec'>样例输入</div><div class='pddata'>4 1<br />\n2</div><div class='pdsec'>样例输出</div><div class='pddata'>1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　40&gt;=n&gt;=3,m&gt;=1<br />\n　　n&gt;m;<br />\n　　陷阱不会位于1及n上</div>\n","gpid":"T318","lanqiaotitle":"超级玛丽","memorylimit":"256.0MB","tid":"ADV-165","timelimit":"1.0s","title":"算法提高 超级玛丽","src":""},{"checkpoint":"动态规划","updatetime":"2015-12-01","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　在Mars星球上，每个Mars人都随身佩带着一串能量项链。在项链上有N颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是Mars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为m，尾标记为r，后一颗能量珠的头标记为r，尾标记为n，则聚合后释放的能量为m*r*n（Mars单位），新产生的珠子的头标记为m，尾标记为n。<br />\n　　需要时，Mars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。<br />\n　　例如：设N=4，4颗珠子的头标记与尾标记依次为(2，3) (3，5) (5，10) (10，2)。我们用记号&oplus;表示两颗珠子的聚合操作，(j&oplus;k)表示第j，k两颗珠子聚合后所释放的能量。则第4、1两颗珠子聚合后释放的能量为：<br />\n　　(4&oplus;1)=10*2*3=60。<br />\n　　这一串项链可以得到最优值的一个聚合顺序所释放的总能量为<br />\n　　((4&oplus;1)&oplus;2)&oplus;3）=10*2*3+10*3*5+10*5*10=710。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行是一个正整数N（4≤N≤100），表示项链上珠子的个数。第二行是N个用空格隔开的正整数，所有的数均不超过1000。第i个数为第i颗珠子的头标记（1≤i≤N），当i&lt;N时，第i颗珠子的尾标记应该等于第i+1颗珠子的头标记。第N颗珠子的尾标记应该等于第1颗珠子的头标记。<br />\n　　至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出只有一行，是一个正整数E（E≤2.1*10<sup>9</sup>），为一个最优聚合顺序所释放的总能量。</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\n2 3 5 10</div><div class='pdsec'>样例输出</div><div class='pddata'>710</div>\n","gpid":"T316","lanqiaotitle":"能量项链","memorylimit":"256.0MB","tid":"ADV-163","timelimit":"1.0s","title":"算法提高 能量项链","src":"NOIP 2006 提高组"},{"checkpoint":"","updatetime":"2015-11-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　你获得了一个据说是古代玛雅人制作的箱子。你非常想打开箱子看看里面有什么东西,但是不幸的是,正如所有故事里一样,神秘的箱子出现的时候总是会挂着神秘的锁。<br />\n　　这个锁上面看起来有 <i>N</i> 个数字,它们排成一排,并且每个数字都在 0 到 2 之间。你发现你可以通过锁上的机关来交换<b>相邻</b>两个数字的顺序。比如,如果原来有 5 个数字 02120,在一次交换以后你就可以得到 20120,01220,02210 或者 02102。<br />\n　　根据你所搜集的情报,这个锁在上面存在某连续四个数字是“2012”的时候会自动打开。现在,你需要计算一下,你至少需要进行多少次交换操作才能打开这把锁?</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入数据的第一行有一个正整数 <i>N</i>。(4 ≤ <i>N</i> ≤ 13) 输入数据的第二行有 <i>N</i> 个数字 <i>a</i><sub>1</sub>,<i>a</i><sub>2</sub>, ..., <i>a</i><sub><i>N</i></sub> ,其中 <i>a<sub>i</sub></i> 表示这个锁上面第 i 个数字的值,满足 0 ≤ <i>a<sub>i</sub></i> ≤ 2。这些数字之间没有空格分隔。<br />\n<i><i><i><i> </i></i></i></i></div><div class='pdsec'>输出格式</div><div class='pdcont'>　　你只需要输出一个数字,即你至少需要的交换次数。如果无论如何都没有希望打开这把锁,输出 -1。</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n02120</div><div class='pdsec'>样例输出</div><div class='pddata'>1</div><div class='pdsec'>对样例的解释</div><div class='pdcont'>　　把前两个数字交换以后,锁上的数字是 20120,其中存在连续四个数字2, 0, 1, 2,因此锁会打开。</div>\n","gpid":"T314","lanqiaotitle":"题目 2 密码锁","memorylimit":"1.0GB","tid":"ADV-161","timelimit":"1.0s","title":"算法提高 题目 2 密码锁","src":""},{"checkpoint":"","updatetime":"2015-11-27","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　设 <i>F</i>(<i>N</i>) 表示正整数 1 到正整数 <i>N</i> 中,数字 1,2 总共出现了多少次。例如 <i>N</i> = 10 时:1, 2, 3, 4, 5, 6, 7, 8, 9, 10 这 10 个数中,数字 1 出现了两次,数字 2 出现了 1 次,所以数字 1, 2 总共出现了 3 次,因此 <i>F</i> (10) = 3。<br />\n　　现在给你正整数 <i>N</i> ,请你求出 <i>F</i>(<i>N</i>) 的值。由于 <i>F</i>(<i>N</i>) 可能很大,你仅需输出 <i>F</i>(<i>N</i>) 除以 20123 的余数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入数据仅一行,包含一个正整数 <i>N</i> (1 ≤ <i>N</i> ≤ 10<sup>100</sup> ),表示函数 <i>F</i>(<i>N</i>)的参数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出仅一个整数,为 <i>F</i>(<i>N</i>) 除以 20123 的余数。</div><div class='pdsec'>样例输入</div><div class='pddata'>10</div><div class='pdsec'>样例输出</div><div class='pddata'>3</div>\n","gpid":"T313","lanqiaotitle":"题目 3 函数求值 ","memorylimit":"1.0GB","tid":"ADV-160","timelimit":"1.0s","title":"算法提高 题目 3 函数求值 ","src":""},{"checkpoint":"模拟 高精度","updatetime":"2015-11-26","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　在C/C++语言中，整型所能表示的范围一般为-2<sup>31</sup>到2<sup>31</sup>（大约21亿）,即使long long型，一般也只能表示到-2<sup>63</sup>到2<sup>63</sup>。要想计算更加规模的数，就要用软件来扩展了，比如用数组或字符串来模拟更多规模的数及共运算。<br />\n　　现在输入两个整数，请输出它们的乘积。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　两行，每行一个正整数，每个整数不超过10000位</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行，两个整数的乘积。</div><div class='pdsec'>样例输入</div><div class='pddata'>99<br />\n101</div><div class='pdsec'>样例输出</div><div class='pddata'>9999</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　每个整数不超过10000位</div>\n","gpid":"T311","lanqiaotitle":"高精度乘法","memorylimit":"256.0MB","tid":"ADV-159","timelimit":"1.0s","title":"算法提高 高精度乘法","src":""},{"checkpoint":"","updatetime":"2015-11-23","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　现代诗如蚯蚓<br />\n　　断成好几截都不会死<br />\n　　字符串断成好几截<br />\n　　有可能完全一样<br />\n　　请编写程序<br />\n　　输入字符串<br />\n　　输出该字符串最多能断成多少截完全一样的子串</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一行，一个字符串</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行，一个正整数表示该字符串最多能断成的截数</div><div class='pdsec'>样例输入</div><div class='pddata'>abcabcabcabc</div><div class='pdsec'>样例输出</div><div class='pddata'>4</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　最多能断成四个”abc”，也就是abc重复四遍便是原串<br />\n　　同时也能断成两个”abcabc”<br />\n　　最坏情况是断成一个原串”abcabcabcabc”</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　字符串长度&lt;=1000</div>\n","gpid":"T308","lanqiaotitle":"现代诗如蚯蚓","memorylimit":"256.0MB","tid":"ADV-157","timelimit":"1.0s","title":"算法提高 现代诗如蚯蚓","src":""},{"checkpoint":"","updatetime":"2015-11-23","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　以前有个孩子，他分分钟都在碎碎念。不过，他的念头之间是有因果关系的。他会在本子里记录每一个念头，并用箭头画出这个念头的来源于之前的哪一个念头。翻开这个本子，你一定会被互相穿梭的箭头给搅晕，现在他希望你用程序计算出这些念头中最长的一条因果链。<br />\n　　将念头从1到n编号，念头i来源于念头from[i]，保证from[i]&lt;i，from[i]=0表示该念头没有来源念头，只是脑袋一抽，灵光一现。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个正整数n表示念头的数量<br />\n　　接下来n行依次给出from[1]，from[2]，…，from[n]</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　共一行，一个正整数L表示最长的念头因果链中的念头数量</div><div class='pdsec'>样例输入</div><div class='pddata'>8<br />\n0<br />\n1<br />\n0<br />\n3<br />\n2<br />\n4<br />\n2<br />\n4</div><div class='pdsec'>样例输出</div><div class='pddata'>3</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　最长的因果链有：<br />\n　　1-&gt;2-&gt;5 (from[5]=2,from[2]=1,from[1]=0)<br />\n　　1-&gt;2-&gt;7 (from[7]=2,from[2]=1,from[1]=0)<br />\n　　3-&gt;4-&gt;6 (from[6]=4,from[4]=3,from[3]=0)<br />\n　　3-&gt;4-&gt;8 (from[8]=4,from[4]=3,from[3]=0)</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=n&lt;=1000</div>\n","gpid":"T307","lanqiaotitle":"分分钟的碎碎念","memorylimit":"256.0MB","tid":"ADV-156","timelimit":"1.0s","title":"算法提高 分分钟的碎碎念","src":""},{"checkpoint":"","updatetime":"2015-11-20","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　在上一季里，曾提到过质数的孤独，其实从另一个角度看，无情隔膜它们的合数全是质数的后代，因为合数可以由质数相乘结合而得。<br />\n　　如果一个合数由两个质数相乘而得，那么我们就叫它是质数们的直接后代。现在，给你一系列自然数，判断它们是否是质数的直接后代。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个正整数T，表示需要判断的自然数数量<br />\n　　接下来T行，每行一个要判断的自然数</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　共T行，依次对于输入中给出的自然数，判断是否为质数的直接后代，是则输出Yes，否则输出No</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\n3<br />\n4<br />\n6<br />\n12</div><div class='pdsec'>样例输出</div><div class='pddata'>No<br />\nYes<br />\nYes<br />\nNo</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=T&lt;=20<br />\n　　2&lt;=要判断的自然数&lt;=10<sup>5</sup></div>\n","gpid":"T305","lanqiaotitle":"质数的后代","memorylimit":"256.0MB","tid":"ADV-154","timelimit":"1.0s","title":"算法提高 质数的后代","src":""},{"checkpoint":"递归 动规","updatetime":"2015-11-20","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　一个正整数可以划分为多个正整数的和，比如n=3时：<br />\n　　3；1＋2；1＋1＋1；<br />\n　　共有三种划分方法。<br />\n　　给出一个正整数，问有多少种划分方法。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一个正整数n</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个正整数，表示划分方案数</div><div class='pdsec'>样例输入</div><div class='pddata'>3</div><div class='pdsec'>样例输出</div><div class='pddata'>3</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=100</div>\n","gpid":"T304","lanqiaotitle":"数的划分","memorylimit":"256.0MB","tid":"ADV-153","timelimit":"1.0s","title":"算法提高 数的划分","src":""},{"checkpoint":"b2002_3 简单图论 搜索","updatetime":"2015-11-19","content":"<div class='pdcont'>　　<b>问题描述<br />\n</b><br />\n　　给出一个整数 n（n&lt;10^30) 和 k 个变换规则（k&lt;=15）。<br />\n<br />\n　　规则：<br />\n<br />\n　　一位数可变换成另一个一位数：<br />\n<br />\n　　规则的右部不能为零。<br />\n<br />\n　　例如：n=234。有规则（k＝2）：<br />\n<br />\n　　2－&gt; 5<br />\n<br />\n　　3－&gt; 6<br />\n<br />\n　　上面的整数 234 经过变换后可能产生出的整数为（包括原数）:<br />\n<br />\n　　234<br />\n<br />\n　　534<br />\n<br />\n　　264<br />\n<br />\n　　564<br />\n<br />\n　　共 4 种不同的产生数<br />\n<br />\n　　问题：<br />\n<br />\n　　给出一个整数 n 和 k 个规则。<br />\n<br />\n　　求出：<br />\n<br />\n　　经过任意次的变换（0次或多次），能产生出多少个不同整数。<br />\n<br />\n　　仅要求输出个数。<br />\n　　<b>输入格式</b>:<br />\n　　n k<br />\n　　x1 y1<br />\n　　x2 y2<br />\n　　... ...<br />\n　　xn yn<br />\n　　<b>输出格式</b>:<br />\n　　一个整数（满足条件的个数）：</div><div class='pdsec'>样例输入</div><div class='pddata'>234 2<br />\n2 5<br />\n3 6</div><div class='pdsec'>样例输出</div><div class='pddata'>4</div>\n","gpid":"T301","lanqiaotitle":"产生数","memorylimit":"256.0MB","tid":"ADV-152","timelimit":"1.0s","title":"算法提高 产生数","src":""},{"checkpoint":"递归 构造 usaco1.5.3","updatetime":"2015-11-10","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　农民约翰母牛总是产生最好的肋骨。你能通过农民约翰和美国农业部标记在每根肋骨上的数字认出它们。农民约翰确定他卖给买方的是真正的质数肋骨，是因为从右边开始切下肋骨，每次还剩下的肋骨上的数字都组成一个质数。<br />\n<br />\n　　例如有四根肋骨的数字分别是：7 3 3 1，那么全部肋骨上的数字 7331是质数；三根肋骨 733是质数；二根肋骨 73 是质数；当然,最后一根肋骨 7 也是质数。7331 被叫做长度 4 的特殊质数。<br />\n<br />\n　　写一个程序对给定的肋骨的数目 N (1&lt;=N&lt;=8),求出所有的特殊质数。数字1不被看作一个质数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　单独的一行包含N。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　按顺序输出长度为 N 的特殊质数,每行一个。</div><div class='pdsec'>样例输入</div><div class='pddata'>4</div><div class='pdsec'>样例输出</div><div class='pddata'>2333<br />\n2339<br />\n2393<br />\n2399<br />\n2939<br />\n3119<br />\n3137<br />\n3733<br />\n3739<br />\n3793<br />\n3797<br />\n5939<br />\n7193<br />\n7331<br />\n7333<br />\n7393</div>\n","gpid":"T293","lanqiaotitle":"特殊的质数肋骨","memorylimit":"256.0MB","tid":"ADV-149","timelimit":"1.0s","title":"算法提高 特殊的质数肋骨","src":""},{"checkpoint":"贪心","updatetime":"2015-11-10","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有n个人排队到r个水龙头去打水，他们装满水桶的时间t1、t2………..tn为整数且各不相等，应如何安排他们的打水顺序才能使他们总共花费的时间最少？</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行n，r (n&lt;=500,r&lt;=75)<br />\n　　第二行为n个人打水所用的时间Ti (Ti&lt;=100)；</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　最少的花费时间</div><div class='pdsec'>样例输入</div><div class='pddata'>3 2<br />\n1 2 3</div><div class='pdsec'>样例输出</div><pre class='pddata'>\n<pre>\n7\n</pre>\n<div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　其中80%的数据保证n&lt;=10</div>\n","gpid":"T292","lanqiaotitle":"排队打水问题","memorylimit":"256.0MB","tid":"ADV-148","timelimit":"1.0s","title":"算法提高 排队打水问题","src":""},{"checkpoint":"二维数组","updatetime":"2015-11-06","content":"<div class='pdcont'><b>【问题描述】</b><br />\n　　王小二的计算器上面的LED显示屏坏掉了，于是他找到了在计算器维修与应用系学习的你来为他修计算器。<br />\n　　屏幕上可以显示0~9的数字，其中每个数字由7个小二极管组成，各个数字对应的表示方式如图所示：<br />\n<img width=\"426\" height=\"77\" src=\"/RequireFile.do?fid=aYT2ERHR\" /><br />\n　　。<br />\n<br />\n　　为了排除电路故障，现在你需要计算，将数字A变为数字B需要经过多少次变换？<br />\n　　注意：现在将其中每段小二极管的开和关都定义为一次变换。例如数字1变为2是5次操作。<br />\n<br />\n<b>【输入格式】</b><br />\n　　第一行为一个正整数L，表示数码的长度。<br />\n　　接下来两行是两个长度为L的数字A和B，表示要把数字A变成数字B（数字可以以0开头）。<br />\n<b>【输出格式】</b><br />\n　　一行一个整数，表示这些小二极管一共要变换多少次。<br />\n<b>【样例输入1】</b><br />\n<br />\n　　3<br />\n　　101<br />\n　　025<br />\n<b>【样例输出1】</b><br />\n　　12<br />\n<b> 【样例输入2】</b><b><br />\n</b><br />\n　　8<br />\n　　19920513<br />\n　　20111211<br />\n<b>【样例输出2</b><b>】</b><br />\n　　27<br />\n<br />\n<b>【数据范围】</b><br />\n　　L&lt;=100</div>\n","gpid":"T289","lanqiaotitle":"计算器","memorylimit":"256.0MB","tid":"ADV-146","timelimit":"1.0s","title":"算法提高 计算器","src":""},{"checkpoint":"noip2011","updatetime":"2015-11-04","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　为了准备一个学生节，组织者在会场的一片矩形区域（可看做是平面直角坐标<br />\n　　系的第一象限）铺上一些矩形地毯。一共有n 张地毯，编号从1 到n。现在将这些地毯按照<br />\n　　编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。<br />\n　　地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形<br />\n　　地毯边界和四个顶点上的点也算被地毯覆盖。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入共 n+2 行。<br />\n　　第一行，一个整数 n，表示总共有n 张地毯。<br />\n　　接下来的 n 行中，第i+1 行表示编号i 的地毯的信息，包含四个正整数a，b，g，k，每<br />\n　　两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标（a，b）以及地毯在x<br />\n　　轴和y 轴方向的长度。<br />\n　　第 n+2 行包含两个正整数x 和y，表示所求的地面的点的坐标（x，y）。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出共 1 行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出-1。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n1 0 2 3<br />\n0 2 3 3<br />\n2 1 3 3<br />\n2 2</div><div class='pdsec'>样例输出</div><div class='pddata'>3</div><div class='pdsec'>样例输入</div><div class='pddata'>3</div><div class='pdsec'>样例输出</div><div class='pddata'>-1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于 30%的数据，有n≤2；<br />\n　　对于 50%的数据，0≤a, b, g, k≤100；<br />\n　　对于 100%的数据，有0≤n≤10,000，0≤a, b, g, k≤100,000。<br />\n<br />\n<br />\n<br />\n　　1 0 2 3<br />\n　　0 2 3 3<br />\n　　2 1 3 3<br />\n　　4 5</div>\n","gpid":"T288","lanqiaotitle":"铺地毯","memorylimit":"256.0MB","tid":"ADV-145","timelimit":"1.0s","title":"算法提高 铺地毯","src":""},{"checkpoint":"递归搜索","updatetime":"2015-10-30","content":"<div class='pdcont'>　　﻿<br />\n　　棋盘多项式</div><div class='pdsec'>问题描述</div><div class='pdcont'>　　八皇后问题是在棋盘上放皇后，互相不攻击，求方案。变换一下棋子，还可以有八车问题，八马问题，八兵问题，八王问题，注意别念反。在这道题里，棋子换成车，同时棋盘也得换，确切说，是进行一些改造。比如现在有一张n*n的棋盘，我们在一些格子上抠几个洞，这些洞自然不能放棋子了，会漏下去的。另外，一个车本来能攻击和它的同行同列。现在，你想想，在攻击的过程中如果踩到一个洞，便会自取灭亡。故，车的攻击范围止于洞。<br />\n　　此题，给你棋盘的规模n，以及挖洞情况，求放k个车的方案数(k从0到最多可放车数)</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个整数n表示棋盘大小<br />\n　　接下来n行，每行n个用空格隔开的数字0或1，0的形状表示洞，1表示没有洞</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　若干行，第i行表示放i个车的方案数</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n1 0 1<br />\n1 1 1<br />\n1 0 1</div><div class='pdsec'>样例输出</div><div class='pddata'>7<br />\n12<br />\n4</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=8</div>\n","gpid":"T285","lanqiaotitle":"棋盘多项式","memorylimit":"256.0MB","tid":"ADV-142","timelimit":"1.0s","title":"算法提高 棋盘多项式","src":""},{"checkpoint":"枚举 逻辑","updatetime":"2015-10-29","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有9盏灯与9个开关，编号都是1~9。<br />\n<br />\n　　每个开关能控制若干盏灯，按下一次会改变其控制的灯的状态(亮的变成不亮，不亮变成亮的)。<br />\n<br />\n　　具体如下：<br />\n<br />\n　　第一个开关控制第二，第四盏灯；<br />\n<br />\n　　第二个开关控制第一，第三，第五盏灯；<br />\n<br />\n　　第三个开关控制第二，第六盏灯；<br />\n<br />\n　　第四个开关控制第一，第五，第七盏灯；<br />\n<br />\n　　第五个开关控制第二，第四，第六，第八盏灯；<br />\n<br />\n　　第六个开关控制第三，第五，第九盏灯；<br />\n<br />\n　　第七个开关控制第四，第八盏灯；<br />\n<br />\n　　第八个开关控制第五，第七，第九盏灯；<br />\n<br />\n　　第九个开关控制第六，第八盏灯。<br />\n<br />\n　　开始时所有灯都是熄灭的，开关是关闭着的。要求按下若干开关后，使得只有4盏灯亮着。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出所有可能的方案，每行一个方案，每一行有9个字符，从左往右第i个字符表示第i个开关的状态(\"0\"表示关闭，\"1\"表示打开)，按字典序输出。下面的样例输出只是部分方案。</div><div class='pdsec'>样例输出</div><div class='pddata'>000001011<br />\n000001110<br />\n000001111</div>\n","gpid":"T283","lanqiaotitle":"开灯游戏","memorylimit":"256.0MB","tid":"ADV-140","timelimit":"1.0s","title":"算法提高 开灯游戏","src":""},{"checkpoint":"递归","updatetime":"2015-04-09","content":"<div class='pdcont'>　　种树</div><div class='pdsec'>问题描述</div><div class='pdcont'>　　A城市有一个巨大的圆形广场，为了绿化环境和净化空气，市政府决定沿圆形广场外圈种一圈树。园林部门 得到指令后，初步规划出n个种树的位置，顺时针编号1到n。并且每个位置都有一个美观度Ai，如果在这里种树就可以得到这Ai的美观度。但由于A城市土壤 肥力欠佳，两棵树决不能种在相邻的位置（i号位置和i+1号位置叫相邻位置。值得注意的是1号和n号也算相邻位置！）。<br />\n　　最终市政府给园林部门提供了m棵树苗并要求全部种上，请你帮忙设计种树方案使得美观度总和最大。如果无法将m棵树苗全部种上，给出无解信息。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含两个正整数n、m。<br />\n　　第二行n个整数Ai。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个整数，表示最佳植树方案可以得到的美观度。如果无解输出“Error!”，不包含引号。</div><div class='pdsec'>样例输入</div><div class='pddata'>7 3<br />\n1 2 3 4 5 6 7</div><div class='pdsec'>样例输出</div><div class='pddata'>15</div><div class='pdsec'>样例输入</div><div class='pddata'>7 4<br />\n1 2 3 4 5 6 7</div><div class='pdsec'>样例输出</div><div class='pddata'>Error!</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于全部数据，满足1&lt;=m&lt;=n&lt;=30；<br />\n　　其中90%的数据满足m&lt;=n&lt;=20<br />\n　　-1000&lt;=Ai&lt;=1000</div>\n","gpid":"T282","lanqiaotitle":"种树","memorylimit":"256.0MB","tid":"ADV-139","timelimit":"1.0s","title":"算法提高 种树","src":""},{"checkpoint":"排序","updatetime":"2015-04-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　达达在陶陶的影响下，也对学习慢慢的产生了兴趣。<br />\n　　他在每次考试之后，都会追着老师问，自己在班级的总名次是多少。考试一多，老师也不耐烦了，于是他给了达达所有人的成绩，让他自己去算出自己的排名。<br />\n　　可人太多了，达达也无法立即算出来，于是他想让你帮帮他。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行为一个整数N，代表班级的学生总数。<br />\n　　接下来N行，每行一个字符串，代表一个学生的姓名，第一行总是DaDa。<br />\n　　接下来一行一个整数M，代表一共有M次考试。<br />\n　　每次考试有N行，每行有以一个空格分隔的一个正整数S和一个字符串P，代表名字为P的学生在这次考试中得了S分。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一共M行，每行一个整数，代表达达在班级里的排名，排名是这一次考试过后的所有考试总分排名，如果达达和别人并列，达达总是排在前面。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<pre class='pddata'>\n<span lang=\"EN-US\" style=\"font-family:\"Courier New\"\">DaDa<o:p></o:p></span>\n</pre>\n<pre class='pddata'>\n<span lang=\"EN-US\" style=\"font-family:\"Courier New\"\">A<o:p></o:p></span>\n</pre>\n<pre class='pddata'>\n<span lang=\"EN-US\" style=\"font-family:\"Courier New\"\">B<o:p></o:p></span>\n</pre>\n<pre class='pddata'>\n<span lang=\"EN-US\" style=\"font-family:\"Courier New\"\">2<o:p></o:p></span>\n</pre>\n<pre class='pddata'>\n<span lang=\"EN-US\" style=\"font-family:\"Courier New\"\">49 DaDa<o:p></o:p></span>\n</pre>\n<pre class='pddata'>\n<st1:chmetcnv tcsc=\"0\" numbertype=\"1\" negative=\"False\" hasspace=\"True\" sourcevalue=\"49\" unitname=\"a\" w:st=\"on\"><span lang=\"EN-US\" style=\"font-family:\"Courier New\"\">49 A</span></st1:chmetcnv><span lang=\"EN-US\" style=\"font-family:\"Courier New\"\"><o:p></o:p></span>\n</pre>\n<pre class='pddata'>\n<span lang=\"EN-US\" style=\"font-family:\"Courier New\"\">48 B<o:p></o:p></span>\n</pre>\n<pre class='pddata'>\n<st1:chmetcnv tcsc=\"0\" numbertype=\"1\" negative=\"False\" hasspace=\"True\" sourcevalue=\"80\" unitname=\"a\" w:st=\"on\"><span lang=\"EN-US\" style=\"font-family:\"Courier New\"\">80 A</span></st1:chmetcnv><span lang=\"EN-US\" style=\"font-family:\"Courier New\"\"><o:p></o:p></span>\n</pre>\n<pre class='pddata'>\n<span lang=\"EN-US\" style=\"font-family:\"Courier New\"\">85 B<o:p></o:p></span>\n</pre>\n<br />\n83 DaDa<pre class='pddata'>\n<span class=\"Apple-style-span\" style=\"font-family: 'Courier New'; \"> </span><span class=\"Apple-style-span\" style=\"font-family: 'Courier New'; \"><br type=\"_moz\" /></span>【样例输出】\n1\n2\n</pre>\n</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　N &lt;= 100，名字长度不超过30，分数不超过100</div>\n","gpid":"T280","lanqiaotitle":"班级排名","memorylimit":"256.0MB","tid":"ADV-138","timelimit":"1.0s","title":"算法提高 班级排名","src":""},{"checkpoint":"递归 搜索","updatetime":"2015-04-01","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　3000米长跑时，围观党们兴高采烈地预测着最后的排名。因为他们来自不同的班，对所有运动员不一定都了解，于是他们分别对自己了解的一些运动员的实力作出了评估，即对部分运动员做了相对排名的预测，并且告诉了可怜留守的班长。因为无聊，于是他们就组团去打Dota去了。比赛结束后他们向班长询问最后的排名，但班长不记得了，只记得他们中哪些人的预测是正确的，哪些人的预测是错误的。他们想知道比赛的排名可能是什么。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行两个整数n， m，n为运动员数量，m为围观党数量。运动员编号从0到n-1。<br />\n　　接下来m行，每行为一个围观党的相对排名预测。每行第一个数c表示他预测的人数，后面跟着c个0~n-1的不同的数，表示他预测的运动员相对排名，最后还有一个数，0表示这个预测是错误的，1表示是正确的。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第一行一个数k为有多少种排名的可能。<br />\n　　下面k行，每行一个0~n-1的排列，为某一个可能的排名，相邻的数间用空格隔开。所有排名按字典序依次输出。</div><div class='pdsec'>样例输入</div><div class='pddata'>Input Sample 1:<br />\n3 2<br />\n2 0 1 1<br />\n2 1 2 0<br />\n<br />\nInput Sample 2:<br />\n3 2<br />\n2 0 1 1<br />\n2 2 1 0</div><div class='pdsec'>样例输出</div><div class='pddata'>Output Sample 1:<br />\n2<br />\n0 2 1<br />\n2 0 1<br />\n<br />\nOutput Sample 2:<br />\n1<br />\n0 1 2</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=n&lt;=10, 2&lt;=c&lt;=n, 1&lt;=m&lt;=10，保证数据合法，且答案中排名可能数不超过20000。对于一个排名序列，一个预测是正确的，当且仅当预测的排名的相对顺序是排名序列的一个子序列。一个预测是错误的，当且仅当这个预测不正确。</div>\n","gpid":"T279","lanqiaotitle":"3000米排名预测","memorylimit":"256.0MB","tid":"ADV-137","timelimit":"1.0s","title":"算法提高 3000米排名预测","src":""},{"checkpoint":"高精度加法","updatetime":"2015-03-25","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输入两个正整数a,b，输出a+b的值。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　两行，第一行a，第二行b。a和b的长度均小于1000位。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行，a+b的值。</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\n2</div><div class='pdsec'>样例输出</div><div class='pddata'>6</div>\n","gpid":"T277","lanqiaotitle":"大数加法","memorylimit":"256.0MB","tid":"ADV-136","timelimit":"1.0s","title":"算法提高 大数加法","src":""},{"checkpoint":"a基础 顺序","updatetime":"2015-03-20","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　由三角形的三边长，求其面积。<br />\n　　提示：由三角形的三边a,b,c求面积可以用如下的公式：<br />\n　　s=（a+b+c）/2<br />\n　　面积=<img src=\"/RequireFile.do?fid=yLLF7Qyy\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　由空格分开的三个整数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个实数，保留两位小数。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 4 5</div><div class='pdsec'>样例输出</div><div class='pddata'>6.00</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　输入的三条边一定能构成三角形，不用进行判定。a,b,c小于1000</div>\n","gpid":"T275","lanqiaotitle":"三角形面积","memorylimit":"256.0MB","tid":"ADV-135","timelimit":"1.0s","title":"算法提高 三角形面积","src":""},{"checkpoint":"数组","updatetime":"2015-03-18","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　某校大门外长度为L的马路上有一排树，每两棵相邻的树之间的间隔都是1米。我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；数轴上的每个整数点，即0，1，2，……，L，都种有一棵树。<br />\n　　由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行有两个整数L（1 &lt;= L &lt;= 10000）和 M（1 &lt;= M &lt;= 100），L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。接下来的M行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出包括一行，这一行只包含一个整数，表示马路上剩余的树的数目。</div><div class='pdsec'>样例输入</div><div class='pddata'>500 3<br />\n150 300<br />\n100 200<br />\n470 471</div><div class='pdsec'>样例输出</div><div class='pddata'>298</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于20%的数据，区域之间没有重合的部分；<br />\n　　对于其它的数据，区域之间有重合的情况。</div><div class='pdsec'>问题描述</div><div class='pdcont'>　　某校大门外长度为L的马路上有一排树，每两棵相邻的树之间的间隔都是1米。我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；数轴上的每个整数点，即0，1，2，……，L，都种有一棵树。<br />\n　　由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入文件的第一行有两个整数L（1 &lt;= L &lt;= 10000）和 M（1 &lt;= M &lt;= 100），L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。接下来的M行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出文件包括一行，这一行只包含一个整数，表示马路上剩余的树的数目。</div><div class='pdsec'>样例输入</div><div class='pddata'>500 3<br />\n150 300<br />\n100 200<br />\n470 471</div><div class='pdsec'>样例输出</div><div class='pddata'>298</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于20%的数据，区域之间没有重合的部分；<br />\n　　对于其它的数据，区域之间有重合的情况。</div><div class='pdsec'>试题来源</div><div class='pdcont'>　　noip2005普及组</div>\n","gpid":"T274","lanqiaotitle":"校门外的树","memorylimit":"256.0MB","tid":"ADV-134","timelimit":"1.0s","title":"算法提高 校门外的树","src":""},{"checkpoint":"一维数组","updatetime":"2015-03-16","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　为丰富男生节活动，贵系女生设置彩票抽奖环节，规则如下：<br />\n　　1、每张彩票上印有7个各不相同的号码，且这些号码的取值范围为[1, 33]；<br />\n　　2、每次在兑奖前都会公布一个由七个互不相同的号码构成的中奖号码；<br />\n　　3、共设置7个奖项，特等奖和一等奖至六等奖。兑奖规则如下：<br />\n　　特等奖：要求彩票上的7个号码都出现在中奖号码中；<br />\n　　一等奖：要求彩票上的6个号码出现在中奖号码中；<br />\n　　二等奖：要求彩票上的5个号码出现在中奖号码中；<br />\n　　……<br />\n　　六等奖：要求彩票上的1个号码出现在中奖号码中；<br />\n　　注：不考虑号码出现的顺序，例如若中奖号码为23 31 1 14 19 17 18，则彩票12 8 9 23 1 16 7由于其中有两个号码（23和1）出现在中奖号码中，所以该彩票中了五等奖。<br />\n　　现已知中奖号码和李华买的若干彩票的号码，请你写一个程序判断他的彩票中奖情况。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个正整数n，表示彩票数量，第二行7个整数，表示中奖号码，下面n行每行7个整数，描述n张彩票。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　7个空格隔开的数字，第1个数字表示特等奖的中奖张数，第2个数字表示一等奖的中奖张数，第3个数字表示二等奖的中奖张数……第7个数字表示六等奖的中奖张数。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n1 2 3 4 5 6 7<br />\n11 12 13 14 15 16 17<br />\n12 13 14 15 16 17 18<br />\n8 7 10 9 31 30 29</div><div class='pdsec'>样例输出</div><div class='pddata'>0 0 0 0 0 0 1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　30%的数据n&lt;=100；<br />\n　　70%的数据n&lt;=1000；<br />\n　　100%的数据n&lt;=100000。<br />\n<br />\n　　*****提示：数组定义为全局变量，可以分配更多内存。*****</div>\n","gpid":"T273","lanqiaotitle":"彩票","memorylimit":"256.0MB","tid":"ADV-133","timelimit":"1.0s","title":"算法提高 彩票","src":""},{"checkpoint":"NOIP2008提高组","updatetime":"2015-03-13","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　笨小猴的词汇量很小，所以每次做英语选择题的时候都很头疼。但是他找到了一种方法，经试验证明，用这种方法去选择选项的时候选对的几率非常大！<br />\n　　这种方法的具体描述如下：假设maxn是单词中出现次数最多的字母的出现次数，minn是单词中出现次数最少的字母的出现次数，如果maxn-minn是一个质数，那么笨小猴就认为这是个Lucky Word，这样的单词很可能就是正确的答案。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入文件只有一行，是一个单词，其中只可能出现小写字母，并且长度小于100。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出文件共两行，第一行是一个字符串，假设输入的的单词是Lucky Word，那么输出“Lucky Word”，否则输出“No Answer”；第二行是一个整数，如果输入单词是Lucky Word，输出maxn-minn的值，否则输出0。</div><div class='pdsec'>样例输入</div><div class='pddata'>error</div><div class='pdsec'>样例输出</div><div class='pddata'>Lucky Word<br />\n2</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　单词error中出现最多的字母r出现了3次，出现次数最少的字母出现了1次，3-1=2，2是质数。</div><div class='pdsec'>样例输入</div><div class='pddata'>olympic</div><div class='pdsec'>样例输出</div><div class='pddata'>No Answer<br />\n0</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　单词olympic中所有字母都只出现了1次，1-1=0，0不是质数。</div>\n","gpid":"T272","lanqiaotitle":"笨小猴","memorylimit":"256.0MB","tid":"ADV-132","timelimit":"1.0s","title":"算法提高 笨小猴","src":""},{"checkpoint":"","updatetime":"2015-03-09","content":"<div class='pdcont'>　　﻿<br />\n　　选择排序</div><div class='pdsec'>问题描述</div><div class='pdcont'>　　排序，顾名思义，是将若干个元素按其大小关系排出一个顺序。形式化描述如下：有n个元素a[1]，a[2]，…，a[n]，从小到大排序就是将它们排成一个新顺序a[i[1]]&lt;a[i[2]]&lt;…&lt;a[i[n]]<br />\n　　i[k]为这个新顺序。<br />\n　　选择排序的思想极其简单，每一步都把一个最小元素放到前面，如果有多个相等的最小元素，选择排位较考前的放到当前头部。还是那个例子：{3 1 5 4 2}：<br />\n　　第一步将1放到开头（第一个位置），也就是交换3和1，即swap(a[0],a[1])得到{1 3 5 4 2}<br />\n　　第二步将2放到第二个位置，也就是交换3和2，即swap(a[1],a[4])得到{1 2 5 4 3}<br />\n　　第三步将3放到第三个位置，也就是交换5和3，即swap(a[2],a[4])得到{1 2 3 4 5}<br />\n　　第四步将4放到第四个位置，也就是交换4和4，即swap(a[3],a[3])得到{1 2 3 4 5}<br />\n　　第五步将5放到第五个位置，也就是交换5和5，即swap(a[4],a[4])得到{1 2 3 4 5}<br />\n　　输入n个整数，输出选择排序的全过程。<br />\n　　要求使用递归实现。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个正整数n，表示元素个数<br />\n　　第二行为n个整数，以空格隔开</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　共n行，每行输出第n步选择时交换哪两个位置的下标，以及交换得到的序列，格式:<br />\n　　swap(a[i],a[j]):a[0] … a[n-1]<br />\n　　i和j为所交换元素的下标，下标从0开始，最初元素顺序按输入顺序。另外请保证i&lt;=j<br />\n　　a[0]…a[n-1]为交换后的序列，元素间以一个空格隔开</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n4 3 1 1 2</div><div class='pdsec'>样例输出</div><div class='pddata'>swap(a[0], a[2]):1 3 4 1 2<br />\nswap(a[1], a[3]):1 1 4 3 2<br />\nswap(a[2], a[4]):1 1 2 3 4<br />\nswap(a[3], a[3]):1 1 2 3 4<br />\nswap(a[4], a[4]):1 1 2 3 4</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=100<br />\n　　整数元素在int范围内</div>\n","gpid":"T270","lanqiaotitle":"选择排序","memorylimit":"256.0MB","tid":"ADV-131","timelimit":"1.0s","title":"算法提高 选择排序","src":""},{"checkpoint":"","updatetime":"2015-03-06","content":"<div class='pdcont'>　　﻿<br />\n　　色盲的民主</div><div class='pdsec'>问题描述</div><div class='pdcont'>　　n个色盲聚在一起，讨论一块布的颜色。尽管都是色盲，却盲得各不相同。每个人都有自己的主张，争论不休。最终，他们决定采取民主投票的方式决定布的颜色，不管布同不同意。某种颜色用字符串表示(字符串为颜色单词或词组，也就是可能有被空格隔开的两个单词组成的颜色词组)，只要字符串不同，程序即判断颜色不同。现在给出这n个人所选择的颜色，输出最有可能的颜色（也就是获得投票最多的颜色），如果有多个颜色获得了最多的投票，则将它们按字典序分行全部输出。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个正整数n，表示色盲的人数<br />\n　　接下来n行，每行一句话</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　若干行，获得投票最多的颜色，按字典序输出</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\nred<br />\nblue<br />\nblack<br />\nblack<br />\nblue</div><div class='pdsec'>样例输出</div><div class='pddata'>black<br />\nblue</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=1000<br />\n　　颜色单词最多20个字符，只包含小写字母或者空格</div><div class='pdsec'>注</div><div class='pdcont'>　　对于char s[20]，由于cin &gt;&gt; s是读取到空格处便会结束，也就是对于light red，用cin只能输入light。如果要整个输入一行，则使用cin.getline(s, 20)，其中20为这一行的最大长度，也就是你的s的容量，如果容量为30,则cin.getline(s, 30)。<br />\n　　另外，你在cin&gt;&gt;n以后cin.getline(s,30)应该会得到一个空字符串，这是因为整数n后面的换行符还未被输入。</div>\n","gpid":"T269","lanqiaotitle":"色盲的民主","memorylimit":"256.0MB","tid":"ADV-130","timelimit":"1.0s","title":"算法提高 色盲的民主","src":""},{"checkpoint":"","updatetime":"2015-03-04","content":"<div class='pdcont'>　　﻿<br />\n　　插入排序</div><div class='pdsec'>问题描述</div><div class='pdcont'>　　排序，顾名思义，是将若干个元素按其大小关系排出一个顺序。形式化描述如下：有n个元素a[1]，a[2]，…，a[n]，从小到大排序就是将它们排成一个新顺序a[i[1]]&lt;a[i[2]]&lt;…&lt;a[i[n]]<br />\n　　i[k]为这个新顺序。<br />\n　　插入排序，顾名思义，是通过插入操作完成排序。其直觉和方法来源于打牌时安排牌的方法。每次摸起一张牌，你都会将其插入到现在手牌中它按顺序应在的那个位置。插入排序每一步都类似这个摸牌过程。比如现在有整数数组：{3, 1, 5, 4, 2}<br />\n　　第一步：插入3 得到新序列{3}<br />\n　　第二步：插入1 得到新序列{1 3}<br />\n　　第三步：插入5 得到新序列{1 3 5}<br />\n　　第四步：插入4 得到新序列{1 3 4 5}<br />\n　　第五步：插入2 得到新序列{1 2 3 4 5}<br />\n　　为了看程序中如何完成插入过程，我们以第五步为例：<br />\n　　初始时：1 3 4 5 2<br />\n　　将2存入临时变量tmp<br />\n　　将下标j指向2之前的元素5，然后根据tmp和a[j]的大小关系决定该元素是否应该后移。如果a[j]&gt;tmp，则将a[j]后移到a[j+1]，序列变成1 3 4 5 5。<br />\n　　将下标j前移<br />\n　　判断a[j]&gt;tmp，后移a[j]到a[j+1]，得到1 3 4 4 5<br />\n　　将下标j前移<br />\n　　判断a[j]&gt;tmp，后移a[j]到a[j+1]，得到1 3 3 4 5<br />\n　　因为a[j]&lt;=tmp，所以将tmp放回a[j+1]，得到 1 2 3 4 5<br />\n　　现在，输入n个整数，根据以上算法，输出插入排序的全过程。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个正整数n，表示元素个数<br />\n　　第二行为n个整数，以空格隔开</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　有n个元素，因此输出部分分为n个部分，每个部分开头行为：Insert element[i]，i为第几个元素。然后对于每一个部分，输出该部分该元素在插入排序过程中的每一步产生的新序列，初始时的序列以Init:打头，然后每一步后移数组元素后的元素序列以Move back:打头，最后得到的最终结果序列以Final:打头。序列元素间以一个空格隔开。示例请看样例输出。每一个部分的Insert element[i]之后的每一步的输出行之前要缩进两格，即输出两个空格。</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n3 1 5 4 2</div><div class='pdsec'>样例输出</div><div class='pddata'>Insert element[1]:<br />\nInit:3<br />\nFinal:3<br />\nInsert element[2]:<br />\nInit:3 1<br />\nMove back:3 3<br />\nFinal:1 3<br />\nInsert element[3]:<br />\nInit:1 3 5<br />\nFinal:1 3 5<br />\nInsert element[4]:<br />\nInit:1 3 5 4<br />\nMove back:1 3 5 5<br />\nFinal:1 3 4 5<br />\nInsert element[5]:<br />\nInit:1 3 4 5 2<br />\nMove back:1 3 4 5 5<br />\nMove back:1 3 4 4 5<br />\nMove back:1 3 3 4 5<br />\nFinal:1 2 3 4 5</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　n&lt;=100<br />\n　　整数元素在int范围内</div>\n","gpid":"T268","lanqiaotitle":"插入排序","memorylimit":"256.0MB","tid":"ADV-129","timelimit":"1.0s","title":"算法提高 插入排序","src":""},{"checkpoint":"素数筛选","updatetime":"2015-03-02","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定区间[L, R]  ， 请计算区间中素数的个数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　两个数L和R。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行，区间中素数的个数。</div><div class='pdsec'>样例输入</div><div class='pddata'>2 11</div><div class='pdsec'>样例输出</div><div class='pddata'>5</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　2 &lt;=  L &lt;= R &lt;= 2147483647        R-L &lt;= 1000000</div>\n","gpid":"T267","lanqiaotitle":"找素数","memorylimit":"256.0MB","tid":"ADV-128","timelimit":"1.0s","title":"算法提高 找素数","src":""},{"checkpoint":"","updatetime":"2015-02-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　扫雷游戏你一定玩过吧！现在给你若干个n×m的地雷阵，请你计算出每个矩阵中每个单元格相邻单元格内地雷的个数，每个单元格最多有8个相邻的单元格。 0&lt;n,m&lt;=100</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含若干个矩阵，对于每个矩阵，第一行包含两个整数n和m，分别表示这个矩阵的行数和列数。接下来n行每行包含m个字符。安全区域用‘.’表示，有地雷区域用'*'表示。当n=m=0时输入结束。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于第i个矩阵，首先在单独的一行里打印序号：“Field #i:”,接下来的n行中，读入的'.'应被该位置周围的地雷数所代替。输出的每两个矩阵必须用一个空行隔开。</div><div class='pdsec'>样例输入</div><div class='pddata'>4 4<br />\n*...<br />\n....<br />\n.*..<br />\n....<br />\n3 5<br />\n**...<br />\n.....<br />\n.*...<br />\n0 0</div><div class='pdsec'>样例输出</div><div class='pddata'>Field #1:<br />\n*100<br />\n2210<br />\n1*10<br />\n1110<br />\n<br />\nField #2:<br />\n**100<br />\n33200<br />\n1*100<br />\n（注意两个矩阵之间应该有一个空行，由于oj的格式化这里不能显示出来）</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　0&lt;n,m&lt;=100</div>\n","gpid":"T264","lanqiaotitle":"扫雷","memorylimit":"256.0MB","tid":"ADV-126","timelimit":"1.0s","title":"算法提高 扫雷","src":""},{"checkpoint":"g背包","updatetime":"2015-01-30","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　张超来到了超市购物。<br />\n　　每个物品都有价格，正好赶上商店推出促销方案。就是把许多东西一起买更便宜（保证优惠方案一定比原价便宜）。物品要买正好的个数，而且不能为了便宜而买不需要的物品。<br />\n　　张超拿到了优惠方案，和需要购买的物品清单，当然想求出最小的花费。他是信息学选手，自然地想到写个程序解决问题。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行促销物品的种类数（0 &lt;= s &lt;= 99）。<br />\n　　第二行..第s+1 行每一行都用几个整数来表示一种促销方式。<br />\n　　第一个整数 n （1 &lt;= n &lt;= 5），表示这种优惠方式由 n 种商品组成。<br />\n　　后面 n 对整数 c 和 k 表示 k （1 &lt;= k &lt;= 5）个编号为 c （1 &lt;= c &lt;= 999）的商品共同构成这种方案。<br />\n　　最后的整数 p 表示这种优惠的优惠价（1 &lt;= p &lt;= 9999）。也就是把当前的方案中的物品全买需要的价格。<br />\n　　第 s+2 行这行一个整数b （0 &lt;= b &lt;= 5），表示需要购买 b 种不同的商品。<br />\n　　第 s+3 行..第 s+b+2 行这 b 行中的每一行包括三个整数：c ，k ，和 p 。<br />\n　　C 表示唯一的商品编号（1 &lt;= c &lt;= 999），<br />\n　　k 表示需要购买的 c 商品的数量（1 &lt;= k &lt;= 5）。<br />\n　　p 表示 c 商品的原价（1 &lt;= p &lt;= 999）。<br />\n　　最多购买 5*5=25 个商品。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个整数ans，表示需要花的最小费用</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n1 7 3 5<br />\n2 7 1 8 2 10<br />\n2<br />\n7 3 2<br />\n8 2 5</div><div class='pdsec'>样例输出</div><div class='pddata'>14</div>\n","gpid":"T262","lanqiaotitle":"促销购物","memorylimit":"256.0MB","tid":"ADV-125","timelimit":"1.0s","title":"算法提高 促销购物","src":""},{"checkpoint":"","updatetime":"2015-01-28","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　巴斯维克命案抓住了六个嫌疑犯，他们的口供如下：<br />\n　　A：我不是罪犯<br />\n　　B：A、C中有一个是罪犯<br />\n　　C：A和B说了假话<br />\n　　D：C和F说了假话<br />\n　　E：其他五个人中，只有A和D说了真话<br />\n　　F：我是罪犯<br />\n　　他们中只有一半说了真话，凶手只有一个。<br />\n　　本题可能有多种可能性，即正确答案（找到唯一的凶手）可能有多个，但每一个可能的答案（某一个是凶手）都满足上述口供。<br />\n　　请编程找出可能的凶手输出。<br />\n　　样例：（假设唯一的凶手是A或者D或者E，则输出结果为三行，按字母顺序依次输出）<br />\n　　A<br />\n　　D<br />\n　　E</div>\n","gpid":"T260","lanqiaotitle":"凶手","memorylimit":"256.0MB","tid":"ADV-124","timelimit":"1.0s","title":"算法提高 凶手","src":""},{"checkpoint":"字符流处理、循环逻辑","updatetime":"2015-01-27","content":"<div class='pdcont'>　　﻿<br />\n　　去注释</div><div class='pdsec'>问题</div><div class='pdcont'>　　给你一段C++代码，将其中的注释去除后输出剩余的代码。<br />\n　　注释共有两种形式：<br />\n　　1.       行注视：以//开头，一直作用到行尾为止。<br />\n　　例子：<br />\n　　int n;<b>//n</b><b>表示数据规模</b><br />\n　　int a;<br />\n　　去注释后：<br />\n　　int n;<br />\n　　int a;<br />\n　　注意：保留行尾换行符<br />\n　　2.       段注视：以/*开头，到*//结尾，中间部分都是注释，可以跨行。<br />\n　　例子：<br />\n　　int main() {<br />\n　　/*<br />\n　　我是<br />\n　　一段<br />\n　　注释<br />\n　　*/<br />\n　　}<br />\n　　去注释后：<br />\n　　int main() {<br />\n<br />\n　　}<br />\n　　注意：由于在线评测系统（Online Judge）对网页显示文本作了格式化，一些空行会被删去，导致上面显示的删除后的结果不正确。删除注释后，剩余的代码应该是三行，两行代码之间有一个空行。这是因为：在段注释结尾符的后面有一个换行符，它不在注释内，需要保留。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一段C++程序代码</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　去掉注释部分后的程序</div><div class='pdsec'>样例输入</div><div class='pddata'>int main() {<br />\n/*<br />\n我是<br />\n一段<br />\n注释<br />\n*/<br />\nint n;//n表示数据规模<br />\n}</div><div class='pdsec'>样例输出</div><div class='pddata'>int main() {<br />\n<br />\nint n;<br />\n}<br />\n<br />\n注意：和之前题目中的解释一样，在int n;之前有一个空行，被在线评测系统删掉，实际程序输出应该有该空行。</div><div class='pdsec'>输入方法</div><div class='pdcont'>　　此题按字符输入，即不断输入下一个字符，直到字符流结束。<br />\n　　char c;<br />\n　　C函数方法：<br />\n　　while ((c = getchar()) != EOF) {<br />\n　　处理..<br />\n　　}<br />\n　　C++流方法：<br />\n　　while ((c = cin.get()) != EOF) {<br />\n　　处理..<br />\n　　}</div>\n","gpid":"T258","lanqiaotitle":"去注释","memorylimit":"256.0MB","tid":"ADV-122","timelimit":"1.0s","title":"算法提高 去注释","src":""},{"checkpoint":"b字符串 数组","updatetime":"2015-01-26","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　在C/C++语言中，整型所能表示的范围一般为-2<sup>31</sup>到2<sup>31</sup>（大约21亿）,即使long long型，一般也只能表示到-2<sup>63</sup>到2<sup>63</sup>。要想计算更加规模的数，就要用软件来扩展了，比如用数组或字符串来模拟更多规模的数及共运算。<br />\n　　现在输入两个整数，请输出它们的和。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　两行，每行一个整数，每个整数不超过1000位</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行，两个整数的和。</div><div class='pdsec'>样例输入</div><div class='pddata'>15464315464465465<br />\n482321654151</div><div class='pdsec'>样例输出</div><div class='pddata'>15464797786119616</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　每个整数不超过1000位</div>\n","gpid":"T257","lanqiaotitle":"高精度加法","memorylimit":"256.0MB","tid":"ADV-121","timelimit":"1.0s","title":"算法提高 高精度加法","src":""},{"checkpoint":"数组操作","updatetime":"2015-01-22","content":"<div class='pdcont'>　　编写函数CompactIntegers，删除数组中所有值为0的元素，其后元素向数组首端移动。注意，CompactIntegers函数需要接收数组及其元素个数作为参数，函数返回值应为删除操作执行后数组的新元素个数。<br />\n　　输入时首先读入数组长度，再依次读入每个元素。<br />\n　　将调用此函数后得到的数组和函数返回值输出。</div><div class='pdsec'>样例输入</div><div class='pddata'>7<br />\n2 0 4 3 0 0 5</div><div class='pdsec'>样例输出</div><div class='pddata'>2 4 3 5<br />\n4</div>\n","gpid":"T254","lanqiaotitle":"6-9删除数组中的0元素","memorylimit":"512.0MB","tid":"ADV-119","timelimit":"1.0s","title":"算法提高 6-9删除数组中的0元素","src":""},{"checkpoint":"函数","updatetime":"2015-01-16","content":"<div class='pdsec'>描述</div><div class='pdcont'>　　编写函数GetReal和GetString，在main函数中分别调用这两个函数。在读入一个实数和一个字符串后，将读入的结果依次用printf输出。<br />\n　　两次输入前要输出的提示信息分别是\"please input a number:\\n”和\"please input a string:\\n\"</div><div class='pdsec'>样例输入</div><div class='pddata'>9.56<br />\nhello</div><div class='pdsec'>样例输出</div><div class='pddata'>please input a number:<br />\nplease input a string:<br />\n9.56<br />\nhello</div>\n","gpid":"T250","lanqiaotitle":"3-2字符串输入输出函数","memorylimit":"512.0MB","tid":"ADV-118","timelimit":"1.0s","title":"算法提高 3-2字符串输入输出函数","src":""},{"checkpoint":"基本运算 数学知识","updatetime":"2015-01-06","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　程序提示用户输入三个字符，每个字符取值范围是0-9，A-F。然后程序会把这三个字符转化为相应的十六进制整数，并分别以十六进制，十进制，八进制输出。<br />\n　　输入格式：输入只有一行，即三个字符。<br />\n　　输出格式：输出只有一行，包括三个整数，中间用空格隔开。<br />\n　　输入输出样例</div><div class='pdsec'>样例输入</div><div class='pddata'>FFF</div><div class='pdsec'>样例输出</div><div class='pddata'>FFF 4095 7777</div>\n","gpid":"T242","lanqiaotitle":"进制转换","memorylimit":"256.0MB","tid":"ADV-117","timelimit":"1.0s","title":"算法提高 进制转换","src":""},{"checkpoint":"","updatetime":"2015-01-05","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编写并测试如下函数：<br />\n　　void Add (int a[], int m, int b[], int n);<br />\n　　该函数将数组b的前n个元素追加到数组a的前m个元素后，假定数组a具有至少存放m+n个元素的空间。例如，如果数组a为{22,33,44,55,66,77,88,99}，数组b为{20,30,40,50,60,70,80,90}，则调用Add(a,5,b,3)后，将把数组a变为{22,33,44,55,66,20,30,40}。注意数组b并没有改变，而且数组a中只需改变n个元素。</div><div class='pdsec'>测试</div><div class='pdcont'>　　输入：4行。第一行为两个整数：m，n，并以空格隔开，分别表示将要输入的数组a和数组b的元素的个数。第二行为m个整数，为数组a的元素；第三行为n个整数，为数组b的元素。第四行为两个整数m1，n1，表示把数组b的前n1个元素追加到数组a的前m1个元素后。<br />\n　　输出：1行。第一行为最后数组a中的元素，两个元素之间以逗号隔开。最后一个元素输出后，输出一个空行。</div><div class='pdsec'>参考程序</div><div class='pdcont'>　　#include &lt;cassert&gt;<br />\n　　#include &lt;iostream&gt;<br />\n　　using namespace std;<br />\n<br />\n　　void Disp(int a[], int n)<br />\n　　{<br />\n　　for (int i=0; i&lt;n-1; i++)<br />\n　　cout &lt;&lt; a[i] &lt;&lt; \", \";<br />\n　　cout &lt;&lt; a[n-1] &lt;&lt; endl;<br />\n　　}<br />\n<br />\n　　void Add(int a[], int m, int b[], int n)<br />\n　　{<br />\n　　//...请补充完整<br />\n　　}<br />\n<br />\n　　int main()<br />\n　　{<br />\n　　int* a = NULL;<br />\n　　int* b = NULL;<br />\n　　int i = 0;<br />\n　　int m, n;<br />\n　　cin &gt;&gt; m &gt;&gt; n;<br />\n　　a = new int[m + n];<br />\n　　b = new int[n];<br />\n　　for(i = 0; i &lt; m; i++)<br />\n　　cin &gt;&gt; a[i];<br />\n　　for(i = 0; i &lt; n; i++)<br />\n　　cin &gt;&gt; b[i];<br />\n<br />\n　　int m1, n1;<br />\n　　cin &gt;&gt; m1 &gt;&gt; n1;<br />\n<br />\n　　//   请补充完整<br />\n<br />\n<br />\n　　return 0;<br />\n　　}</div>\n","gpid":"T241","lanqiaotitle":"c++_ch06_02","memorylimit":"512.0MB","tid":"ADV-116","timelimit":"1.0s","title":"算法提高 c++_ch06_02","src":""},{"checkpoint":"","updatetime":"2015-01-04","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　PASCAL三角是形状如下的三角矩阵：<br />\n　　1<br />\n　　1 1<br />\n　　1 2 1<br />\n　　1 3 3 1<br />\n　　1 4 6 4 1<br />\n　　在PASCAL三角中的每个数是一个组合C(n,k)。<br />\n　　C(n,k)=(((((((n/1)(n-1))/2(n-2))/3)***(n-k+2))/(k-1))(n-k+1))/k<br />\n　　公式中交替使用乘法和除法，每次将从n开始递减的一个值相乘，然后除以下一个从1开始递增的值。<br />\n　　如果对行和列从0开始计数，则数字C(n,k)在n行k列。例如C(6,2)在第6行第2列。编程输出指定阶数的PASCAL三角矩阵。例如下面给出的是12阶PASCAL三角形矩阵。<br />\n<br />\n　　编写程序，使运行结果为：<br />\n　　1<br />\n　　1   1<br />\n　　1   2   1<br />\n　　1   3   3   1<br />\n　　1   4   6   4   1<br />\n　　1   5  10  10   5   1<br />\n　　1   6  15  20  15   6   1<br />\n　　1   7  21  35  35  21   7   1<br />\n　　1   8  28  56  70  56  28   8   1<br />\n　　1   9  36  84 126 126  84  36   9   1<br />\n　　1  10  45 120 210 252 210 120  45  10   1<br />\n　　1  11  55 165 330 462 462 330 165  55  11   1<br />\n　　1  12  66 220 495 792 924 792 495 220  66  12   1<br />\n<br />\n<br />\n　　该题的详细文档及程序框架请从网络学堂下载！</div>\n","gpid":"T240","lanqiaotitle":"c++_ch03_02","memorylimit":"512.0MB","tid":"ADV-115","timelimit":"3.0s","title":"算法提高 c++_ch03_02","src":""},{"checkpoint":"","updatetime":"2014-12-31","content":"<div class='pdcont'>　　编写程序实现“剪刀，石头，布”游戏。在这个游戏中，两个人同时说“剪刀”，“石头”或“布”，压过另一方的为胜者。规则是：“布”胜过“石头”，“石头”胜过“剪刀”，“剪刀”胜过“布”。要求：选择结构中使用枚举类型，结果的输出也使用枚举类型表示。<br />\n　　输入：两个数，范围为{0,1,2}，用空格隔开。0表示石头，1表示布，2表示剪刀。这两个数分别表示两个人所说的物品。<br />\n　　输出：如果前者赢，输出1。如果后者赢，输出-1。如果是平局，输出0。</div>\n","gpid":"T239","lanqiaotitle":"c++_ch02_03","memorylimit":"512.0MB","tid":"ADV-114","timelimit":"1.0s","title":"算法提高 c++_ch02_03","src":""},{"checkpoint":"","updatetime":"2014-12-30","content":"<div class='pdcont'>　　使用Switch语句编写一个模拟简单计算器的程序。依次输入两个整数和一个字符，并用空格隔开。如果该字符是一个“+”，则打印和；如果该字符是一个“-”，则打印差；如果该字符是一个“*”,则打印积；如果该字符是“/”，则打印商；如果该字符是一个“%”，则打印余数。打印结果后输出一个空行。</div>\n","gpid":"T238","lanqiaotitle":"c++_ch02_02","memorylimit":"512.0MB","tid":"ADV-113","timelimit":"1.0s","title":"算法提高 c++_ch02_02","src":""},{"checkpoint":"基本运算 数学知识","updatetime":"2014-12-25","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　求解方程ax<sup>2</sup>+bx+c=0的根。要求a, b, c由用户输入，并且可以为任意实数。<br />\n　　输入格式：输入只有一行，包括三个系数，之间用空格格开。<br />\n　　输出格式：输出只有一行，包括两个根，大根在前，小根在后，无需考虑特殊情况，保留小数点后两位。<br />\n　　输入输出样例</div><div class='pdsec'>样例输入</div><div class='pddata'>2.5 7.5 1.0</div><div class='pdsec'>样例输出</div><div class='pddata'>-0.14 -2.86</div>\n","gpid":"T234","lanqiaotitle":"Quadratic Equation","memorylimit":"512.0MB","tid":"ADV-111","timelimit":"1.0s","title":"算法提高 Quadratic Equation","src":"程序设计公共基础课(谌卫军)"},{"checkpoint":"基本运算 数学知识","updatetime":"2014-12-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编写一个程序，输入一个摄氏温度，输出相应的华氏温度。在输出时，保留小数点后面两位。<br />\n　　输入格式：输入只有一个整数，即摄氏温度。<br />\n　　输出格式：输出只有一实数，即相应的华氏温度。<br />\n　　输入输出样例</div><div class='pdsec'>样例输入</div><div class='pddata'>35</div><div class='pdsec'>样例输出</div><div class='pddata'>95.00</div>\n","gpid":"T233","lanqiaotitle":"温度转换","memorylimit":"512.0MB","tid":"ADV-110","timelimit":"1.0s","title":"算法提高 温度转换","src":"程序设计公共基础课(谌卫军)"},{"checkpoint":"基本运算 数学知识","updatetime":"2014-12-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　税务局希望你帮他们编写一个征税程序，该程序的功能是：首先输入某公司的年销售额sale和税率rate，然后程序将计算出相应的税额tax，并把它显示在屏幕上。计算公式是：<br />\n　　tax = sale * rate。<br />\n　　输入格式：输入只有一行，包括两个数据，即年销售额和税率。<br />\n　　输出格式：输出只有一行，包括一个实数，即相应的税额，保留到小数点后两位。<br />\n　　输入输出样例</div><div class='pdsec'>样例输入</div><div class='pddata'>50000.5 0.1</div><div class='pdsec'>样例输出</div><div class='pddata'>5000.50</div>\n","gpid":"T232","lanqiaotitle":"征税程序","memorylimit":"512.0MB","tid":"ADV-109","timelimit":"1.0s","title":"算法提高 征税程序","src":"程序设计公共基础课(谌卫军)"},{"checkpoint":"","updatetime":"2014-12-22","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　2016.4.5已更新此题，此前的程序需要重新提交。</div><div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个百分制成绩T，将其划分为如下五个等级之一：<br />\n　　90~100为A，80~89为B，70~79为C，60~69为D，0~59为E<br />\n　　现在给定一个文件inp，文件中包含若干百分制成绩（成绩个数不超过100），请你统计五个等级段的人数，并找出人数最多的那个等级段，按照从大到小的顺序输出该段中所有人成绩（保证人数最多的等级只有一个）。要求输出到指定文件oup中。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　若干0~100的正整数，用空格隔开</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　第一行为5个正整数，分别表示A,B,C,D,E五个等级段的人数<br />\n　　第二行一个正整数，表示人数最多的等级段中人数<br />\n　　接下来一行若干个用空格隔开的正整数，表示人数最多的那个等级中所有人的分数，按从大到小的顺序输出。</div><div class='pdsec'>样例输入</div><div class='pddata'>100 80 85 77 55 61 82 90 71 60</div><div class='pdsec'>样例输出</div><div class='pddata'>2 3 2 2 1<br />\n3<br />\n85 82 80</div>\n","gpid":"T231","lanqiaotitle":"分数统计","memorylimit":"512.0MB","tid":"ADV-108","timelimit":"1.0s","title":"算法提高 分数统计","src":""},{"checkpoint":"","updatetime":"2014-12-18","content":"<div class='pdsec'>说明</div><div class='pdcont'>　　2016.4.5 已更新试题，请重新提交自己的程序。</div><div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个大于1，不超过2000000的正整数n，输出欧拉函数，phi(n)的值。<br />\n　　如果你并不了解欧拉函数，那么请参阅提示。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　在给定的输入文件中进行读入：<br />\n　　一行一个正整数n。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　将输出信息输出到指定的文件中:<br />\n　　一行一个整数表示phi(n)。</div><div class='pdsec'>样例输入</div><div class='pddata'>17</div><div class='pdsec'>样例输出</div><div class='pddata'>16</div><div class='pdsec'>提示</div><div class='pdcont'>　　欧拉函数phi(n)是数论中非常重要的一个函数，其表示1到n-1之间，与n互质的数的个数。显然的，我们可以通过定义直接计算phi(n)。<br />\n　　当然，phi(n)还有这么一种计算方法。<br />\n　　首先我们对n进行质因数分解，不妨设n=p1^a1 * p2^a2 * ... * pk^ak （这里a^b表示a的b次幂，p1到pk为k个互不相同的质数，a1到ak均为正整数），那么<br />\n　　phi(n)=n(1-(1/p1))(1-(1/p2))....(1-(1/pk))<br />\n　　稍稍化简一下就是<br />\n　　phi(n)=n(p1-1)(p2-1)...(pk-1)/(p1*p2*...*pk)<br />\n<br />\n<b>计算的时候小心中间计算结果超过int类型上界，可通过调整公式各项的计算顺序避免(比如先做除法)!</b></div>\n","gpid":"T229","lanqiaotitle":"欧拉函数","memorylimit":"512.0MB","tid":"ADV-106","timelimit":"1.0s","title":"算法提高 欧拉函数","src":""},{"checkpoint":"数组运算 字符操作","updatetime":"2014-12-18","content":"<div class='pdcont'><b> </b><br />\n<b>问题描述</b><br />\n　　编写一个程序，输入一个句子，然后统计出这个句子当中不同的单词个数。例如：对于句子“one little two little three little boys”，总共有5个不同的单词：one, little, two, three, boys。<br />\n　　说明：（1）由于句子当中包含有空格，所以应该用gets函数来输入这个句子；（2）输入的句子当中只包含英文字符和空格，单词之间用一个空格隔开；（3）不用考虑单词的大小写，假设输入的都是小写字符；（4）句子长度不超过100个字符。<br />\n　　输入格式：输入只有一行，即一个英文句子。<br />\n　　输出格式：输出只有一行，是一个整数，表示句子中不同单词的个数。<br />\n<b>输入输出样例</b></div><div class='pdsec'>样例输入</div><div class='pddata'>one little two little three little boys</div><div class='pdsec'>样例输出</div><div class='pddata'>5<br />\n<b> </b></div>\n","gpid":"T228","lanqiaotitle":"不同单词个数统计","memorylimit":"512.0MB","tid":"ADV-105","timelimit":"1.0s","title":"算法提高 不同单词个数统计","src":"程序设计公共基础课(谌卫军)"},{"checkpoint":"","updatetime":"2014-12-11","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　N个人要打水，有M个水龙头，第i个人打水所需时间为Ti，请安排一个合理的方案使得所有人的等待时间之和尽量小。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行两个正整数N M 接下来一行N个正整数Ti。<br />\n　　N,M&lt;=1000，Ti&lt;=1000</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　最小的等待时间之和。（不需要输出具体的安排方案）</div><div class='pdsec'>样例输入</div><div class='pddata'>7 3<br />\n3 6 1 4 2 5 7</div><div class='pdsec'>样例输出</div><div class='pddata'>11</div><div class='pdsec'>提示</div><div class='pdcont'>　　一种最佳打水方案是，将N个人按照Ti从小到大的顺序依次分配到M个龙头打水。<br />\n　　例如样例中，Ti从小到大排序为1，2，3，4，5，6，7，将他们依次分配到3个龙头，则去龙头一打水的为1，4，7；去龙头二打水的为2,5；去第三个龙头打水的为3,6。<br />\n　　第一个龙头打水的人总等待时间 = 0 + 1 + (1 + 4) = 6<br />\n　　第二个龙头打水的人总等待时间 = 0 + 2 = 2<br />\n　　第三个龙头打水的人总等待时间 = 0 + 3 = 3<br />\n　　所以总的等待时间 = 6 + 2 + 3 = 11</div>\n","gpid":"T224","lanqiaotitle":"打水问题","memorylimit":"512.0MB","tid":"ADV-104","timelimit":"1.0s","title":"算法提高 打水问题","src":""},{"checkpoint":"字符操作","updatetime":"2014-11-20","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编写一个程序，输入一个字符串（长度不超过80），然后统计出该字符串当中包含有多少个单词。例如：字符串“this is a book”当中包含有4个单词。<br />\n　　输入格式：输入一个字符串，由若干个单词组成，单词之间用一个空格隔开。<br />\n　　输出格式：输出一个整数，即单词的个数。<br />\n　　输入输出样例<br />\n　　用户输入数据样例：<br />\n　　this is a book<br />\n　　系统输出数据如下：<br />\n　　4</div>\n","gpid":"T214","lanqiaotitle":"单词个数统计","memorylimit":"512.0MB","tid":"ADV-102","timelimit":"1.0s","title":"算法提高 单词个数统计","src":""},{"checkpoint":"逻辑判断","updatetime":"2014-11-18","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　公安人员审问甲、乙、丙、丁四个嫌疑犯，已确知，这四个人当中仅有一人是偷窃者，还知道这四个人的答话，要么完全诚实，要么完全说谎。在回答公安人员的问话中：<br />\n　　甲说：“乙没有偷，是丁偷的。”<br />\n　　乙说：“我没有偷，是丙偷的。”<br />\n　　丙说：“甲没有偷，是乙偷的。”<br />\n　　丁说：“我没有偷，我用的那东西是我家里的。”<br />\n　　请根据上述四人答话，判断谁是偷窃者。<br />\n　　输入格式：无输入。<br />\n　　输出格式：输出一个字符，表示偷窃者是谁，A表示甲，B表示乙，C表示丙，D表示丁。</div>\n","gpid":"T212","lanqiaotitle":"断案","memorylimit":"512.0MB","tid":"ADV-101","timelimit":"1.0s","title":"算法提高 断案","src":"程序设计公共基础课(谌卫军)"},{"checkpoint":"循环语句","updatetime":"2014-11-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编写一个程序，输入两个整数，作为栅格的高度和宽度，然后用“+”、“-”和“|”这三个字符来打印一个栅格。<br />\n　　输入格式：输入只有一行，包括两个整数，分别为栅格的高度和宽度。<br />\n　　输出格式：输出相应的栅格。<br />\n　　输入输出样例</div><div class='pdsec'>样例输入</div><div class='pddata'>3 2</div><div class='pdsec'>样例输出</div><div class='pddata'>+-+-+<br />\n| | |<br />\n+-+-+<br />\n| | |<br />\n+-+-+<br />\n| | |<br />\n+-+-+</div>\n","gpid":"T210","lanqiaotitle":"栅格打印问题","memorylimit":"512.0MB","tid":"ADV-99","timelimit":"1.0s","title":"算法提高 栅格打印问题","src":"程序设计公共基础课(谌卫军)"},{"checkpoint":"","updatetime":"2014-11-13","content":"<pre class='pddata'>\n从键盘读入n个复数（实部和虚部都为整数）用链表存储，遍历链表求出n个复数的和并输出。\n样例输入: <br />3 <br />3 4<br />5 2<br />1 3<br />样例输出:<br />9+9i\n</pre>\n<pre class='pddata'>\n样例输入: <br />7<br />1 2<br />3 4<br />2 5<br />1 8<br />6 4<br />7 9<br />3 7<br />样例输出:<br />23+39i\n</pre>\n\n","gpid":"T206","lanqiaotitle":"复数求和","memorylimit":"512.0MB","tid":"ADV-96","timelimit":"1.0s","title":"算法提高 复数求和","src":""},{"checkpoint":"","updatetime":"2014-11-12","content":"<pre class='pddata'>\n独立实现标准字符串库的strcmp函数，即字符串比较函数，从键盘输入两个字符串，按字典序比较大小，前者大于后者输出1，前者小于后者输出-1，两者相等输出0。\n</pre>\n<pre class='pddata'>\n样例输入: <br />apple one <br />样例输出:<br />-1\n</pre>\n<pre class='pddata'>\n样例输入: <br />hello he<br />样例输出:<br />1\n</pre>\n<pre class='pddata'>\n<br />样例输入: <br />hello hello<br />样例输出:<br />0\n</pre>\n\n","gpid":"T204","lanqiaotitle":"字符串比较","memorylimit":"512.0MB","tid":"ADV-95","timelimit":"1.0s","title":"算法提高 字符串比较","src":""},{"checkpoint":"","updatetime":"2014-09-29","content":"<pre class='pddata'>\n已知2007年1月1日为星期一。\n设计一函数按照下述格式打印2007年以后（含）某年某月的日历，2007年以前的拒绝打印。\n为完成此函数，设计必要的辅助函数可能也是必要的。其中输入为年分和月份。\n</pre>\n<pre class='pddata'>\n样例输入: <br />2007  1<br />样例输出:<br />Calendar 2007-01<br />---------------------<br /> Su Mo Tu We Th Fr Sa<br />---------------------<br />     1  2  3  4  5  6<br />  7  8  9 10 11 12 13<br /> 14 15 16 17 18 19 20<br /> 21 22 23 24 25 26 27<br /> 28 29 30 31<br />---------------------\n</pre>\n<pre class='pddata'>\n样例输入: <br />2010  9<br />样例输出:<br />Calendar 2010-09<br />---------------------<br /> Su Mo Tu We Th Fr Sa<br />---------------------<br />           1  2  3  4<br />  5  6  7  8  9 10 11<br /> 12 13 14 15 16 17 18<br /> 19 20 21 22 23 24 25<br /> 26 27 28 29 30<br />---------------------\n</pre>\n<pre class='pddata'>\n注意：短线“-”个数要与题目中一致，否则系统会判为错误。\n</pre>\n\n","gpid":"T199","lanqiaotitle":"任意年月日历输出","memorylimit":"512.0MB","tid":"ADV-93","timelimit":"1.0s","title":"算法提高 任意年月日历输出","src":""},{"checkpoint":"","updatetime":"2014-09-22","content":"<pre class='pddata'>\n编写一函数gcd，求两个正整数的最大公约数。\n</pre>\n<pre class='pddata'>\n样例输入: <br />5 15<br />样例输出:<br />5\n</pre>\n<pre class='pddata'>\n样例输入: <br />7 2<br />样例输出:<br />1\n</pre>\n\n","gpid":"T198","lanqiaotitle":"求最大公约数","memorylimit":"512.0MB","tid":"ADV-92","timelimit":"1.0s","title":"算法提高 求最大公约数","src":""},{"checkpoint":"","updatetime":"2014-09-15","content":"<pre class='pddata'>\n编写一函数IsPrime，判断某个大于2的正整数是否为素数。\n</pre>\n<pre class='pddata'>\n样例输入: <br />5<br />样例输出:<br />yes\n</pre>\n<pre class='pddata'>\n样例输入: <br />9<br />样例输出:<br />no\n</pre>\n<pre class='pddata'>\n注意：是素数输出yes，不是素数输出no，其中yes和no均为小写。\n</pre>\n\n","gpid":"T197","lanqiaotitle":"素数判断","memorylimit":"512.0MB","tid":"ADV-91","timelimit":"1.0s","title":"算法提高 素数判断","src":""},{"checkpoint":"","updatetime":"2014-09-09","content":"<pre class='pddata'>\n按照下述格式打印2006年12月日历：\n</pre>\n<pre class='pddata'>\nCalendar 2006-12<br />--------------------------<br />Su  Mo  Tu  We  Th  Fr  Sa<br />--------------------------<br />                     1   2<br /> 3   4   5   6   7   8   9<br />10  11  12  13  14  15  16<br />17  18  19  20  21  22  23<br />24  25  26  27  28  29  30<br />31<br />--------------------------\n</pre>\n<pre class='pddata'>\n注意：表头和表中的英文字符大小写要与题目中一致，短线“-”个数要与题目中一致，否则系统会判为错误。\n</pre>\n\n","gpid":"T196","lanqiaotitle":"输出日历","memorylimit":"512.0MB","tid":"ADV-90","timelimit":"1.0s","title":"算法提高 输出日历","src":""},{"checkpoint":"","updatetime":"2014-09-01","content":"<pre class='pddata'>\n编制程序，按照下述格式打印九九乘法表。\n输出样例：\nNine-by-nine Multiplication Table<br />--------------------------------------<br />     1   2   3   4   5   6   7   8   9<br />--------------------------------------<br /> 1   1<br /> 2   2   4<br /> 3   3   6   9<br /> 4   4   8  12  16<br /> 5   5  10  15  20  25<br /> 6   6  12  18  24  30  36<br /> 7   7  14  21  28  35  42  49<br /> 8   8  16  24  32  40  48  56  64<br /> 9   9  18  27  36  45  54  63  72  81<br />--------------------------------------\n</pre>\n<div class='pdcont'>　　注意：表头的大小写要和样例一致，短线“-”个数要与样例中一致，否则系统会判为错误。</div>\n","gpid":"T195","lanqiaotitle":"输出九九乘法表","memorylimit":"512.0MB","tid":"ADV-89","timelimit":"1.0s","title":"算法提高 输出九九乘法表","src":""},{"checkpoint":"","updatetime":"2014-08-25","content":"<pre class='pddata'>\n使用循环结构打印下述图形，打印行数n由用户输入。图中每行事实上包括两部分，中间间隔空格字符数m也由用户输入。\n</pre>\n<pre class='pddata'>\n样例输入n,m: <br />5  4<br />样例输出:<br />    *    *********<br />   ***    *******<br />  *****    *****<br /> *******    ***<br />*********    *\n</pre>\n<pre class='pddata'>\n<br />注意：两行之间没有空行。\n</pre>\n\n","gpid":"T194","lanqiaotitle":"输出正反三角形","memorylimit":"512.0MB","tid":"ADV-88","timelimit":"1.0s","title":"算法提高 输出正反三角形","src":""},{"checkpoint":"","updatetime":"2014-08-18","content":"<div class='pdcont'>　　编制程序完成下述任务：接受两个数，一个为用户一年期定期存款金额，一个为按照百分比格式表示的利率；程序计算一年期满<br />\n　　后本金与利息总额。说明：（1）存款金额以人民币元为单位，可能精确到分；（2）输入利率时不需要输入百分号，例如一年期定期存款年利率<br />\n　　为2.52%，用户输入2.52即可；（3）按照国家法律，存款利息所得需缴纳20% 的所得税，计算结果时所得税部分应扣除。要求输出小数点后严格<br />\n　　保留两位小数。</div><div class='pdsec'>样例输入</div><div class='pddata'>10000   2.52</div><div class='pdsec'>样例输出</div><div class='pddata'>10201.60</div>\n","gpid":"T193","lanqiaotitle":"利息计算","memorylimit":"512.0MB","tid":"ADV-87","timelimit":"1.0s","title":"算法提高 利息计算","src":""},{"checkpoint":"","updatetime":"2014-08-11","content":"<pre class='pddata'>\n编制程序，输出下述数据。说明：（1）表中数据来自总参谋部测绘局编制的\n《世界地图集》（星球地图出版社，2004年1月第2版），数据可能已不准确；\n（2）面积单位为万平方公里，人口单位为万人，GDP单位为十亿美元；\n（3）表中所有数据都必须以变量的形式保存；（4）如果不知道每字段宽度\n到底为多少，请仔细数数作为分隔标记的短横数目。<br />---------------------------------------------------<br />COUNTRY     AREA(10K km2)  POP.(10K)  GDP(Billion$)<br />---------------------------------------------------<br />China              960.00  129500.00  1080.00<br />Iceland             10.30      27.57  8.20<br />India              297.47   97000.00  264.80<br />Madagascar          62.70    1635.00  3.60<br />Maldive            0.0298      27.80  0.23<br />---------------------------------------------------<br />注意：输出时空格与短线的数量要与上面格式严格一致，否则系统会判为错误。\n</pre>\n\n","gpid":"T192","lanqiaotitle":"格式化数据输出","memorylimit":"512.0MB","tid":"ADV-86","timelimit":"1.0s","title":"算法提高 格式化数据输出","src":""},{"checkpoint":"","updatetime":"2014-08-04","content":"<pre class='pddata'>\n<span style=\"font-size: medium\"><span style=\"font-family: Times New Roman\"><span lang=\"EN-US\"><span style=\"font: 7pt 'Times New Roman'\">编写一程序，接受用户输入的两个整数，并计算它们的和、差、<br />积、商，程序运行时候输入输出例子如下所示。</span></span></span></span>\n</pre>\n<pre class='pddata'>\n<span style=\"font-size: medium\"><span style=\"font-family: Times New Roman\"><span lang=\"EN-US\"><span style=\"font: 7pt 'Times New Roman'\">样例输入：<br />3  5</span></span></span></span>\n</pre>\n<pre class='pddata'>\n<span style=\"font-size: medium\"><span style=\"font-family: Times New Roman\"><span lang=\"EN-US\"><span style=\"font: 7pt 'Times New Roman'\">样例输出：<br />3+5=8<br />3-5=-2<br />3*5=15<br />3/5=0</span></span></span></span>\n</pre>\n<pre class='pddata'>\n<span style=\"font-size: medium\"><span style=\"font-family: Times New Roman\"><span style=\"\"><span lang=\"EN-US\" style=\"mso-fareast-font-family: 'Times New Roman'\"><span style=\"mso-list: Ignore\"><font face=\"Times New Roman\"><span style=\"font: 7pt 'Times New Roman'\">注意：输出要严格按照+-*/的顺序，分四行输出，而且中间不能有空格，否则系统会判为错误。</span></font></span></span></span></span></span>\n</pre>\n\n","gpid":"T191","lanqiaotitle":"算术运算","memorylimit":"512.0MB","tid":"ADV-85","timelimit":"1.0s","title":"算法提高 算术运算","src":""},{"checkpoint":"","updatetime":"2014-07-14","content":"<div class='pdcont'>　　编写一程序，在屏幕上输出如下内容：<br />\n　　X | X | X<br />\n　　---+---+---<br />\n　　|   |<br />\n　　---+---+---<br />\n　　O | O | O<br />\n　　注意：本题请同学们严格按照图形的格式输出，对齐，其中X和O为大写，否则系统会判为错误。</div>\n","gpid":"T190","lanqiaotitle":"图形输出","memorylimit":"512.0MB","tid":"ADV-84","timelimit":"1.0s","title":"算法提高 图形输出","src":""},{"checkpoint":"","updatetime":"2014-07-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　将1，2，…，9共9个数分成三组，分别组成三个三位数，且使这三个三位数构成<br />\n　　1：2：3的比例，试求出所有满足条件的三个三位数。<br />\n　　例如：三个三位数192，384，576满足以上条件。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　无输入文件</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出每行有三个数，为满足题设三位数。各行为满足要求的不同解。</div>\n","gpid":"T189","lanqiaotitle":"寻找三位数","memorylimit":"512.0MB","tid":"ADV-83","timelimit":"1.0s","title":"算法提高 寻找三位数","src":""},{"checkpoint":"简单计算","updatetime":"2014-06-16","content":"<div class='pdcont'>　　编程计算涂满高为2，半径为r的圆形蛋糕表面，需要多少表面积的奶油(只要涂上表面和侧面)<br />\n　　读入一个数r，输出需要奶油的表面积，结果保留一位小数</div><div class='pdsec'>样例输入</div><div class='pddata'>5.0</div><div class='pdsec'>样例输出</div><div class='pddata'>141.4</div>\n","gpid":"T186","lanqiaotitle":"填充蛋糕","memorylimit":"512.0MB","tid":"ADV-82","timelimit":"1.0s","title":"算法提高 填充蛋糕","src":""},{"checkpoint":"语言 指针","updatetime":"2014-06-05","content":"<div class='pdcont'>　　输入一个正整数（范围[1..10000]），打印其平方（不保留小数位）、平方根、倒数。(用指针实现，保留2位小数，输出每个数之间以一个空格隔开)</div><div class='pdsec'>样例输入</div><div class='pddata'>2</div><div class='pdsec'>样例输出</div><div class='pddata'>4  1.41 0.50</div>\n","gpid":"T185","lanqiaotitle":"数的运算","memorylimit":"512.0MB","tid":"ADV-81","timelimit":"1.0s","title":"算法提高 数的运算","src":""},{"checkpoint":"语言 指针","updatetime":"2014-06-04","content":"<div class='pdcont'>　　输入3个整数a、b、c，（数的范围是[1,10000]）输出其中最大的数。(用指针实现)</div><div class='pdsec'>样例输入</div><div class='pddata'>2  5  1</div><div class='pdsec'>样例输出</div><div class='pddata'>5</div>\n","gpid":"T184","lanqiaotitle":"选最大数","memorylimit":"512.0MB","tid":"ADV-80","timelimit":"1.0s","title":"算法提高 选最大数","src":""},{"checkpoint":"算法 普通计算","updatetime":"2014-06-03","content":"<div class='pdcont'>　　输入n分钟换算成天、小时和分输出。例如4880分钟，可换算成3天9小时20分。<br />\n　　输入一个正整数n(1</div><div class='pdsec'>样例输入</div><div class='pddata'>4880</div><div class='pdsec'>样例输出</div><div class='pddata'>3  9  20</div>\n","gpid":"T183","lanqiaotitle":"时间转换","memorylimit":"512.0MB","tid":"ADV-79","timelimit":"1.0s","title":"算法提高 时间转换","src":""},{"checkpoint":"算法 枚举","updatetime":"2014-05-28","content":"<div class='pdcont'>　　编写一个函数，输入一行字符，将此字符串中最长的单词输出。<br />\n　　输入仅一行，多个单词，每个单词间用一个空格隔开。单词仅由小写字母组成。所有单词的长度和不超过100000。如有多个最长单词，输出最先出现的。</div><div class='pdsec'>样例输入</div><div class='pddata'>I am a student</div><div class='pdsec'>样例输出</div><div class='pddata'>student</div>\n","gpid":"T181","lanqiaotitle":"最长单词","memorylimit":"512.0MB","tid":"ADV-78","timelimit":"1.0s","title":"算法提高 最长单词","src":""},{"checkpoint":"语言 二维数组","updatetime":"2014-05-26","content":"<div class='pdcont'>　　有4个学生，上4门课，要求输入全部学生的各门课成绩，并分别求出每门课的平均成绩。(保留2位小数)<br />\n　　括号里是解释内容，不用输入输出。输入的所有数都为0到100之间（包括端点）的整数</div><div class='pdsec'>样例输入</div><div class='pddata'>(输入第1个学生的4门课成绩) 94  78 87 96<br />\n(输入第2个学生的4门课成绩) 66  87 75 69<br />\n(输入第3个学生的4门课成绩)100 98 89 77<br />\n(输入第4个学生的4门课成绩) 82 73 67 54</div><div class='pdsec'>样例输出</div><div class='pddata'>(第1门课的平均成绩是) 85.50<br />\n(第2门课的平均成绩是) 84.00<br />\n(第3门课的平均成绩是) 79.50<br />\n(第4门课的平均成绩是) 74.00</div>\n","gpid":"T179","lanqiaotitle":"统计平均成绩","memorylimit":"512.0MB","tid":"ADV-77","timelimit":"1.0s","title":"算法提高 统计平均成绩","src":""},{"checkpoint":"语言 循环","updatetime":"2014-05-23","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　设我国国民生产总值的年增产率为10%，计算n年后我国国民生产总值与现在的比是多少。计算公式为：P=(1+r)<sup>n</sup>, r为年增产率，n为年数，P为n年后国民生产总值与现在相比的倍数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入一个数n(1 &lt;= n &lt;= 300)。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个数P，保留2位小数。</div><div class='pdsec'>样例输入</div><div class='pddata'>10</div><div class='pdsec'>样例输出</div><div class='pddata'>2.59</div>\n","gpid":"T178","lanqiaotitle":"GDP计算","memorylimit":"512.0MB","tid":"ADV-76","timelimit":"1.0s","title":"算法提高 GDP计算","src":""},{"checkpoint":"语言 switch语句","updatetime":"2014-05-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编程模拟计算器的加、减、乘、除功能，根据用户输入的运算符，对两个数进行运算。(要求switch语句)</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入只有一行，用空格隔开的运算符和两个运算数，运算符一定是+, -, *, /之一，运算数一定是绝对值不超过200的整数，当运算符为除号时，除数不为0并第一个数一定是第二个数的整数倍。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出只有一行，包含一个整数，表示运算结果。</div><div class='pdsec'>样例输入</div><div class='pddata'>/ 6 2</div><div class='pdsec'>样例输出</div><div class='pddata'>3</div>\n","gpid":"T177","lanqiaotitle":"简单计算器","memorylimit":"512.0MB","tid":"ADV-75","timelimit":"1.0s","title":"算法提高 简单计算器","src":""},{"checkpoint":"","updatetime":"2014-05-20","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输入一个整数，输出其所有质因子。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入只有一行，包含一个整数n。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行，包含若干个整数，为n的所有质因子，按照从小到大的顺序排列。</div><div class='pdsec'>样例输入</div><div class='pddata'>6</div><div class='pdsec'>样例输出</div><div class='pddata'>2 3</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1&lt;=n&lt;=10000。</div>\n","gpid":"T176","lanqiaotitle":"计算整数因子","memorylimit":"512.0MB","tid":"ADV-74","timelimit":"1.0s","title":"算法提高 计算整数因子","src":""},{"checkpoint":"数组 循环","updatetime":"2014-05-16","content":"<div class='pdcont'>　　输入一个3行4列的数组，找出该数组中绝对值最大的元素、输出该元素及其两个下标值。如有多个输出行号最小的，还有多个的话输出列号最小的。</div><div class='pdsec'>样例输入</div><div class='pddata'>1 2  3  5<br />\n-2  5  8  9<br />\n6  -7  5  3</div><div class='pdsec'>样例输出</div><div class='pddata'>9 2 4</div>\n","gpid":"T175","lanqiaotitle":"数组输出","memorylimit":"512.0MB","tid":"ADV-73","timelimit":"1.0s","title":"算法提高 数组输出","src":"程序设计公共基础课"},{"checkpoint":"输入输出","updatetime":"2014-05-13","content":"<div class='pdcont'>　　输入一元一次方法的ax+b=0的解。且数据均在double类型以内,且一定有解（保留2位小数）</div><div class='pdsec'>样例输入</div><div class='pddata'>2  6</div><div class='pdsec'>样例输出</div><div class='pddata'>-3.00</div>\n","gpid":"T172","lanqiaotitle":"一元一次方程","memorylimit":"512.0MB","tid":"ADV-72","timelimit":"1.0s","title":"算法提高 一元一次方程","src":"程序设计公共基础课"},{"checkpoint":"循环 字符串","updatetime":"2014-05-12","content":"<div class='pdcont'>　　编程判断一个字符串是否是回文，当字符串是回文时，输出字符串：yes!，否则输出字符串：no!。所谓回文即正向与反向的拼写都一样，如adgda。　　长度在100以内，且全为小写字母</div><div class='pdsec'>样例输入</div><div class='pddata'>adgda</div><div class='pdsec'>样例输出</div><div class='pddata'>yes!</div>\n","gpid":"T171","lanqiaotitle":"判断回文","memorylimit":"512.0MB","tid":"ADV-71","timelimit":"1.0s","title":"算法提高 判断回文","src":"程序设计公共基础课"},{"checkpoint":"排序 数组","updatetime":"2014-05-06","content":"<div class='pdcont'>　　输入10个数，用“冒泡法”对10个数排序（由小到大）这10个数字在100以内。</div><div class='pdsec'>样例输入</div><div class='pddata'>1 3 6 8 2 7 9 0 4 5</div><div class='pdsec'>样例输出</div><div class='pddata'>0 1 2 3 4 5 6 7 8 9</div>\n","gpid":"T167","lanqiaotitle":"冒泡法排序","memorylimit":"512.0MB","tid":"ADV-70","timelimit":"1.0s","title":"算法提高 冒泡法排序","src":"程序设计公共基础课"},{"checkpoint":"循环 数论","updatetime":"2014-05-05","content":"<div class='pdcont'>　　将一个正整数N(1&lt;N&lt;32768)分解质因数。例如，输入90，打印出90=2*3*3*5。</div><div class='pdsec'>样例输入</div><div class='pddata'>66</div><div class='pdsec'>样例输出</div><div class='pddata'>66=2*3*11</div>\n","gpid":"T166","lanqiaotitle":"质因数","memorylimit":"512.0MB","tid":"ADV-69","timelimit":"1.0s","title":"算法提高 质因数","src":"程序设计公共基础课"},{"checkpoint":"循环 逻辑","updatetime":"2014-04-30","content":"<div class='pdcont'>　　企业发放的奖金根据利润提成。利润低于或等于10万元时，奖金可提10%；利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万元到60万元之间时高于40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%；高于100万元时，超过100万元的部分按1%提成。从键盘输入当月利润，求应发放奖金总数？（保留两位小数）利润的大小在double以内</div><div class='pdsec'>样例输入</div><div class='pddata'>210000</div><div class='pdsec'>样例输出</div><div class='pddata'>18000.00</div>\n","gpid":"T165","lanqiaotitle":"企业奖金发放","memorylimit":"512.0MB","tid":"ADV-68","timelimit":"1.0s","title":"算法提高 企业奖金发放","src":""},{"checkpoint":"NOIP2003 提高组搜索","updatetime":"2014-04-29","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　近来，一种新的传染病肆虐全球。蓬莱国也发现了零星感染者，为防止该病在蓬莱国大范围流行，该国政府决定不惜一切代价控制传染病的蔓延。不幸的是，由于人们尚未完全认识这种传染病，难以准确判别病毒携带者，更没有研制出疫苗以保护易感人群。于是，蓬莱国的疾病控制中心决定采取切断传播途径的方法控制疾病传播。经过 WHO（世界卫生组织）以及全球各国科研部门的努力，这种新兴传染病的传播途径和控制方法已经研究消楚，剩下的任务就是由你协助蓬莱国疾控中心制定一个有效的控制办法。</div><div class='pdsec'>问题描述</div><div class='pdcont'>　　研究表明，这种传染病的传播具有两种很特殊的性质；<br />\n　　第一是它的传播途径是树型的，一个人X只可能被某个特定的人Y感染，只要Y不得病，或者是XY之间的传播途径被切断，则X就不会得病。<br />\n　　第二是，这种疾病的传播有周期性，在一个疾病传播周期之内，传染病将只会感染一代患者，而不会再传播给下一代。<br />\n　　这些性质大大减轻了蓬莱国疾病防控的压力，并且他们已经得到了国内部分易感人群的潜在传播途径图（一棵树）。但是，麻烦还没有结束。由于蓬莱国疾控中心人手不够，同时也缺乏强大的技术，以致他们在一个疾病传播周期内，只能设法切断一条传播途径，而没有被控制的传播途径就会引起更多的易感人群被感染（也就是与当前已经被感染的人有传播途径相连，且连接途径没有被切断的人群）。当不可能有健康人被感染时，疾病就中止传播。所以，蓬莱国疾控中心要制定出一个切断传播途径的顺序，以使尽量少的人被感染。你的程序要针对给定的树，找出合适的切断顺序。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入格式的第一行是两个整数n（1≤n≤300）和p。接下来p行，每一行有两个整数i和j，表示节点i和j间有边相连（意即，第i人和第j人之间有传播途径相连，注意：可能是i到j也可能是j到i）。其中节点1是已经被感染的患者。<br />\n　　对于给定的输入数据，如果不切断任何传播途径，则所有人都会感染。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　只有一行，输出总共被感染的人数。</div><div class='pdsec'>样例输入</div><div class='pddata'>7 6<br />\n1 2<br />\n1 3<br />\n2 4<br />\n2 5<br />\n3 6<br />\n7 3</div><div class='pdsec'>样例输出</div><div class='pddata'>3</div>\n","gpid":"T163","lanqiaotitle":"传染病控制","memorylimit":"512.0MB","tid":"ADV-67","timelimit":"1.0s","title":"算法提高 传染病控制","src":"NOIP2003 提高组"},{"checkpoint":"","updatetime":"2014-04-29","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　在同学们的帮助下，阮小二是变的越来越懒了，连算账都不愿意自己亲自动手了，每天的工作就是坐在电脑前看自己的银行账户的钱是否有变多。可是一段时间观察下来，阮小二发现自己账户的钱增长好慢啊，碰到节假日的时候连个铜板都没进，更郁闷的是这些天分文不进就算了，可恨的是银行这几天还有可能“落井下石”(代扣个人所得税)，看着自己账户的钱被负增长了，阮小二就有被割肉的感觉(太痛苦了！)，这时阮小二最大的愿望无疑是以最快的速度日进斗金，可什么方法能够日进斗金呢？抢银行(老本行)？不行，太危险，怕有命抢没命花；维持现状？受不了，搂钱太慢了！想来想去，抓破脑袋之后，终于想到了能快速发家致富的法宝----买彩票，不但挣了钱有命花，运气好的话，可以每天中他个几百万的，岂不爽哉！抱着这种想法，阮小二开始了他的买彩票之旅。想法是“好的”（太天真了OR 太蠢了），可是又发现自己的数学功底太差，因为不知道数字都有哪些组合排列？那现在就请同学们写个<b>递归</b>程序，帮助阮小二解决一下这个问题吧！</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　不超过6位数的正整数N，注意：<b>构成正整数</b><b>N</b><b>的数字可重复</b></div><div class='pdsec'>输出格式</div><div class='pdcont'>　　组成正整数N的所有位数的全排列，这些排列按<b>升序</b>输出，<b>每个排列占一行。</b><br />\n<b>   </b><br />\n<b>   注意：输出数据中不能有重复的排列</b></div><div class='pdsec'>样例输入</div><div class='pddata'>123</div><div class='pdsec'>样例输出</div><div class='pddata'>123<br />\n132<br />\n213<br />\n231<br />\n312<br />\n321</div><div class='pdsec'>样例输入</div><div class='pddata'>3121</div><div class='pdsec'>样例输出</div><div class='pddata'>1123<br />\n1132<br />\n1213<br />\n1231<br />\n1312<br />\n1321<br />\n2113<br />\n2131<br />\n2311<br />\n3112<br />\n3121<br />\n3211</div><div class='pdsec'>样例输入</div><div class='pddata'>4003</div><div class='pdsec'>样例输出</div><div class='pddata'>0034<br />\n0043<br />\n0304<br />\n0340<br />\n0403<br />\n0430<br />\n3004<br />\n3040<br />\n3400<br />\n4003<br />\n4030<br />\n4300</div>\n","gpid":"T162","lanqiaotitle":"阮小二买彩票","memorylimit":"512.0MB","tid":"ADV-66","timelimit":"1.0s","title":"算法提高 阮小二买彩票","src":""},{"checkpoint":"","updatetime":"2014-04-25","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输入三个自然数N，i，j （1&lt;=i&lt;=N，1&lt;=j&lt;=N），输出在一个N*N格的棋盘中，与格子（i，j）同行、同列、同一对角线的所有格子的位置。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入共三行，分别输入自然数N，i，j。其中保证N&lt;=24且1&lt;=i&lt;=N，1&lt;=j&lt;=N。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出共四行。第一行为与格子（i，j）同行的所有格子的位置，第二行为与格子（i，j）同列的所有格子的位置，第三行为从左上到右下对角线上的格子的位置，第四行为从左下到右上对角线上的格子的位置。</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\n2<br />\n3</div><div class='pdsec'>样例输出</div><div class='pddata'>(2,1) (2,2) (2,3) (2,4)<br />\n(1,3) (2,3) (3,3) (4,3)<br />\n(1,2) (2,3) (3,4)<br />\n(4,1) (3,2) (2,3) (1,4)</div><div class='pdsec'>输入输出样例解释</div><div class='pdcont'>　　n=4，i=2，j=3表示了棋盘中的第二行第三列的格子，如下图：<br />\n<table cellspacing=0 cellpadding=2px style='border-collapse:collapse;' class='table table-striped table-horver'><tbody><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'>第1列</td><td style='border:solid 1.0pt'>第2列</td><td style='border:solid 1.0pt'>第3列</td><td style='border:solid 1.0pt'>第4列</td><td style='border:solid 1.0pt'> </td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'> </td><td style='border:solid 1.0pt'> </td><td style='border:solid 1.0pt'> </td><td style='border:solid 1.0pt'> </td><td style='border:solid 1.0pt'>第1行</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'> </td><td style='border:solid 1.0pt'> </td><td style='border:solid 1.0pt'>(2,3)</td><td style='border:solid 1.0pt'> </td><td style='border:solid 1.0pt'>第2行</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'> </td><td style='border:solid 1.0pt'> </td><td style='border:solid 1.0pt'> </td><td style='border:solid 1.0pt'> </td><td style='border:solid 1.0pt'>第3行</td></tr><tr  style='border:solid 1.0pt'><td style='border:solid 1.0pt'> </td><td style='border:solid 1.0pt'> </td><td style='border:solid 1.0pt'> </td><td style='border:solid 1.0pt'> </td><td style='border:solid 1.0pt'>第4行</td></tr></tbody></table><br />\n　　(2,1) (2,2) (2,3) (2,4) \t\t\t{同一行上格子的位置}<br />\n　　(1,3) (2,3) (3,3) (4,3)\t\t\t{同列列上格子的位置}<br />\n　　(1,2) (2,3) (3,4)\t         \t{左上到右下对角线上的格子的位置}<br />\n　　(4,1) (3,2) (2,3) (1,4)   \t\t{左下到右上对角线上的格子的位置}</div>\n","gpid":"T158","lanqiaotitle":"格子位置","memorylimit":"512.0MB","tid":"ADV-65","timelimit":"1.0s","title":"算法提高 格子位置","src":""},{"checkpoint":"","updatetime":"2014-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编制一个乘法运算的程序。<br />\n　　从键盘读入2个100以内的正整数，进行乘法运算并以竖式输出。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入只有一行，是两个用空格隔开的数字，均在1~99之间（含1和99）。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出为4行或7行，符合乘法的竖式运算格式。</div><div class='pdsec'>样例输入</div><div class='pddata'>89 13</div><div class='pdsec'>样例输出</div><div class='pddata'>89<br />\n×13<br />\n━━━<br />\n267<br />\n89<br />\n━━━<br />\n1157</div><div class='pdsec'>输入输出样例1解释</div><div class='pdcont'>　　3×89=267，则第四行267右侧对准个位输出。1×89=89，则第五行89右侧对准十位输出。267+890=1157，则1157右侧对准个位输出。</div><div class='pdsec'>样例输入</div><div class='pddata'>16 8</div><div class='pdsec'>样例输出</div><div class='pddata'>16<br />\n× 8<br />\n━━━<br />\n128</div><div class='pdsec'>输入输出样例2解释</div><div class='pdcont'>　　8×16=128，则第四行128右侧对准个位输出。计算完成，不再输出。</div>\n","gpid":"T157","lanqiaotitle":"乘法运算","memorylimit":"512.0MB","tid":"ADV-64","timelimit":"1.0s","title":"算法提高 乘法运算","src":""},{"checkpoint":"输入函数，输出函数，基本算数运算","updatetime":"2014-04-24","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　编制程序完成下述任务：接受两个数，一个为用户一年期定期存款金额，一个为按照百分比格式表示的利率；程序计算一年期满后本金与利息总额。说明：（1）存款金额以人民币元为单位，可能精确到分；（2）输入利率时不需要输入百分号，例如一年期定期存款年利率为2.52%，用户输入2.52即可；（3）按照国家法律，存款利息所得需缴纳20% 的所得税，计算结果时所得税部分应扣除。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入一行，包含两个实数，分别表示本金和年利率。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行，包含一个实数，保留到小数点后两位，表示一年后的本金与利息和。</div><div class='pdsec'>样例输入</div><div class='pddata'>10000  2.52</div><div class='pdsec'>样例输出</div><div class='pddata'>10201.60</div>\n","gpid":"T156","lanqiaotitle":"利息计算","memorylimit":"512.0MB","tid":"ADV-63","timelimit":"1.0s","title":"算法提高 利息计算","src":"程序设计公共基础课"},{"checkpoint":"","updatetime":"2014-04-23","content":"<div class='pdcont'><b>[</b><b>题目描述]</b><br />\n　　在一座山上,有很多很多珠宝,它们散落在山底通往山顶的每条道路上,不同道路上的珠宝的数目也各不相同.下图为一张藏宝地图:<br />\n<br />\n　　7<br />\n　　3        8<br />\n　　8   1   0<br />\n　　2   7   4   4<br />\n　　4   5   2   6   5<br />\n<br />\n　　”夺宝奇兵”从山下出发,到达山顶,如何选路才能得到最多的珠宝呢?在上图所示例子中,按照5-&gt;7-&gt;8-&gt;3-&gt;7的顺序,将得到最大值30<br />\n<br />\n<b>[</b><b>输入]</b><br />\n　　第一行正整数N(100&gt;=N&gt;1),表示山的高度<br />\n　　接下来有N行非负整数,第i行有i个整数(1&lt;=i&lt;=N),表示山的第i层上从左到右每条路上的珠宝数目<br />\n<br />\n<b>[</b><b>输出]</b><br />\n　　一个整数,表示从山底到山顶的所能得到的珠宝的最大数目.<br />\n<b>[</b><b>样例输入]</b><pre class='pddata'>\n<span lang=\"EN-US\"><font face=\"宋体\" size=\"3\">5</font></span>\n</pre>\n<pre class='pddata'>\n<span lang=\"EN-US\"><font face=\"宋体\" size=\"3\">7</font></span>\n</pre>\n<pre class='pddata'>\n<span lang=\"EN-US\"><font face=\"宋体\" size=\"3\">3 8</font></span>\n</pre>\n<pre class='pddata'>\n<span lang=\"EN-US\"><font face=\"宋体\" size=\"3\">8 1 0 </font></span>\n</pre>\n<pre class='pddata'>\n<span lang=\"EN-US\"><font face=\"宋体\" size=\"3\">2 7 4 4</font></span>\n</pre>\n<pre class='pddata'>\n<span lang=\"EN-US\"><font face=\"宋体\" size=\"3\">4 5 2 6 5</font></span>\n</pre>\n<br />\n<b>[</b><b>样例输出]</b><br />\n　　30</div>\n","gpid":"T155","lanqiaotitle":"夺宝奇兵","memorylimit":"512.0MB","tid":"ADV-62","timelimit":"1.0s","title":"算法提高 夺宝奇兵","src":""},{"checkpoint":"","updatetime":"2014-04-23","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个矩阵A,一个非负整数b和一个正整数m，求A的b次方除m的余数。<br />\n　　其中一个nxn的矩阵除m的余数得到的仍是一个nxn的矩阵，这个矩阵的每一个元素是原矩阵对应位置上的数除m的余数。<br />\n　　要计算这个问题，可以将A连乘b次，每次都对m求余，但这种方法特别慢，当b较大时无法使用。下面给出一种较快的算法(用A^b表示A的b次方)：<br />\n　　若b=0，则A^b%m=I%m。其中I表示单位矩阵。<br />\n　　若b为偶数，则A^b%m=(A^(b/2)%m)^2%m，即先把A乘b/2次方对m求余，然后再平方后对m求余。<br />\n　　若b为奇数，则A^b%m=(A^(b-1)%m)*a%m，即先求A乘b-1次方对m求余，然后再乘A后对m求余。<br />\n　　这种方法速度较快，请使用这种方法计算A^b%m，其中A是一个2x2的矩阵，m不大于10000。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入第一行包含两个整数b, m，第二行和第三行每行两个整数，为矩阵A。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出两行，每行两个整数，表示A^b%m的值。</div><div class='pdsec'>样例输入</div><div class='pddata'>2 2<br />\n1 1<br />\n0 1</div><div class='pdsec'>样例输出</div><div class='pddata'>1 0<br />\n0 1</div>\n","gpid":"T154","lanqiaotitle":"矩阵乘方","memorylimit":"512.0MB","tid":"ADV-61","timelimit":"1.0s","title":"算法提高 矩阵乘方","src":""},{"checkpoint":"","updatetime":"2014-04-22","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　一元n 次多项式可用如下的表达式表示：<br />\n　　f(x)=a[n]x^n+a[n-1]x^(n-1)+...+a[1]x+a[0], a[n]!=0<br />\n　　其中，a[i]x^i称为i 次项， a[i]称为i 次项的系数。给出一个一元多项式各项的次数和系数，请按照如下规定的格式要求输出该多项式：<br />\n　　1. 多项式中自变量为x，从左到右按照次数递减顺序给出多项式。<br />\n　　2. 多项式中只包含系数不为0 的项。<br />\n　　3. 如果多项式n 次项系数为正，则多项式开头不出现“+”号，如果多项式n 次项系数为负，则多项式以“-”号开头。<br />\n　　4. 对于不是最高次的项，以“+”号或者“-”号连接此项与前一项，分别表示此项系数为正或者系数为负。紧跟一个正整数，表示此项系数的绝对值（如果一个高于0 次的项，其系数的绝对值为1，则无需输出1）。如果x 的指数大于1，则接下来紧跟的指数部分的形式为“x^b”，其中b 为x 的指数；如果x 的指数为1，则接下来紧跟的指数部分形式为“x”；如果x 的指数为0，则仅需输出系数即可。<br />\n　　5. 多项式中，多项式的开头、结尾不含多余的空格。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入共有2 行<br />\n　　第一行1 个整数，n，表示一元多项式的次数。<br />\n　　第二行有n+1 个整数，其中第i 个整数表示第n-i+1 次项的系数，每两个整数之间用空格隔开。<br />\n　　1 ≤ n ≤ 100，多项式各次项系数的绝对值均不超过100。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出共1 行，按题目所述格式输出多项式。</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n100 -1 1 -3 0 10</div><div class='pdsec'>样例输出</div><div class='pddata'>100x^5-x^4+x^3-3x^2+10</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n-50 0 0 1</div><div class='pdsec'>样例输出</div><div class='pddata'>-50x^3+1</div>\n","gpid":"T152","lanqiaotitle":"多项式输出","memorylimit":"512.0MB","tid":"ADV-21","timelimit":"1.0s","title":"算法提高 多项式输出","src":""},{"checkpoint":"","updatetime":"2014-04-16","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定N个整数组成的序列，每次交换当前第x个与第y个整数，要求输出最终的序列。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行为序列的大小N(1&lt;=N&lt;=1000)和操作个数M(1&lt;=M&lt;=1000)。<br />\n　　第二行包含N个数字，表示初始序列。<br />\n　　接下来M行，每行两个整数x,y (1&lt;=x,y&lt;=N)，表示要交换的两个整数。在一次交换中，如果x和y相等，则不会改变序列的内容。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出N行，为交换后的序列中的数。</div><div class='pdsec'>样例输入</div><div class='pddata'>5 2<br />\n1 2 3 4 5<br />\n1 2<br />\n3 4</div><div class='pdsec'>样例输出</div><div class='pddata'>2<br />\n1<br />\n4<br />\n3<br />\n5</div>\n","gpid":"T145","lanqiaotitle":"交换Easy","memorylimit":"512.0MB","tid":"ADV-20","timelimit":"1.0s","title":"算法提高 交换Easy","src":""},{"checkpoint":"","updatetime":"2014-04-15","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　由 n(1≤n≤100)　　个珠子组成的一个项链，珠子有红、蓝、白三种颜色，各种颜色的珠子的安排顺序由键盘输入的字符串任意给定。蓝色用小写字母b表示,红色用小写字母r表示,　　白色用小写字母w表示.<br />\n<br />\n　　假定从项链的某处将其剪断，把它摆成一条直线。先从左端向右收集同色珠子，遇到第一个异色珠子时停止.　　收集过程中, 白色是一种特殊颜色, 既可以看成红色也可以看成蓝色。然后再从剩余珠子的右端向左重复上述过程。<br />\n<br />\n　　例如：对下图一所示的项链, 如果从图一中标记的位置0处剪断,　　则按顺时针顺序得到wbbbwwrrbwbrrwb（如图二所示）。这时从左端开始收集可以得到wbbbww,　　共6个珠子；然后从剩余珠子右端开始收集得到wb，共2个珠子。这种剪法共可收集到6+2=8个珠子。 如果从图一中标记的位置4处剪断,　　则按顺时针顺序得到wwrrbwbrrwbwbbb（如图二所示）。这时从左端收集可以得到wwrr,共4个珠子；然后从剩余珠子右端收集可以得到wbwbbb，共6个珠子。这种剪法共可收集到4+6=10个珠子。<br />\n<br />\n　　要求: 在项链中选择合适的剪断位置, 使得从左右两端收集到的珠子数目之和最大，输出收集到的珠子数的最大值M。<br />\n<img height=500 src=\"\" /><br />\n<img height=280 src=\"\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　由小写字母b,r,w组成的字符串。此字符串记录了一个首尾相接的项链从某处断开后，按顺时针顺序得到的珠子的直线排列。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　收集到的珠子数的最大值 M</div><div class='pdsec'>样例输入</div><pre class='pddata'>\nwbbbwwrrbwbrrwb</PRE></FONT>\n<P></P>\n<br /></p><p class=\"subtitle\">样例输出</p><p class=\"probcontent\">\n<P><FONT face=\"Times New Roman\" size=3><PRE>10</PRE></FONT>\n<P></P>\n<br />\n</pre>\n\n","gpid":"T143","lanqiaotitle":"项链","memorylimit":"512.0MB","tid":"ADV-19","timelimit":"1.0s","title":"算法提高 项链","src":""},{"checkpoint":"","updatetime":"2014-04-15","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　计算两个实数相加的结果。<br />\n　　输入的实数满足如下要求: (1)　　小数点前的整数部分最多100位，(2) 小数点后的小数部分最多100位.</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　两行字符串，每行都是一个合法的实数。合法的意思是指:　　整数部分的值如果大于零,则最高位数字必定大于零. 如果整数部分的值为零,则整数部分只有一个零. 小数部分尾部可以有任意多的零. 可以没有小数部分,　　此时也没有小数点. 如果有小数点, 则至少需要有一位小数部分, 且允许是零.</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　相加结果。注意: 小数部分末尾如果有连续的0, 则它们都是有效数字,　　不能舍去. 如果是两个整数相加, 则结果仍为整数而没有小数部分.</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n样例一:\n0.0000000000000000000000000000000000000111111111000000000000000000\n100000000000000000000000000000000000000000000000000000.0\n样例二:\n3\n4\n样例三:\n3.9\n2\n样例四：\n1.001\n8.99999999999999999999999</PRE></FONT>\n<P></P>\n<br /></p><p class=\"subtitle\">样例输出</p><p class=\"probcontent\">\n<P><FONT face=\"Times New Roman\" size=3><PRE>样例一：\n100000000000000000000000000000000000000000000000000000.0000000000000000000000000000000000000111111111000000000000000000\n样例二：\n7\n样例三:\n5.9\n样例四：\n10.00099999999999999999999</PRE></FONT>\n<P></P>\n<br />\n</pre>\n\n","gpid":"T142","lanqiaotitle":"实数相加","memorylimit":"512.0MB","tid":"ADV-18","timelimit":"1.0s","title":"算法提高 实数相加","src":""},{"checkpoint":"","updatetime":"2014-04-14","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　统计输入英文文章段落中不同单词（单词有大小写之分,　　但统计时忽略大小写）各自出现的次数。 输入段落中所含单词的总数不超过100，最长单词的长度不超过20个字母.</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一个包含若干句子的段落, 每个句子由若干英文单词组成. 除空格,　　逗号和句号外, 这些输入的句子中不含其他非字母字符, 并且, 逗号和句号紧跟在它前面的英文单词后面, 中间没有空格. 段落最后一个字符是回车符,　　表示输入结束.</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　若段落中共有M个不同的英文单词，则按照其在段落中出现的先后顺序输出M行，各行的格式为:　　单词中所有字母均用大写形式输出（最长的单词顶格输出，它前面没有多余的空格;　　其余单词与其右对齐）+冒号+N个*号+该单词在段落中的出现次数N</div><div class='pdsec'>样例输入</div><pre class='pddata'>\nThis is a test. This test is easy. This is a test. This test is easy.</PRE></FONT>\n<P></P>\n<br /></p><p class=\"subtitle\">样例输出</p><p class=\"probcontent\">\n<P><FONT face=\"Times New Roman\" size=3><PRE>THIS:****4\nIS:****4\nA:**2\nTEST:****4\nEASY:**2\n</PRE></FONT>\n<P></P>\n<br />\n</pre>\n\n","gpid":"T140","lanqiaotitle":"统计单词数","memorylimit":"512.0MB","tid":"ADV-17","timelimit":"1.0s","title":"算法提高 统计单词数","src":""},{"checkpoint":"","updatetime":"2014-04-10","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　对于一个给定的长度为N的整数序列A，它的“子序列”的定义是：A中非空的一段连续的元素（整数）。你要完成的任务是，在所有可能的子序列中，找到一个子序列，该子序列中所有元素的和是最大的（跟其他所有子序列相比）。程序要求你输出这个最大值。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入文件的第一行包含一个整数N，第二行包含N个整数，表示A。<br />\n　　其中<br />\n　　1 &lt;= N &lt;= 100000<br />\n　　-10000 &lt;= A[i] &lt;=　　10000</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出仅包含一个整数，表示你算出的答案。</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n5\n3 -2 3 -5 4</PRE></FONT>\n<P></P>\n<br /></p><p class=\"subtitle\">样例输出</p><p class=\"probcontent\">\n<P><FONT face=\"Times New Roman\" size=3><PRE>4</PRE></FONT>\n<P></P>\n<br />\n</pre>\n\n","gpid":"T137","lanqiaotitle":"和最大子序列","memorylimit":"512.0MB","tid":"ADV-16","timelimit":"1.0s","title":"算法提高 和最大子序列","src":""},{"checkpoint":"","updatetime":"2014-04-09","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　锦瑟年华谁与度 莫问情归处 只影向斜阳 剑吼西风 欲把春留驻<br />\n　　天涯芳草无归路 回首花无数 解语自销魂 弱袂萦春 尘缘不相误<br />\n　　......<br />\n　　在卡勒沃夫充满文学杀伤力的声音中，身处紫荆2号楼202B的四位远近高低各不同的室友纷纷回忆起了各自波澜起伏的过去，并对长在百草园，邻有百花谷的现状表达了各自的见解。<br />\n　　某Q：\"...我小学就开窍了...她的父母说我很好，但是...今天又和北林的联系了...\"<br />\n　　某X：\"...差点就成了，结果到学校了...这个方法放假了我去对我的同桌用！...\"<br />\n　　某W：\"...\"（千言万语不言中，有大量的故事等待考古）<br />\n　　某Z：\"...为了来清华...咱们审美观不一样，不会抢...\"<br />\n　　......<br />\n　　卡勒沃夫在这个不朽的夜话中搜集出了某人零散的历任女友资料，为了强迫某人将他出的题目的标程交出，现在卡勒沃夫需要一个能将这些零散信息整合起来的程序。伴随着雄壮委婉动人的音乐，身为程序设计快男（超女）的你降临了！卡勒沃夫正对着您做Orz状并请求着：\"神牛啊~请施舍给我一段程序把~偶米头发~\"。。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行为一个不超过5的整数T，表示数据的组数。之后每组数据的一行为一个不超过100的整数n。之后n行每行有两个用单个空格隔开的字符串（每个字符串只有英文大小写字母，长度不超过10），为两位mm的名字。每行第一个mm先于第二个mm成为某人的女友。<br />\n　　在这里我们假装诅咒某人不会同时被两个或两个以上mm泡，某个mm抛弃了某人后不会再吃回头草，同时卡勒沃夫深邃的洞察力使得他收集到了充足的信息以确定某人女友的先后顺序。<br />\n　　在小数据组中出现的人物不超过13个</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出T行，每行对应一组数据，并按照mm们从先到后成为某人女友的顺序输出她们的名字，各个名字间用一个空格隔开。</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n2\n2\nRY Unknown\nYSZ RY\n3\ntomorrow yestoday\ntomorrow today\ntoday yestoday\n</PRE></FONT>\n<P></P>\n<br /></p><p class=\"subtitle\">样例输出</p><p class=\"probcontent\">\n<P><FONT face=\"Times New Roman\" size=3><PRE>YSZ RY Unknown\ntomorrow today yestoday</PRE></FONT>\n<P></P>\n<br />\n</pre>\n\n","gpid":"T135","lanqiaotitle":"卡勒沃夫之弱水路三千(提高型)","memorylimit":"512.0MB","tid":"ADV-14","timelimit":"1.0s","title":"算法提高 卡勒沃夫之弱水路三千(提高型)","src":""},{"checkpoint":"","updatetime":"2014-04-08","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给两组数，各n个。<br />\n　　请调整每组数的排列顺序，使得两组数据相同下标元素对应相乘，然后相加的和最小。要求程序输出这个最小值。<br />\n　　例如两组数分别为:1 3　　-5和-2 4 1<br />\n<br />\n　　那么对应乘积取和的最小值应为：<br />\n　　(-5) * 4 + 3 * (-2) + 1 * 1 = -25</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一个行一个数T表示数据组数。后面每组数据，先读入一个n，接下来两行每行n个数，每个数的绝对值小于等于1000。<br />\n　　n&lt;=1000,T&lt;=10</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个数表示答案。</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n2\n3\n1 3 -5\n-2 4 1\n5\n1 2 3 4 5\n1 0 1 0 1\n</PRE></FONT>\n<P></P>\n<br /></p><p class=\"subtitle\">样例输出</p><p class=\"probcontent\">\n<P><FONT face=\"Times New Roman\" size=3><PRE>-25\n6\n</PRE></FONT>\n<P></P>\n<br />\n</pre>\n\n","gpid":"T134","lanqiaotitle":"最小乘积(提高型)","memorylimit":"512.0MB","tid":"ADV-13","timelimit":"1.0s","title":"算法提高 最小乘积(提高型)","src":""},{"checkpoint":"","updatetime":"2014-04-04","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个t，将t秒转化为HH:MM:SS的形式，表示HH小时MM分钟SS秒。HH,MM,SS均是两位数，如果小于10用0补到两位。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行一个数T(1&lt;=T&lt;=100,000)，表示数据组数。后面每组数据读入一个数t，0&lt;=t&lt;24*60*60。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　每组数据一行，HH:MM:SS。</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n0<br />\n86399</div><div class='pdsec'>样例输出</div><div class='pddata'>00:00:00<br />\n23:59:59</div>\n","gpid":"T132","lanqiaotitle":"计算时间","memorylimit":"512.0MB","tid":"ADV-12","timelimit":"1.0s","title":"算法提高 计算时间","src":""},{"checkpoint":"","updatetime":"2014-04-03","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Torry从小喜爱数学。一天，老师告诉他，像2、3、5、7……这样的数叫做质数。Torry突然想到一个问题，前10、100、1000、10000……个质数的乘积是多少呢？他把这个问题告诉老师。老师愣住了，一时回答不出来。于是Torry求助于会编程的你，请你算出前n个质数的乘积。不过，考虑到你才接触编程不久，Torry只要你算出这个数模上50000的值。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　仅包含一个正整数n，其中n&lt;=100000。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行，即前n个质数的乘积模50000的值。</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n1</PRE></FONT>\n<P></P>\n<br /></p><p class=\"subtitle\">样例输出</p><p class=\"probcontent\">\n<P><FONT face=\"Times New Roman\" size=3><PRE>2</PRE></FONT>\n<P></P>\n<br />\n</pre>\n\n","gpid":"T130","lanqiaotitle":"Torry的困惑(提高型)","memorylimit":"512.0MB","tid":"ADV-11","timelimit":"1.0s","title":"算法提高 Torry的困惑(提高型)","src":""},{"checkpoint":"","updatetime":"2014-04-02","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　如右图所示，这是一个空心正方体（请想象用纸糊出来的正方体），每条棱的编号如图所示<br />\n　　(图在http://166.111.138.150/fop/attach/cube.jpg)。<br />\n<br />\n　　考虑剪开若干条棱，请判断正方体是否会被剪成分开（即判断正方体是否会被分割成不少于2个部分）。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　本题包括多组数据。<br />\n　　第一行输入一个N，表示数据组数。<br />\n　　对于每一组数据，都包括两行。<br />\n　　第一行输入一个n，表示总共剪开了n条棱。<br />\n　　第二行有n个数，每个数表示剪开的棱的编号。（输入保证每条棱出现次数不超过1）</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对于每一组输入，输出一行。<br />\n　　若正方体会被分割成不少于2个部分，则输出“Yes”，否则输出“No”（均不包括引号）。</div><div class='pdsec'>样例输入</div><pre class='pddata'>\n5\n4\n1 2 3 4\n6\n1 2 5 7 11 12\n3\n1 4 5\n6\n1 3 4 5 9 12\n12\n1 2 3 4 5 6 7 8 9 10 11 12\n</PRE></FONT>\n<P></P>\n<br /></p><p class=\"subtitle\">样例输出</p><p class=\"probcontent\">\n<P><FONT face=\"Times New Roman\" size=3><PRE>Yes\nYes\nNo\nNo\nYes\n</PRE></FONT>\n<P></P>\n<br />\n</pre>\n\n","gpid":"T127","lanqiaotitle":"立方体截断问题","memorylimit":"512.0MB","tid":"ADV-10","timelimit":"1.0s","title":"算法提高 立方体截断问题","src":""},{"checkpoint":"","updatetime":"2014-03-20","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　完成一个递归程序，倒置字符数组。并打印实现过程<br />\n　　递归逻辑为：<br />\n　　当字符长度等于1时，直接返回<br />\n　　否则，调换首尾两个字符，在递归地倒置字符数组的剩下部分</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　字符数组长度及该数组</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　在求解过程中，打印字符数组的变化情况。<br />\n　　最后空一行，在程序结尾处打印倒置后该数组的各个元素。</div><div class='pdsec'>样例输入</div><pre class='pddata'>\nSample 1\n5 abcde\nSample 2\n1 a</PRE></FONT>\n<P></P>\n<br /></p><p class=\"subtitle\">样例输出</p><p class=\"probcontent\">\n<P><FONT face=\"Times New Roman\" size=3><PRE>Sample 1\nebcda\nedcba\nedcba\nSample 2\na\n</PRE></FONT>\n<P></P>\n<br />\n</pre>\n\n","gpid":"T112","lanqiaotitle":"递归倒置字符数组","memorylimit":"512.0MB","tid":"ADV-9","timelimit":"1.0s","title":"算法提高 递归倒置字符数组","src":""},{"checkpoint":"组合","updatetime":"2013-11-07","content":"<div class='pdcont'>　　考虑冒泡排序的一种实现。<br />\n　　bubble-sort (A[], n)<br />\n　　&gt; round = 0<br />\n　　&gt; while A is not sorted<br />\n　　&gt; &gt; round := round + 1<br />\n　　&gt; &gt; for i := 1 to n - 1<br />\n　　&gt; &gt; &gt; if (A[i] &gt; A[i + 1])<br />\n　　&gt; &gt; &gt; &gt; swap(A[i], A[i + 1])<br />\n　　求1 .. n的排列中，有多少个排列使得A被扫描了K遍，亦即算法结束时round == K。<br />\n<br />\n　　答案模20100713输出。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入包含多组数据。每组数据为一行两个整数N，K。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　对每组数据，输出一行一个整数表示答案。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n3 0<br />\n3 1<br />\n3 2</div><div class='pdsec'>样例输出</div><div class='pddata'>1<br />\n3<br />\n2</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　T &lt;= 10 ^ 5。<br />\n　　1 &lt;= K &lt; N &lt; 10 ^ 6。</div>\n","gpid":"T81","lanqiaotitle":"冒泡排序计数","memorylimit":"256.0MB","tid":"ADV-8","timelimit":"1.0s","title":"算法提高 冒泡排序计数","src":""},{"checkpoint":"组合","updatetime":"2013-11-07","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　一个有N个元素的集合有2^N个不同子集（包含空集），现在要在这2^N个集合中取出若干集合（至少一个），使得它们的交集的元素个数为K，求取法的方案数，答案模1000000007。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入一行两个整数N，K。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个整数表示答案。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 2</div><div class='pdsec'>样例输出</div><div class='pddata'>6</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1 &lt;= K &lt;= N &lt;= 10 ^ 6。</div>\n","gpid":"T80","lanqiaotitle":"子集选取","memorylimit":"256.0MB","tid":"ADV-7","timelimit":"1.0s","title":"算法提高 子集选取","src":""},{"checkpoint":"搜索","updatetime":"2013-10-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个信封，最多只允许粘贴N张邮票，计算在给定K（N+K≤13）种邮票的情况下（假定所有的邮票数量都足够），如何设计邮票的面值，能得到最大值MAX，使在1～MAX之间的每一个邮资值都能得到。<br />\n<br />\n　　例如，N=3，K=2，如果面值分别为1分、4分，则在1分～6分之间的每一个邮资值都能得到（当然还有8分、9分和12分）；如果面值分别为1分、3分，则在1分～7分之间的每一个邮资值都能得到。可以验证当N=3，K=2时，7分就是可以得到的连续的邮资最大值，所以MAX=7，面值分别为1分、3分。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一行，两个数N、K</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　两行，第一行升序输出设计的邮票面值，第二行输出“MAX=xx”（不含引号），其中xx为所求的能得到的连续邮资最大值。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 2</div><div class='pdsec'>样例输出</div><div class='pddata'>1 3<br />\nMAX=7</div>\n","gpid":"T45","lanqiaotitle":"邮票面值设计","memorylimit":"256.0MB","tid":"ADV-6","timelimit":"1.0s","title":"算法提高 邮票面值设计","src":"NOIP1999 提高组"}]},{"name":"历届试题","prefix":"PREV-","problems":[{"checkpoint":"","updatetime":"2017-12-18","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　模拟程序型计算器，依次输入指令，可能包含的指令有<br />\n<br />\n<br />\n　　1. 数字：'NUM X'，X为一个只包含大写字母和数字的字符串，表示一个当前进制的数<br />\n　　2. 运算指令：'ADD','SUB','MUL','DIV','MOD'，分别表示加减乘，除法取商，除法取余<br />\n　　3. 进制转换指令：'CHANGE K'，将当前进制转换为K进制(2≤K≤36)<br />\n　　4. 输出指令：'EQUAL'，以当前进制输出结果<br />\n　　5. 重置指令：'CLEAR'，清除当前数字<br />\n<br />\n<br />\n　　指令按照以下规则给出：<br />\n　　数字，运算指令不会连续给出，进制转换指令，输出指令，重置指令有可能连续给出<br />\n　　运算指令后出现的第一个数字，表示参与运算的数字。且在该运算指令和该数字中间不会出现运算指令和输出指令<br />\n　　重置指令后出现的第一个数字，表示基础值。且在重置指令和第一个数字中间不会出现运算指令和输出指令<br />\n　　进制转换指令可能出现在任何地方<br />\n<br />\n<br />\n　　运算过程中中间变量均为非负整数，且小于2^63。<br />\n　　以大写的'A'~'Z'表示10~35</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第1行：1个n，表示指令数量<br />\n　　第2..n+1行：每行给出一条指令。指令序列一定以'CLEAR'作为开始，并且满足指令规则</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　依次给出每一次'EQUAL'得到的结果</div><div class='pdsec'>样例输入</div><div class='pddata'>7<br />\nCLEAR<br />\nNUM 1024<br />\nCHANGE 2<br />\nADD<br />\nNUM 100000<br />\nCHANGE 8<br />\nEQUAL</div><div class='pdsec'>样例输出</div><div class='pddata'>2040</div>\n","gpid":"T459","lanqiaotitle":"小计算器","memorylimit":"256.0MB","tid":"PREV-55","timelimit":"1.0s","title":"历届试题 小计算器","src":"2017蓝桥杯决赛 JavaB组第四题"},{"checkpoint":"","updatetime":"2017-12-18","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　w星球的一个种植园，被分成 m * n 个小格子（东西方向m行，南北方向n列）。每个格子里种了一株合根植物。<br />\n　　这种植物有个特点，它的根可能会沿着南北或东西方向伸展，从而与另一个格子的植物合成为一体。<br />\n<br />\n<br />\n　　如果我们告诉你哪些小格子间出现了连根现象，你能说出这个园中一共有多少株合根植物吗？</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行，两个整数m，n，用空格分开，表示格子的行数、列数（1&lt;m,n&lt;1000）。<br />\n　　接下来一行，一个整数k，表示下面还有k行数据(0&lt;k&lt;100000)<br />\n　　接下来k行，第行两个整数a，b，表示编号为a的小格子和编号为b的小格子合根了。<br />\n<br />\n<br />\n　　格子的编号一行一行，从上到下，从左到右编号。<br />\n　　比如：5 * 4 的小格子，编号：<br />\n　　1  2  3  4<br />\n　　5  6  7  8<br />\n　　9  10 11 12<br />\n　　13 14 15 16<br />\n　　17 18 19 20</div><div class='pdsec'>样例输入</div><div class='pddata'>5 4<br />\n16<br />\n2 3<br />\n1 5<br />\n5 9<br />\n4 8<br />\n7 8<br />\n9 10<br />\n10 11<br />\n11 12<br />\n10 14<br />\n12 16<br />\n14 18<br />\n17 18<br />\n15 19<br />\n19 20<br />\n9 13<br />\n13 17</div><div class='pdsec'>样例输出</div><div class='pddata'>5</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　其合根情况参考下图<br />\n<img src=\"/RequireFile.do?fid=H549d7Ej\" /></div>\n","gpid":"T458","lanqiaotitle":"合根植物","memorylimit":"256.0MB","tid":"PREV-54","timelimit":"2.0s","title":"历届试题 合根植物","src":"2017蓝桥杯决赛 C++C组第六题 JavaC组第六题"},{"checkpoint":"","updatetime":"2017-12-18","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　n个人参加某项特殊考试。<br />\n　　为了公平，要求任何两个认识的人不能分在同一个考场。<br />\n　　求是少需要分几个考场才能满足条件。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行，一个整数n(1&lt;n&lt;100)，表示参加考试的人数。<br />\n　　第二行，一个整数m，表示接下来有m行数据<br />\n　　以下m行每行的格式为：两个整数a，b，用空格分开 (1&lt;=a,b&lt;=n)  表示第a个人与第b个人认识。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行一个整数，表示最少分几个考场。</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n8<br />\n1 2<br />\n1 3<br />\n1 4<br />\n2 3<br />\n2 4<br />\n2 5<br />\n3 4<br />\n4 5</div><div class='pdsec'>样例输出</div><div class='pddata'>4</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n10<br />\n1 2<br />\n1 3<br />\n1 4<br />\n1 5<br />\n2 3<br />\n2 4<br />\n2 5<br />\n3 4<br />\n3 5<br />\n4 5</div><div class='pdsec'>样例输出</div><div class='pddata'>5</div>\n","gpid":"T457","lanqiaotitle":"分考场","memorylimit":"256.0MB","tid":"PREV-53","timelimit":"1.0s","title":"历届试题 分考场","src":"2017蓝桥杯决赛 C++C组第五题 JavaC组第五题"},{"checkpoint":"","updatetime":"2017-12-18","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　我们知道，整数做除法时，有时得到有限小数，有时得到无限循环小数。<br />\n　　如果我们把有限小数的末尾加上无限多个0，它们就有了统一的形式。<br />\n<br />\n<br />\n　　本题的任务是：在上面的约定下，求整数除法小数点后的第n位开始的3位数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一行三个整数：a b n，用空格分开。a是被除数，b是除数，n是所求的小数后位置（0&lt;a,b,n&lt;1000000000）</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行3位数字，表示：a除以b，小数后第n位开始的3位数字。</div><div class='pdsec'>样例输入</div><div class='pddata'>1 8 1</div><div class='pdsec'>样例输出</div><div class='pddata'>125</div><div class='pdsec'>样例输入</div><div class='pddata'>1 8 3</div><div class='pdsec'>样例输出</div><div class='pddata'>500</div><div class='pdsec'>样例输入</div><div class='pddata'>282866 999000 6</div><div class='pdsec'>样例输出</div><div class='pddata'>914</div>\n","gpid":"T456","lanqiaotitle":"小数第n位","memorylimit":"256.0MB","tid":"PREV-52","timelimit":"1.0s","title":"历届试题 小数第n位","src":"2017蓝桥杯决赛 C++C组第四题 JavaC组第四题"},{"checkpoint":"","updatetime":"2017-12-18","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　跳蚤国正在大力发展旅游业，每个城市都被打造成了旅游景点。<br />\n　　许多跳蚤想去其他城市旅游，但是由于跳得比较慢，它们的愿望难以实现。这时，小C听说有一种叫做火车的交通工具，在铁路上跑得很快，便抓住了商机，创立了一家铁路公司，向跳蚤国王请示在每两个城市之间都修建铁路。<br />\n　　然而，由于小C不会扳道岔，火车到一个城市以后只能保证不原路返回，而会随机等概率地驶向与这个城市有铁路连接的另外一个城市。<br />\n　　跳蚤国王向广大居民征求意见，结果跳蚤们不太满意，因为这样修建铁路以后有可能只游览了3个城市（含出发的城市）以后就回来了，它们希望能多游览几个城市。于是跳蚤国王要求小C提供一个方案，使得每只跳蚤坐上火车后能多游览几个城市才回来。<br />\n<br />\n<br />\n　　小C提供了一种方案给跳蚤国王。跳蚤国王想知道这个方案中每个城市的居民旅游的期望时间（设火车经过每段铁路的时间都为1），请你来帮跳蚤国王。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含两个正整数n、m，其中n表示城市的数量，m表示方案中的铁路条数。<br />\n　　接下来m行，每行包含两个正整数u、v，表示方案中城市u和城市v之间有一条铁路。<br />\n　　保证方案中无重边无自环，每两个城市之间都能经过铁路直接或间接到达，且火车由任意一条铁路到任意一个城市以后一定有路可走。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出n行，第i行包含一个实数tBi，表示方案B中城市i的居民旅游的期望时间。你应当输出足够多的小数位数，以保证输出的值和真实值之间的绝对或相对误差不超过1e-9。</div><div class='pdsec'>样例输入</div><div class='pddata'>4 5<br />\n1 2<br />\n2 3<br />\n3 4<br />\n4 1<br />\n1 3</div><div class='pdsec'>样例输出</div><div class='pddata'>3.333333333333<br />\n5.000000000000<br />\n3.333333333333<br />\n5.000000000000</div><div class='pdsec'>样例输入</div><div class='pddata'>10 15<br />\n1 2<br />\n1 9<br />\n1 5<br />\n2 3<br />\n2 7<br />\n3 4<br />\n3 10<br />\n4 5<br />\n4 8<br />\n5 6<br />\n6 7<br />\n6 10<br />\n7 8<br />\n8 9<br />\n9 10</div><div class='pdsec'>样例输出</div><div class='pddata'>10.000000000000<br />\n10.000000000000<br />\n10.000000000000<br />\n10.000000000000<br />\n10.000000000000<br />\n10.000000000000<br />\n10.000000000000<br />\n10.000000000000<br />\n10.000000000000<br />\n10.000000000000</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于10%的测试点，n &lt;= 10；<br />\n　　对于20%的测试点，n &lt;= 12；<br />\n　　对于50%的测试点，n &lt;= 16；<br />\n　　对于70%的测试点，n &lt;= 19；<br />\n　　对于100%的测试点，4 &lt;= k &lt;= n &lt;= 21，1 &lt;= u, v &lt;= n。数据有梯度。</div>\n","gpid":"T455","lanqiaotitle":"观光铁路","memorylimit":"256.0MB","tid":"PREV-51","timelimit":"2.0s","title":"历届试题 观光铁路","src":"2017蓝桥杯决赛 C++B组第六题 JavaA组第六题"},{"checkpoint":"","updatetime":"2017-12-18","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　小明喜欢在一个围棋网站上找别人在线对弈。这个网站上所有注册用户都有一个积分，代表他的围棋水平。<br />\n<br />\n<br />\n　　小明发现网站的自动对局系统在匹配对手时，只会将积分差恰好是K的两名用户匹配在一起。如果两人分差小于或大于K，系统都不会将他们匹配。<br />\n<br />\n<br />\n　　现在小明知道这个网站总共有N名用户，以及他们的积分分别是A1, A2, ... AN。<br />\n<br />\n<br />\n　　小明想了解最多可能有多少名用户同时在线寻找对手，但是系统却一场对局都匹配不起来(任意两名用户积分差不等于K)？</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含两个个整数N和K。<br />\n　　第二行包含N个整数A1, A2, ... AN。<br />\n<br />\n<br />\n　　对于30%的数据，1 &lt;= N &lt;= 10<br />\n　　对于100%的数据，1 &lt;= N &lt;= 100000, 0 &lt;= Ai &lt;= 100000, 0 &lt;= K &lt;= 100000</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个整数，代表答案。</div><div class='pdsec'>样例输入</div><div class='pddata'>10 0<br />\n1 4 2 8 5 7 1 4 2 8</div><div class='pdsec'>样例输出</div><div class='pddata'>6</div>\n","gpid":"T454","lanqiaotitle":"对局匹配","memorylimit":"256.0MB","tid":"PREV-50","timelimit":"1.0s","title":"历届试题 对局匹配","src":"2017蓝桥杯决赛 C++B组第五题 JavaA组第五题"},{"checkpoint":"","updatetime":"2017-12-18","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　小明的实验室有N台电脑，编号1~N。原本这N台电脑之间有N-1条数据链接相连，恰好构成一个树形网络。在树形网络上，任意两台电脑之间有唯一的路径相连。<br />\n<br />\n<br />\n　　不过在最近一次维护网络时，管理员误操作使得某两台电脑之间增加了一条数据链接，于是网络中出现了环路。环路上的电脑由于两两之间不再是只有一条路径，使得这些电脑上的数据传输出现了BUG。<br />\n<br />\n<br />\n　　为了恢复正常传输。小明需要找到所有在环路上的电脑，你能帮助他吗？</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含一个整数N。<br />\n　　以下N行每行两个整数a和b，表示a和b之间有一条数据链接相连。<br />\n<br />\n<br />\n　　对于30%的数据，1 &lt;= N &lt;= 1000<br />\n　　对于100%的数据, 1 &lt;= N &lt;= 100000， 1 &lt;= a, b &lt;= N<br />\n<br />\n<br />\n　　输入保证合法。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　按从小到大的顺序输出在环路上的电脑的编号，中间由一个空格分隔。</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n1 2<br />\n3 1<br />\n2 4<br />\n2 5<br />\n5 3</div><div class='pdsec'>样例输出</div><div class='pddata'>1 2 3 5</div>\n","gpid":"T453","lanqiaotitle":"发现环","memorylimit":"256.0MB","tid":"PREV-49","timelimit":"1.0s","title":"历届试题 发现环","src":"2017蓝桥杯决赛 C++B组第四题 JavaA组第四题"},{"checkpoint":"","updatetime":"2017-12-18","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给出一个长度为 n 的数组 {A_i}，由 1 到 n 标号 ， 你需要维护 m 个操作。<br />\n　　操作分为三种，输入格式为：<br />\n<br />\n<br />\n　　1 l r d，将数组中下标 l 到 r 的位置都加上 d，即对于 l&lt;=i&lt;=r，执行A_i=A_i+d。<br />\n<br />\n<br />\n　　2 l_1 r_1 l_2 r_2，将数组中下标为 l_1 到 r_1 的位置，赋值成 l_2 到 r_2 的值，保证 r_1-l_1=r_2-l_2。<br />\n　　换句话说先对 0&lt;=i&lt;=r_2-l_2 执行 B_i=A_(l_2+i)，再对 0&lt;=i&lt;=r_1-l_1 执行 A_(l_1+i)=B_i，其中 {B_i} 为一个临时数组。<br />\n<br />\n<br />\n　　3 l r，求数组中下标 l 到 r 的位置的和，即求出 ∑_(i=l到r) A_i 。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　从标准输入读入数据。<br />\n　　第一行一个整数 Case，表示测试点编号，其中 Case=0 表示该点为样例。<br />\n　　第二行包含两个整数 n,m。保证 1&lt;=n,m&lt;=10^5。<br />\n　　第三行包含 n 个整数 A_i，表示这个数组的初值。保证 0&lt;=A_i&lt;=10^5。<br />\n　　接下来 m 每行描述一个操作，格式如问题描述所示。<br />\n　　对于操作中提到每个数，满足 0&lt;=d&lt;=10^5，1&lt;=l&lt;=r&lt;=n，1&lt;=l_1&lt;=r_1&lt;=n，1&lt;=l_2&lt;=r_2&lt;=n，r_1-l_1=r_2-l_2。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出到标准输出。<br />\n　　对于每次 3 操作输出一行一个数，表示求和的结果。</div><div class='pdsec'>样例输入</div><div class='pddata'>0<br />\n5 6<br />\n1 2 3 4 5<br />\n2 1 3 3 5<br />\n3 3 5<br />\n1 2 4 2<br />\n3 3 5<br />\n2 1 3 3 5<br />\n3 1 5</div><div class='pdsec'>样例输出</div><div class='pddata'>14<br />\n18<br />\n29</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'><table cellspacing=0 cellpadding=2px style='border-collapse:collapse;' class='table table-striped table-horver'><tbody><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>测试点<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>n,m<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>其他约束<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>1,2<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>&lt;=10^3<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>无<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>3,4<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>&lt;=10^5<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>没有2操作<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>5,6,7<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>&lt;=10^5<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>n 为偶数，且所有2操作满l_1=1,r_1=n/2  ,l_2=n/2+1,r_2=n<br />\n</td></tr><tr  style='border:solid 1.0pt'><td valign=\"top\" style='border:solid 1.0pt'>8,9,10<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>&lt;=10^5<br />\n</td><td valign=\"top\" style='border:solid 1.0pt'>无<br />\n</td></tr></tbody></table></div>\n","gpid":"T452","lanqiaotitle":"数组操作","memorylimit":"2.0GB","tid":"PREV-48","timelimit":"2.0s","title":"历届试题 数组操作","src":"2017蓝桥杯决赛 C++A组第六题"},{"checkpoint":"","updatetime":"2017-12-18","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　数轴上有<i>n</i>个闭区间<i>D</i><sub>1</sub>,…,<i>D<sub>n</sub></i>。其中区间<i>D<sub>i</sub></i>用一对整数[<i>a<sub>i</sub></i>, <i>b<sub>i</sub></i>]来描述，满足<i>a<sub>i</sub></i> &lt; <i>b<sub>i</sub></i>。已知这些区间的长度之和至少有10000。所以，通过适当的移动这些区间，你总可以使得他们的“并”覆盖[0, 10000]——也就是说[0, 10000]这个区间内的每一个点都落于至少一个区间内。<br />\n　　你希望找一个移动方法，使得位移差最大的那个区间的位移量最小。<br />\n　　具体来说，假设你将<i>D<sub>i</sub></i>移动到[<i>a<sub>i</sub></i>+<i>c<sub>i</sub></i>, <i>b<sub>i</sub></i>+<i>c<sub>i</sub></i>]这个位置。你希望使得max<i><sub>i</sub></i> |<i>c<sub>i</sub></i>|　　最小。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含一个整数n，表示区间的数量。<br />\n　　接下来有n行，每行2个整数a<sub>i</sub>,　　b<sub>i</sub>，以一个空格分开，表示区间[<i>a<sub>i</sub></i>, <i>b<sub>i</sub></i>]。保证区间的长度之和至少是10000。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个数，表示答案。如果答案是整数，只输出整数部分。如果答案不是整数，输出时四舍五入保留一位小数。</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n10 5010<br />\n4980 9980</div><div class='pdsec'>样例输出</div><div class='pddata'>20</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　第一个区间往左移动10；第二个区间往右移动20。</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\n0 4000<br />\n3000 5000<br />\n5001 8000<br />\n7000 10000</div><div class='pdsec'>样例输出</div><div class='pddata'>0.5</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　第2个区间往右移0.5；第3个区间往左移0.5即可。</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于30%的评测用例，1 ≤ <i>n</i> ≤ 10；<br />\n　　对于100%的评测用例，1 ≤ <i>n</i> ≤ 10000，0 ≤ <i>a<sub>i</sub></i> &lt; <i>b<sub>i</sub></i>　　≤ 10000。</div>\n","gpid":"T451","lanqiaotitle":"区间移位","memorylimit":"256.0MB","tid":"PREV-47","timelimit":"1.5s","title":"历届试题 区间移位","src":"2017蓝桥杯决赛 C++A组第五题 JavaB组第六题"},{"checkpoint":"","updatetime":"2017-12-18","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　小明经常玩 LOL 游戏上瘾，一次他想挑战K大师，不料K大师说：<br />\n　　“我们先来玩个空格填字母的游戏，要是你不能赢我，就再别玩LOL了”。<br />\n<br />\n<br />\n　　K大师在纸上画了一行n个格子，要小明和他交替往其中填入字母。<br />\n<br />\n<br />\n　　并且：<br />\n<br />\n<br />\n　　1. 轮到某人填的时候，只能在某个空格中填入L或O<br />\n　　2. 谁先让字母组成了“LOL”的字样，谁获胜。<br />\n　　3. 如果所有格子都填满了，仍无法组成LOL，则平局。<br />\n<br />\n<br />\n　　小明试验了几次都输了，他很惭愧，希望你能用计算机帮他解开这个谜。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行，数字n（n&lt;10），表示下面有n个初始局面。<br />\n　　接下来，n行，每行一个串，表示开始的局面。<br />\n　　比如：“******”, 表示有6个空格。“L****”,   表示左边是一个字母L，它的右边是4个空格。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　要求输出n个数字，表示对每个局面，如果小明先填，当K大师总是用最强着法的时候，小明的最好结果。<br />\n　　1 表示能赢<br />\n　　-1 表示必输<br />\n　　0 表示可以逼平</div><div class='pdsec'>样例输入</div><div class='pddata'>4<br />\n***<br />\nL**L<br />\nL**L***L<br />\nL*****L</div><div class='pdsec'>样例输出</div><div class='pddata'>0<br />\n-1<br />\n1<br />\n1</div>\n","gpid":"T450","lanqiaotitle":"填字母游戏","memorylimit":"256.0MB","tid":"PREV-46","timelimit":"1.0s","title":"历届试题 填字母游戏","src":"2017蓝桥杯决赛 C++A组第四题 JavaB组第五题"},{"checkpoint":"","updatetime":"2017-12-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　小明需要在一篇文档中加入 N 张图片，其中第 i 张图片的宽度是 Wi，高度是 Hi。<br />\n　　假设纸张的宽度是 M，小明使用的文档编辑工具会用以下方式对图片进行自动排版：<br />\n<br />\n<br />\n　　1. 该工具会按照图片顺序，在宽度 M 以内，将尽可能多的图片排在一行。该行的高度是行内最高的图片的高度。例如在 M=10 的纸张上依次打印 3x4, 2x2, 3x3 三张图片，则效果如下图所示，这一行高度为4。(分割线以上为列标尺，分割线以下为排版区域；数字组成的矩形为第x张图片占用的版面)<br />\n<img src=\"/RequireFile.do?fid=fRbHaHGh\" /><br />\n<br />\n　　2. 如果当前行剩余宽度大于0，并且小于下一张图片，则下一张图片会按比例缩放到宽度为当前行剩余宽度(高度向上取整)，然后放入当前行。例如再放入一张4x9的图片，由于剩余宽度是2，这张图片会被压缩到2x5，再被放入第一行的末尾。此时该行高度为5：<br />\n<img src=\"/RequireFile.do?fid=Egybm3aa\" /><br />\n<br />\n　　3. 如果当前行剩余宽度为0，该工具会从下一行开始继续对剩余的图片进行排版，直到所有图片都处理完毕。此时所有行的总高度和就是这 N 张图片的排版高度。例如再放入11x1, 5x5, 3x4 的图片后，效果如下图所示，总高度为11：<br />\n<img src=\"/RequireFile.do?fid=7YAGqg8q\" /><br />\n<br />\n<br />\n<br />\n　　现在由于排版高度过高，图片的先后顺序也不能改变，小明只好从 N 张图片中选择一张删除掉以降低总高度。他希望剩余N-1张图片按原顺序的排版高度最低，你能求出最低高度是多少么？</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含两个整数 M 和 N，分别表示纸张宽度和图片的数量。<br />\n　　接下来 N 行，每行2个整数Wi, Hi，表示第 i 个图大小为 Wi*Hi。<br />\n<br />\n<br />\n　　对于30%的数据，满足1&lt;=N&lt;=1000<br />\n　　对于100%的数据，满足1&lt;=N&lt;=100000，1&lt;=M, Wi, Hi&lt;=100</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个整数，表示在删除掉某一张图片之后，排版高度最少能是多少。</div><div class='pdsec'>样例输入</div><div class='pddata'>4 3<br />\n2 2<br />\n2 3<br />\n2 2</div><div class='pdsec'>样例输出</div><div class='pddata'>2</div><div class='pdsec'>样例输入</div><div class='pddata'>2 10<br />\n4 4<br />\n4 3<br />\n1 3<br />\n4 5<br />\n2 1<br />\n2 3<br />\n5 4<br />\n5 3<br />\n1 5<br />\n2 4</div><div class='pdsec'>样例输出</div><div class='pddata'>17</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　峰值内存消耗（含虚拟机） &lt; 256M<br />\n　　CPU消耗  &lt; 2000ms<br />\n<br />\n<br />\n<br />\n<br />\n　　请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。<br />\n<br />\n<br />\n　　注意：<br />\n　　main函数需要返回0;<br />\n　　只使用ANSI C/ANSI C++ 标准;<br />\n　　不要调用依赖于编译环境或操作系统的特殊函数。<br />\n　　所有依赖的函数必须明确地在源文件中 #include &lt;xxx&gt;<br />\n　　不能通过工程设置而省略常用头文件。<br />\n<br />\n<br />\n　　提交程序时，注意选择所期望的语言类型和编译器类型。</div>\n","gpid":"T449","lanqiaotitle":"图形排版","memorylimit":"256.0MB","tid":"PREV-45","timelimit":"2.0s","title":"历届试题 图形排版","src":"2017蓝桥杯省赛 C++C组第十题 JavaC组第十题"},{"checkpoint":"","updatetime":"2017-12-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　X星球的流行宠物是青蛙，一般有两种颜色：白色和黑色。<br />\n　　X星球的居民喜欢把它们放在一排茶杯里，这样可以观察它们跳来跳去。<br />\n　　如下图，有一排杯子，左边的一个是空着的，右边的杯子，每个里边有一只青蛙。<br />\n<br />\n<br />\n　　*WWWBBB<br />\n<br />\n<br />\n　　其中，W字母表示白色青蛙，B表示黑色青蛙，*表示空杯子。<br />\n<br />\n<br />\n　　X星的青蛙很有些癖好，它们只做3个动作之一：<br />\n　　1. 跳到相邻的空杯子里。<br />\n　　2. 隔着1只其它的青蛙（随便什么颜色）跳到空杯子里。<br />\n　　3. 隔着2只其它的青蛙（随便什么颜色）跳到空杯子里。<br />\n<br />\n<br />\n　　对于上图的局面，只要1步，就可跳成下图局面：<br />\n<br />\n<br />\n　　WWW*BBB<br />\n<br />\n<br />\n　　本题的任务就是已知初始局面，询问至少需要几步，才能跳成另一个目标局面。<br />\n<br />\n<br />\n　　输入为2行，2个串，表示初始局面和目标局面。<br />\n　　输出要求为一个整数，表示至少需要多少步的青蛙跳。</div><div class='pdsec'>样例输入</div><div class='pddata'>*WWBB<br />\nWWBB*</div><div class='pdsec'>样例输出</div><div class='pddata'>2</div><div class='pdsec'>样例输入</div><div class='pddata'>WWW*BBB<br />\nBBB*WWW</div><div class='pdsec'>样例输出</div><div class='pddata'>10</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　我们约定，输入的串的长度不超过15<br />\n<br />\n<br />\n　　资源约定：<br />\n　　峰值内存消耗（含虚拟机） &lt; 256M<br />\n　　CPU消耗  &lt; 1000ms<br />\n<br />\n<br />\n<br />\n<br />\n　　请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。<br />\n<br />\n<br />\n　　所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。<br />\n　　不要使用package语句。不要使用jdk1.7及以上版本的特性。<br />\n　　主类的名字必须是：Main，否则按无效代码处理。<br />\n<br />\n<br />\n　　----------------------------<br />\n<br />\n<br />\n　　笨笨有话说：<br />\n　　我梦见自己是一棵大树，<br />\n　　青蛙跳跃，<br />\n　　我就发出新的枝条，<br />\n　　春风拂动那第 5 层的新枝,<br />\n　　哦，我已是枝繁叶茂。</div>\n","gpid":"T448","lanqiaotitle":"青蛙跳杯子","memorylimit":"256.0MB","tid":"PREV-44","timelimit":"1.0s","title":"历届试题 青蛙跳杯子","src":"2017蓝桥杯省赛 JavaC组第九题"},{"checkpoint":"","updatetime":"2017-12-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　小的时候，你玩过纸牌游戏吗？<br />\n　　有一种叫做“拉马车”的游戏，规则很简单，却很吸引小朋友。<br />\n<br />\n<br />\n　　其规则简述如下：<br />\n　　假设参加游戏的小朋友是A和B，游戏开始的时候，他们得到的随机的纸牌序列如下：<br />\n　　A方：[K, 8, X, K, A, 2, A, 9, 5, A]<br />\n　　B方：[2, 7, K, 5, J, 5, Q, 6, K, 4]<br />\n<br />\n<br />\n　　其中的X表示“10”，我们忽略了纸牌的花色。<br />\n<br />\n<br />\n　　从A方开始，A、B双方轮流出牌。<br />\n<br />\n<br />\n　　当轮到某一方出牌时，他从自己的纸牌队列的头部拿走一张，放到桌上，并且压在最上面一张纸牌上（如果有的话）。<br />\n<br />\n<br />\n　　此例中，游戏过程：<br />\n　　A出K，B出2，A出8，B出7，A出X，此时桌上的序列为：<br />\n<br />\n<br />\n　　K,2,8,7,X<br />\n<br />\n<br />\n　　当轮到B出牌时，他的牌K与桌上的纸牌序列中的K相同，则把包括K在内的以及两个K之间的纸牌都赢回来，放入自己牌的队尾。注意：为了操作方便，放入牌的顺序是与桌上的顺序相反的。<br />\n　　此时，A、B双方的手里牌为：<br />\n　　A方：[K, A, 2, A, 9, 5, A]<br />\n　　B方：[5, J, 5, Q, 6, K, 4, K, X, 7, 8, 2, K]<br />\n<br />\n<br />\n　　赢牌的一方继续出牌。也就是B接着出5，A出K，B出J，A出A，B出5，又赢牌了。<br />\n　　5,K,J,A,5<br />\n　　此时双方手里牌：<br />\n　　A方：[2, A, 9, 5, A]<br />\n　　B方：[Q, 6, K, 4, K, X, 7, 8, 2, K, 5, A, J, K, 5]<br />\n<br />\n<br />\n　　注意：更多的时候赢牌的一方并不能把桌上的牌都赢走，而是拿走相同牌点及其中间的部分。但无论如何，都是赢牌的一方继续出牌，有的时候刚一出牌又赢了，也是允许的。<br />\n<br />\n<br />\n　　当某一方出掉手里最后一张牌，但无法从桌面上赢取牌时，游戏立即结束。<br />\n<br />\n<br />\n　　对于本例的初始手牌情况下，最后A会输掉，而B最后的手里牌为：<br />\n<br />\n<br />\n　　9K2A62KAX58K57KJ5<br />\n<br />\n<br />\n　　本题的任务就是已知双方初始牌序，计算游戏结束时，赢的一方手里的牌序。当游戏无法结束时，输出-1。<br />\n<br />\n<br />\n　　输入为2行，2个串，分别表示A、B双方初始手里的牌序列。<br />\n　　输出为1行，1个串，表示A先出牌，最后赢的一方手里的牌序。</div><div class='pdsec'>样例输入</div><div class='pddata'>96J5A898QA<br />\n6278A7Q973</div><div class='pdsec'>样例输出</div><div class='pddata'>2J9A7QA6Q6889977</div><div class='pdsec'>样例输入</div><div class='pddata'>25663K6X7448<br />\nJ88A5KJXX45A</div><div class='pdsec'>样例输出</div><div class='pddata'>6KAJ458KXAX885XJ645</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　我们约定，输入的串的长度不超过30<br />\n<br />\n<br />\n　　资源约定：<br />\n　　峰值内存消耗（含虚拟机） &lt; 256M<br />\n　　CPU消耗  &lt; 1000ms<br />\n<br />\n<br />\n<br />\n<br />\n　　请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。<br />\n<br />\n<br />\n　　注意：<br />\n　　main函数需要返回0;<br />\n　　只使用ANSI C/ANSI C++ 标准;<br />\n　　不要调用依赖于编译环境或操作系统的特殊函数。<br />\n　　所有依赖的函数必须明确地在源文件中 #include &lt;xxx&gt;<br />\n　　不能通过工程设置而省略常用头文件。<br />\n<br />\n<br />\n　　提交程序时，注意选择所期望的语言类型和编译器类型。<br />\n<br />\n<br />\n　　----------------------------<br />\n<br />\n　　笨笨有话说：<br />\n　　不断删除前边的，又要后边添加.... 如果用数组，需要开一个大点的，请佛祖保佑在游戏结束前，不会用到数组的边缘。<br />\n<br />\n<br />\n　　歪歪有话说：<br />\n　　反正串也不长，不如每次操作都返回一个新的串。<br />\n<br />\n<br />\n　　默默有话说：<br />\n　　我一般都不吱声，这是典型的队列结构，动态数组最好，没有？自己造一个呗！</div>\n","gpid":"T447","lanqiaotitle":"拉马车","memorylimit":"256.0MB","tid":"PREV-43","timelimit":"1.0s","title":"历届试题 拉马车","src":"2017蓝桥杯省赛 C++C组第九题 JavaC组第八题"},{"checkpoint":"","updatetime":"2017-12-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　小明最近在教邻居家的小朋友小学奥数，而最近正好讲述到了三阶幻方这个部分，三阶幻方指的是将1~9不重复的填入一个3*3的矩阵当中，使得每一行、每一列和每一条对角线的和都是相同的。<br />\n<br />\n　　三阶幻方又被称作九宫格，在小学奥数里有一句非常有名的口诀：“二四为肩，六八为足，左三右七，戴九履一，五居其中”，通过这样的一句口诀就能够非常完美的构造出一个九宫格来。<br />\n<br />\n　　4 9 2<br />\n　　3 5 7<br />\n　　8 1 6<br />\n<br />\n<br />\n　　有意思的是，所有的三阶幻方，都可以通过这样一个九宫格进行若干镜像和旋转操作之后得到。现在小明准备将一个三阶幻方（不一定是上图中的那个）中的一些数抹掉，交给邻居家的小朋友来进行还原，并且希望她能够判断出究竟是不是只有一个解。<br />\n<br />\n　　而你呢，也被小明交付了同样的任务，但是不同的是，你需要写一个程序~</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入仅包含单组测试数据。<br />\n　　每组测试数据为一个3*3的矩阵，其中为0的部分表示被小明抹去的部分。<br />\n　　对于100%的数据，满足给出的矩阵至少能还原出一组可行的三阶幻方。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　如果仅能还原出一组可行的三阶幻方，则将其输出，否则输出“Too Many”（不包含引号）。</div><div class='pdsec'>样例输入</div><div class='pddata'>0 7 2<br />\n0 5 0<br />\n0 3 0</div><div class='pdsec'>样例输出</div><div class='pddata'>6 7 2<br />\n1 5 9<br />\n8 3 4</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　峰值内存消耗（含虚拟机） &lt; 256M<br />\n　　CPU消耗  &lt; 1000ms<br />\n<br />\n<br />\n<br />\n<br />\n　　请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。<br />\n<br />\n<br />\n　　注意：<br />\n　　main函数需要返回0;<br />\n　　只使用ANSI C/ANSI C++ 标准;<br />\n　　不要调用依赖于编译环境或操作系统的特殊函数。<br />\n　　所有依赖的函数必须明确地在源文件中 #include &lt;xxx&gt;<br />\n　　不能通过工程设置而省略常用头文件。<br />\n<br />\n<br />\n　　提交程序时，注意选择所期望的语言类型和编译器类型。<br />\n<br />\n<br />\n　　--------------<br />\n<br />\n<br />\n　　笨笨有话说：<br />\n　　我最喜欢这类题目了。既然九宫幻方一共也没有多少，我就不辞辛劳地一个一个写出来好了。<br />\n　　也不能太过分，好歹用个数组。</div>\n","gpid":"T446","lanqiaotitle":"九宫幻方","memorylimit":"256.0MB","tid":"PREV-42","timelimit":"1.0s","title":"历届试题 九宫幻方","src":"2017蓝桥杯省赛 C++C组第八题"},{"checkpoint":"","updatetime":"2017-12-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　Excel单元格的地址表示很有趣，它使用字母来表示列号。<br />\n　　比如，<br />\n　　A表示第1列，<br />\n　　B表示第2列，<br />\n　　Z表示第26列，<br />\n　　AA表示第27列，<br />\n　　AB表示第28列，<br />\n　　BA表示第53列，<br />\n　　....<br />\n<br />\n<br />\n　　当然Excel的最大列号是有限度的，所以转换起来不难。<br />\n　　如果我们想把这种表示法一般化，可以把很大的数字转换为很长的字母序列呢？<br />\n<br />\n<br />\n　　本题目即是要求对输入的数字, 输出其对应的Excel地址表示方式。</div><div class='pdsec'>样例输入</div><div class='pddata'>26</div><div class='pdsec'>样例输出</div><div class='pddata'>Z</div><div class='pdsec'>样例输入</div><div class='pddata'>2054</div><div class='pdsec'>样例输出</div><div class='pddata'>BZZ</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　我们约定，输入的整数范围[1,2147483647]<br />\n<br />\n<br />\n　　峰值内存消耗（含虚拟机） &lt; 256M<br />\n　　CPU消耗  &lt; 1000ms<br />\n<br />\n<br />\n<br />\n<br />\n　　请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。<br />\n<br />\n<br />\n　　注意：<br />\n　　main函数需要返回0;<br />\n　　只使用ANSI C/ANSI C++ 标准;<br />\n　　不要调用依赖于编译环境或操作系统的特殊函数。<br />\n　　所有依赖的函数必须明确地在源文件中 #include &lt;xxx&gt;<br />\n　　不能通过工程设置而省略常用头文件。<br />\n<br />\n<br />\n　　提交程序时，注意选择所期望的语言类型和编译器类型。<br />\n<br />\n<br />\n　　------------------------------<br />\n<br />\n<br />\n　　笨笨有话说：<br />\n　　这有点像进制关系，又不完全是。好像末2位是以1当26，末3位是以1当26*26<br />\n<br />\n<br />\n　　歪歪有话说：<br />\n　　要是从字母序列转数字还好点，倒过来有点麻烦，不过计算机跑得快啊。</div>\n","gpid":"T445","lanqiaotitle":"Excel地址","memorylimit":"256.0MB","tid":"PREV-41","timelimit":"1.0s","title":"历届试题 Excel地址","src":"2017蓝桥杯省赛 C++C组第七题 JavaC组第七题"},{"checkpoint":"","updatetime":"2017-12-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个长度为N的数列，A1, A2, ... AN，如果其中一段连续的子序列Ai, Ai+1, ... Aj(i &lt;= j)之和是K的倍数，我们就称这个区间[i, j]是K倍区间。<br />\n<br />\n<br />\n　　你能求出数列中总共有多少个K倍区间吗？</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含两个整数N和K。(1 &lt;= N, K &lt;= 100000)<br />\n　　以下N行每行包含一个整数Ai。(1 &lt;= Ai &lt;= 100000)</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个整数，代表K倍区间的数目。</div><div class='pdsec'>样例输入</div><div class='pddata'>5 2<br />\n1<br />\n2<br />\n3<br />\n4<br />\n5</div><div class='pdsec'>样例输出</div><div class='pddata'>6</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　峰值内存消耗（含虚拟机） &lt; 256M<br />\n　　CPU消耗  &lt; 2000ms<br />\n<br />\n<br />\n<br />\n<br />\n　　请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。<br />\n<br />\n<br />\n　　注意：<br />\n　　main函数需要返回0;<br />\n　　只使用ANSI C/ANSI C++ 标准;<br />\n　　不要调用依赖于编译环境或操作系统的特殊函数。<br />\n　　所有依赖的函数必须明确地在源文件中 #include &lt;xxx&gt;<br />\n　　不能通过工程设置而省略常用头文件。<br />\n<br />\n<br />\n　　提交程序时，注意选择所期望的语言类型和编译器类型。</div>\n","gpid":"T444","lanqiaotitle":"k倍区间","memorylimit":"256.0MB","tid":"PREV-40","timelimit":"2.0s","title":"历届试题 k倍区间","src":"2017蓝桥杯省赛 C++B组第十题 JavaB组第十题"},{"checkpoint":"","updatetime":"2017-12-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　小明正在整理一批历史文献。这些历史文献中出现了很多日期。小明知道这些日期都在1960年1月1日至2059年12月31日。令小明头疼的是，这些日期采用的格式非常不统一，有采用年/月/日的，有采用月/日/年的，还有采用日/月/年的。更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。<br />\n<br />\n<br />\n　　比如02/03/04，可能是2002年03月04日、2004年02月03日或2004年03月02日。<br />\n<br />\n<br />\n　　给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一个日期，格式是\"AA/BB/CC\"。  (0 &lt;= A, B, C &lt;= 9)</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出若干个不相同的日期，每个日期一行，格式是\"yyyy-MM-dd\"。多个日期按从早到晚排列。</div><div class='pdsec'>样例输入</div><div class='pddata'>02/03/04</div><div class='pdsec'>样例输出</div><div class='pddata'>2002-03-04<br />\n2004-02-03<br />\n2004-03-02</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　峰值内存消耗（含虚拟机） &lt; 256M<br />\n　　CPU消耗  &lt; 1000ms<br />\n<br />\n<br />\n<br />\n<br />\n　　请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。<br />\n<br />\n<br />\n　　注意：<br />\n　　main函数需要返回0;<br />\n　　只使用ANSI C/ANSI C++ 标准;<br />\n　　不要调用依赖于编译环境或操作系统的特殊函数。<br />\n　　所有依赖的函数必须明确地在源文件中 #include &lt;xxx&gt;<br />\n　　不能通过工程设置而省略常用头文件。<br />\n<br />\n<br />\n　　提交程序时，注意选择所期望的语言类型和编译器类型。</div>\n","gpid":"T443","lanqiaotitle":"日期问题","memorylimit":"256.0MB","tid":"PREV-39","timelimit":"1.0s","title":"历届试题 日期问题","src":"2017蓝桥杯省赛 C++B组第七题 JavaB组第七题"},{"checkpoint":"","updatetime":"2017-12-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　X星球的一批考古机器人正在一片废墟上考古。<br />\n　　该区域的地面坚硬如石、平整如镜。<br />\n　　管理人员为方便，建立了标准的直角坐标系。<br />\n<br />\n<br />\n　　每个机器人都各有特长、身怀绝技。它们感兴趣的内容也不相同。<br />\n　　经过各种测量，每个机器人都会报告一个或多个矩形区域，作为优先考古的区域。<br />\n<br />\n<br />\n　　矩形的表示格式为(x1,y1,x2,y2)，代表矩形的两个对角点坐标。<br />\n<br />\n<br />\n　　为了醒目，总部要求对所有机器人选中的矩形区域涂黄色油漆。<br />\n　　小明并不需要当油漆工，只是他需要计算一下，一共要耗费多少油漆。<br />\n<br />\n<br />\n　　其实这也不难，只要算出所有矩形覆盖的区域一共有多大面积就可以了。<br />\n　　注意，各个矩形间可能重叠。<br />\n<br />\n<br />\n　　本题的输入为若干矩形，要求输出其覆盖的总面积。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行，一个整数n，表示有多少个矩形(1&lt;=n&lt;10000)<br />\n　　接下来的n行，每行有4个整数x1 y1 x2 y2，空格分开，表示矩形的两个对角顶点坐标。<br />\n　　(0&lt;= x1,y1,x2,y2 &lt;=10000)</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一行一个整数，表示矩形覆盖的总面积面积。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n1 5 10 10<br />\n3 1 20 20<br />\n2 7 15 17</div><div class='pdsec'>样例输出</div><div class='pddata'>340</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n5 2 10 6<br />\n2 7 12 10<br />\n8 1 15 15</div><div class='pdsec'>样例输出</div><div class='pddata'>128</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　峰值内存消耗（含虚拟机） &lt; 256M<br />\n　　CPU消耗  &lt; 2000ms<br />\n<br />\n<br />\n<br />\n<br />\n　　请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。<br />\n<br />\n<br />\n　　注意：<br />\n　　main函数需要返回0;<br />\n　　只使用ANSI C/ANSI C++ 标准;<br />\n　　不要调用依赖于编译环境或操作系统的特殊函数。<br />\n　　所有依赖的函数必须明确地在源文件中 #include &lt;xxx&gt;<br />\n　　不能通过工程设置而省略常用头文件。<br />\n<br />\n<br />\n　　提交程序时，注意选择所期望的语言类型和编译器类型。</div>\n","gpid":"T442","lanqiaotitle":"油漆面积","memorylimit":"256.0MB","tid":"PREV-38","timelimit":"2.0s","title":"历届试题 油漆面积","src":"2017蓝桥杯省赛 C++A组第十题 JavaA组第十题"},{"checkpoint":"","updatetime":"2017-12-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　儿童节那天有K位小朋友到小明家做客。小明拿出了珍藏的巧克力招待小朋友们。<br />\n　　小明一共有N块巧克力，其中第i块是Hi x Wi的方格组成的长方形。<br />\n<br />\n<br />\n　　为了公平起见，小明需要从这 N 块巧克力中切出K块巧克力分给小朋友们。切出的巧克力需要满足：<br />\n<br />\n<br />\n　　1. 形状是正方形，边长是整数<br />\n　　2. 大小相同<br />\n<br />\n<br />\n　　例如一块6x5的巧克力可以切出6块2x2的巧克力或者2块3x3的巧克力。<br />\n<br />\n<br />\n　　当然小朋友们都希望得到的巧克力尽可能大，你能帮小Hi计算出最大的边长是多少么？</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含两个整数N和K。(1 &lt;= N, K &lt;= 100000)<br />\n　　以下N行每行包含两个整数Hi和Wi。(1 &lt;= Hi, Wi &lt;= 100000)<br />\n　　输入保证每位小朋友至少能获得一块1x1的巧克力。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出切出的正方形巧克力最大可能的边长。</div><div class='pdsec'>样例输入</div><div class='pddata'>2 10<br />\n6 5<br />\n5 6</div><div class='pdsec'>样例输出</div><div class='pddata'>2</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　峰值内存消耗（含虚拟机） &lt; 256M<br />\n　　CPU消耗  &lt; 1000ms<br />\n<br />\n<br />\n<br />\n<br />\n　　请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。<br />\n<br />\n<br />\n　　注意：<br />\n　　main函数需要返回0;<br />\n　　只使用ANSI C/ANSI C++ 标准;<br />\n　　不要调用依赖于编译环境或操作系统的特殊函数。<br />\n　　所有依赖的函数必须明确地在源文件中 #include &lt;xxx&gt;<br />\n　　不能通过工程设置而省略常用头文件。<br />\n<br />\n<br />\n　　提交程序时，注意选择所期望的语言类型和编译器类型。</div>\n","gpid":"T441","lanqiaotitle":"分巧克力","memorylimit":"256.0MB","tid":"PREV-37","timelimit":"1.0s","title":"历届试题 分巧克力","src":"2017蓝桥杯省赛 C++A组第九题 C++B组第九题 JavaA组第九题 JavaB组第九题"},{"checkpoint":"","updatetime":"2017-12-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　小明几乎每天早晨都会在一家包子铺吃早餐。他发现这家包子铺有N种蒸笼，其中第i种蒸笼恰好能放Ai个包子。每种蒸笼都有非常多笼，可以认为是无限笼。<br />\n<br />\n<br />\n　　每当有顾客想买X个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有X个包子。比如一共有3种蒸笼，分别能放3、4和5个包子。当顾客想买11个包子时，大叔就会选2笼3个的再加1笼5个的（也可能选出1笼3个的再加2笼4个的）。<br />\n<br />\n<br />\n　　当然有时包子大叔无论如何也凑不出顾客想买的数量。比如一共有3种蒸笼，分别能放4、5和6个包子。而顾客想买7个包子时，大叔就凑不出来了。<br />\n<br />\n<br />\n　　小明想知道一共有多少种数目是包子大叔凑不出来的。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行包含一个整数N。(1 &lt;= N &lt;= 100)<br />\n　　以下N行每行包含一个整数Ai。(1 &lt;= Ai &lt;= 100)</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　一个整数代表答案。如果凑不出的数目有无限多个，输出INF。</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n4<br />\n5</div><div class='pdsec'>样例输出</div><div class='pddata'>6</div><div class='pdsec'>样例输入</div><div class='pddata'>2<br />\n4<br />\n6</div><div class='pdsec'>样例输出</div><div class='pddata'>INF</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　对于样例1，凑不出的数目包括：1, 2, 3, 6, 7, 11。<br />\n　　对于样例2，所有奇数都凑不出来，所以有无限多个。</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　峰值内存消耗（含虚拟机） &lt; 256M<br />\n　　CPU消耗  &lt; 1000ms<br />\n<br />\n<br />\n<br />\n<br />\n　　请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。<br />\n<br />\n<br />\n　　注意：<br />\n　　main函数需要返回0;<br />\n　　只使用ANSI C/ANSI C++ 标准;<br />\n　　不要调用依赖于编译环境或操作系统的特殊函数。<br />\n　　所有依赖的函数必须明确地在源文件中 #include &lt;xxx&gt;<br />\n　　不能通过工程设置而省略常用头文件。<br />\n<br />\n<br />\n　　提交程序时，注意选择所期望的语言类型和编译器类型。</div>\n","gpid":"T440","lanqiaotitle":"包子凑数","memorylimit":"256.0MB","tid":"PREV-36","timelimit":"1.0s","title":"历届试题 包子凑数","src":"2017蓝桥杯省赛 C++A组第八题 C++B组第八题 JavaA组第八题 JavaB组第八题"},{"checkpoint":"","updatetime":"2017-12-17","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　考虑一种简单的正则表达式：<br />\n　　只由 x ( ) | 组成的正则表达式。<br />\n　　小明想求出这个正则表达式能接受的最长字符串的长度。<br />\n<br />\n<br />\n　　例如 ((xx|xxx)x|(x|xx))xx 能接受的最长字符串是： xxxxxx，长度是6。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一个由x()|组成的正则表达式。输入长度不超过100，保证合法。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　这个正则表达式能接受的最长字符串的长度。</div><div class='pdsec'>样例输入</div><div class='pddata'>((xx|xxx)x|(x|xx))xx</div><div class='pdsec'>样例输出</div><div class='pddata'>6</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　峰值内存消耗（含虚拟机） &lt; 256M<br />\n　　CPU消耗  &lt; 1000ms<br />\n<br />\n<br />\n<br />\n<br />\n　　请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。<br />\n<br />\n<br />\n　　注意：<br />\n　　main函数需要返回0;<br />\n　　只使用ANSI C/ANSI C++ 标准;<br />\n　　不要调用依赖于编译环境或操作系统的特殊函数。<br />\n　　所有依赖的函数必须明确地在源文件中 #include &lt;xxx&gt;<br />\n　　不能通过工程设置而省略常用头文件。<br />\n<br />\n<br />\n　　提交程序时，注意选择所期望的语言类型和编译器类型。</div>\n","gpid":"T439","lanqiaotitle":"正则问题","memorylimit":"256.0MB","tid":"PREV-35","timelimit":"1.0s","title":"历届试题 正则问题","src":"2017蓝桥杯省赛 C++A组第七题 JavaA组第七题"},{"checkpoint":"","updatetime":"2014-03-25","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　小明先把硬币摆成了一个 n 行 m 列的矩阵。<br />\n<br />\n　　随后，小明对每一个硬币分别进行一次 Q 操作。<br />\n<br />\n　　对第x行第y列的硬币进行 Q 操作的定义：将所有第 i*x 行，第 j*y 列的硬币进行翻转。<br />\n<br />\n　　其中i和j为任意使操作可行的正整数，行号和列号都是从1开始。<br />\n<br />\n　　当小明对所有硬币都进行了一次 Q 操作后，他发现了一个奇迹——所有硬币均为正面朝上。<br />\n<br />\n　　小明想知道最开始有多少枚硬币是反面朝上的。于是，他向他的好朋友小M寻求帮助。<br />\n<br />\n　　聪明的小M告诉小明，只需要对所有硬币再进行一次Q操作，即可恢复到最开始的状态。然而小明很懒，不愿意照做。于是小明希望你给出他更好的方法。帮他计算出答案。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入数据包含一行，两个正整数 n m，含义见题目描述。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个正整数，表示最开始有多少枚硬币是反面朝上的。</div><div class='pdsec'>样例输入</div><div class='pddata'>2 3</div><div class='pdsec'>样例输出</div><div class='pddata'>1</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于10%的数据，n、m &lt;= 10^3；<br />\n　　对于20%的数据，n、m &lt;= 10^7；<br />\n　　对于40%的数据，n、m &lt;= 10^15；<br />\n　　对于10%的数据，n、m &lt;= 10^1000（10的1000次方）。</div>\n","gpid":"T126","lanqiaotitle":"矩阵翻硬币","memorylimit":"256.0MB","tid":"PREV-34","timelimit":"1.0s","title":"历届试题 矩阵翻硬币","src":""},{"checkpoint":"","updatetime":"2014-03-25","content":"<div class='pdsec'>问题描述</div><div class='pdcont'><img src=\"/RequireFile.do?fid=YJrfYLeN\" width=\"354\" height=\"355\" /><br />\n<br />\n　　兰顿蚂蚁，是于1986年，由克里斯·兰顿提出来的，属于细胞自动机的一种。<br />\n<br />\n　　平面上的正方形格子被填上黑色或白色。在其中一格正方形内有一只“蚂蚁”。<br />\n　　蚂蚁的头部朝向为：上下左右其中一方。<br />\n<br />\n　　蚂蚁的移动规则十分简单：<br />\n　　若蚂蚁在黑格，右转90度，将该格改为白格，并向前移一格；<br />\n　　若蚂蚁在白格，左转90度，将该格改为黑格，并向前移一格。<br />\n<br />\n　　规则虽然简单，蚂蚁的行为却十分复杂。刚刚开始时留下的路线都会有接近对称，像是会重复，但不论起始状态如何，蚂蚁经过漫长的混乱活动后，会开辟出一条规则的“高速公路”。<br />\n<br />\n　　蚂蚁的路线是很难事先预测的。<br />\n<br />\n　　你的任务是根据初始状态，用计算机模拟兰顿蚂蚁在第n步行走后所处的位置。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入数据的第一行是 m n 两个整数（3 &lt; m, n &lt; 100），表示正方形格子的行数和列数。<br />\n　　接下来是 m 行数据。<br />\n　　每行数据为 n 个被空格分开的数字。0 表示白格，1 表示黑格。<br />\n<br />\n　　接下来是一行数据：x y s k, 其中x y为整数，表示蚂蚁所在行号和列号（行号从上到下增长，列号从左到右增长，都是从0开始编号）。s 是一个大写字母，表示蚂蚁头的朝向，我们约定：上下左右分别用：UDLR表示。k 表示蚂蚁走的步数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出数据为两个空格分开的整数 p q, 分别表示蚂蚁在k步后，所处格子的行号和列号。</div><div class='pdsec'>样例输入</div><div class='pddata'>5 6<br />\n0 0 0 0 0 0<br />\n0 0 0 0 0 0<br />\n0 0 1 0 0 0<br />\n0 0 0 0 0 0<br />\n0 0 0 0 0 0<br />\n2 3 L 5</div><div class='pdsec'>样例输出</div><div class='pddata'>1 3</div><div class='pdsec'>样例输入</div><div class='pddata'>3 3<br />\n0 0 0<br />\n1 1 1<br />\n1 1 1<br />\n1 1 U 6</div><div class='pdsec'>样例输出</div><div class='pddata'>0 0</div>\n","gpid":"T125","lanqiaotitle":"兰顿蚂蚁","memorylimit":"256.0MB","tid":"PREV-33","timelimit":"1.0s","title":"历届试题 兰顿蚂蚁","src":""},{"checkpoint":"","updatetime":"2014-03-25","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　有n个小朋友围坐成一圈。老师给每个小朋友随机发偶数个糖果，然后进行下面的游戏：<br />\n<br />\n　　每个小朋友都把自己的糖果分一半给左手边的孩子。<br />\n<br />\n　　一轮分糖后，拥有奇数颗糖的孩子由老师补给1个糖果，从而变成偶数。<br />\n<br />\n　　反复进行这个游戏，直到所有小朋友的糖果数都相同为止。<br />\n<br />\n　　你的任务是预测在已知的初始糖果情形下，老师一共需要补发多少个糖果。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　程序首先读入一个整数N(2&lt;N&lt;100)，表示小朋友的人数。<br />\n　　接着是一行用空格分开的N个偶数（每个偶数不大于1000，不小于2）</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　要求程序输出一个整数，表示老师需要补发的糖果数。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n2 2 4</div><div class='pdsec'>样例输出</div><div class='pddata'>4</div>\n","gpid":"T124","lanqiaotitle":"分糖果","memorylimit":"256.0MB","tid":"PREV-32","timelimit":"1.0s","title":"历届试题 分糖果","src":""},{"checkpoint":"","updatetime":"2014-03-25","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　n 个小朋友站成一排。现在要把他们按身高从低到高的顺序排列，但是每次只能交换位置相邻的两个小朋友。<br />\n<br />\n　　每个小朋友都有一个不高兴的程度。开始的时候，所有小朋友的不高兴程度都是0。<br />\n<br />\n　　如果某个小朋友第一次被要求交换，则他的不高兴程度增加1，如果第二次要求他交换，则他的不高兴程度增加2（即不高兴程度为3），依次类推。当要求某个小朋友第k次交换时，他的不高兴程度增加k。<br />\n<br />\n　　请问，要让所有小朋友按从低到高排队，他们的不高兴程度之和最小是多少。<br />\n<br />\n　　如果有两个小朋友身高一样，则他们谁站在谁前面是没有关系的。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含一个整数n，表示小朋友的个数。<br />\n　　第二行包含 n 个整数 H1 H2 … Hn，分别表示每个小朋友的身高。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行，包含一个整数，表示小朋友的不高兴程度和的最小值。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n3 2 1</div><div class='pdsec'>样例输出</div><div class='pddata'>9</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　首先交换身高为3和2的小朋友，再交换身高为3和1的小朋友，再交换身高为2和1的小朋友，每个小朋友的不高兴程度都是3，总和为9。</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于10%的数据， 1&lt;=n&lt;=10；<br />\n　　对于30%的数据， 1&lt;=n&lt;=1000；<br />\n　　对于50%的数据， 1&lt;=n&lt;=10000；<br />\n　　对于100%的数据，1&lt;=n&lt;=100000，0&lt;=Hi&lt;=1000000。</div>\n","gpid":"T123","lanqiaotitle":"小朋友排队","memorylimit":"256.0MB","tid":"PREV-31","timelimit":"1.0s","title":"历届试题 小朋友排队","src":""},{"checkpoint":"","updatetime":"2014-03-25","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　观察这个数列：<br />\n　　1 3 0 2 -1 1 -2 ...<br />\n<br />\n　　这个数列中后一项总是比前一项增加2或者减少3。<br />\n<br />\n　　栋栋对这种数列很好奇，他想知道长度为 n 和为 s 而且后一项总是比前一项增加a或者减少b的整数数列可能有多少种呢？</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含四个整数 n s a b，含义如前面说述。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行，包含一个整数，表示满足条件的方案数。由于这个数很大，请输出方案数除以100000007的余数。</div><div class='pdsec'>样例输入</div><div class='pddata'>4 10 2 3</div><div class='pdsec'>样例输出</div><div class='pddata'>2</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　这两个数列分别是2 4 1 3和7 4 1 -2。</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于10%的数据，1&lt;=n&lt;=5，0&lt;=s&lt;=5，1&lt;=a,b&lt;=5；<br />\n　　对于30%的数据，1&lt;=n&lt;=30，0&lt;=s&lt;=30，1&lt;=a,b&lt;=30；<br />\n　　对于50%的数据，1&lt;=n&lt;=50，0&lt;=s&lt;=50，1&lt;=a,b&lt;=50；<br />\n　　对于70%的数据，1&lt;=n&lt;=100，0&lt;=s&lt;=500，1&lt;=a, b&lt;=50；<br />\n　　对于100%的数据，1&lt;=n&lt;=1000，-1,000,000,000&lt;=s&lt;=1,000,000,000，1&lt;=a, b&lt;=1,000,000。</div>\n","gpid":"T122","lanqiaotitle":"波动数列","memorylimit":"256.0MB","tid":"PREV-30","timelimit":"1.0s","title":"历届试题 波动数列","src":""},{"checkpoint":"","updatetime":"2014-03-25","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　斐波那契数列大家都非常熟悉。它的定义是：<br />\n<br />\n　　f(x) = 1                    .... (x=1,2)<br />\n　　f(x) = f(x-1) + f(x-2)      .... (x&gt;2)<br />\n<br />\n　　对于给定的整数 n 和 m，我们希望求出：<br />\n　　f(1) + f(2) + ... + f(n)  的值。但这个值可能非常大，所以我们把它对 f(m) 取模。<br />\n　　公式如下<br />\n<img src=\"/RequireFile.do?fid=hyry39mn\" width=\"302\" height=\"78\" /><br />\n<br />\n　　但这个数字依然很大，所以需要再对 p 求模。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入为一行用空格分开的整数 n m p (0 &lt; n, m, p &lt; 10^18)</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出为1个整数，表示答案</div><div class='pdsec'>样例输入</div><div class='pddata'>2 3 5</div><div class='pdsec'>样例输出</div><div class='pddata'>0</div><div class='pdsec'>样例输入</div><div class='pddata'>15 11 29</div><div class='pdsec'>样例输出</div><div class='pddata'>25</div>\n","gpid":"T121","lanqiaotitle":"斐波那契","memorylimit":"256.0MB","tid":"PREV-29","timelimit":"1.0s","title":"历届试题 斐波那契","src":""},{"checkpoint":"","updatetime":"2014-03-25","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　X 国王有一个地宫宝库。是 n x m 个格子的矩阵。每个格子放一件宝贝。每个宝贝贴着价值标签。<br />\n<br />\n　　地宫的入口在左上角，出口在右下角。<br />\n<br />\n　　小明被带到地宫的入口，国王要求他只能向右或向下行走。<br />\n<br />\n　　走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。<br />\n<br />\n　　当小明走到出口时，如果他手中的宝贝恰好是k件，则这些宝贝就可以送给小明。<br />\n<br />\n　　请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这k件宝贝。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入一行3个整数，用空格分开：n m k (1&lt;=n,m&lt;=50, 1&lt;=k&lt;=12)<br />\n<br />\n　　接下来有 n 行数据，每行有 m 个整数 Ci (0&lt;=Ci&lt;=12)代表这个格子上的宝物的价值</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　要求输出一个整数，表示正好取k个宝贝的行动方案数。该数字可能很大，输出它对 1000000007 取模的结果。</div><div class='pdsec'>样例输入</div><div class='pddata'>2 2 2<br />\n1 2<br />\n2 1</div><div class='pdsec'>样例输出</div><div class='pddata'>2</div><div class='pdsec'>样例输入</div><div class='pddata'>2 3 2<br />\n1 2 3<br />\n2 1 5</div><div class='pdsec'>样例输出</div><div class='pddata'>14</div>\n","gpid":"T120","lanqiaotitle":"地宫取宝","memorylimit":"256.0MB","tid":"PREV-28","timelimit":"1.0s","title":"历届试题 地宫取宝","src":""},{"checkpoint":"","updatetime":"2014-03-25","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　长100厘米的细长直杆子上有n只蚂蚁。它们的头有的朝左，有的朝右。<br />\n<br />\n　　每只蚂蚁都只能沿着杆子向前爬，速度是1厘米/秒。<br />\n<br />\n　　当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。<br />\n<br />\n　　这些蚂蚁中，有1只蚂蚁感冒了。并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。<br />\n<br />\n　　请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　第一行输入一个整数n (1 &lt; n &lt; 50), 表示蚂蚁的总数。<br />\n<br />\n　　接着的一行是n个用空格分开的整数 Xi (-100 &lt; Xi &lt; 100), Xi的绝对值，表示蚂蚁离开杆子左边端点的距离。正值表示头朝右，负值表示头朝左，数据中不会出现0值，也不会出现两只蚂蚁占用同一位置。其中，第一个数据代表的蚂蚁感冒了。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　要求输出1个整数，表示最后感冒蚂蚁的数目。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n5 -2 8</div><div class='pdsec'>样例输出</div><div class='pddata'>1</div><div class='pdsec'>样例输入</div><div class='pddata'>5<br />\n-10 8 -20 12 25</div><div class='pdsec'>样例输出</div><div class='pddata'>3</div>\n","gpid":"T119","lanqiaotitle":"蚂蚁感冒","memorylimit":"256.0MB","tid":"PREV-27","timelimit":"1.0s","title":"历届试题 蚂蚁感冒","src":""},{"checkpoint":"","updatetime":"2014-03-25","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　给定一个n*m的矩阵A，求A中的一个非空子矩阵，使这个子矩阵中的元素和最大。<br />\n<br />\n　　其中，A的子矩阵指在A中行和列均连续的一块。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含两个整数n, m，分别表示矩阵A的行数和列数。<br />\n　　接下来n行，每行m个整数，表示矩阵A。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行，包含一个整数，表示A中最大的子矩阵中的元素和。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 3<br />\n-1 -4 3<br />\n3 4 -1<br />\n-5 -2 8</div><div class='pdsec'>样例输出</div><div class='pddata'>10</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　取最后一列，和为10。</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于50%的数据，1&lt;=n, m&lt;=50；<br />\n　　对于100%的数据，1&lt;=n, m&lt;=500，A中每个元素的绝对值不超过5000。</div>\n","gpid":"T118","lanqiaotitle":"最大子阵","memorylimit":"256.0MB","tid":"PREV-26","timelimit":"1.0s","title":"历届试题 最大子阵","src":""},{"checkpoint":"","updatetime":"2014-03-25","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　栋栋居住在一个繁华的C市中，然而，这个城市的道路大都年久失修。市长准备重新修一些路以方便市民，于是找到了栋栋，希望栋栋能帮助他。<br />\n<br />\n　　C市中有n个比较重要的地点，市长希望这些地点重点被考虑。现在可以修一些道路来连接其中的一些地点，每条道路可以连接其中的两个地点。另外由于C市有一条河从中穿过，也可以在其中的一些地点建设码头，所有建了码头的地点可以通过河道连接。<br />\n<br />\n　　栋栋拿到了允许建设的道路的信息，包括每条可以建设的道路的花费，以及哪些地点可以建设码头和建设码头的花费。<br />\n<br />\n　　市长希望栋栋给出一个方案，使得任意两个地点能只通过新修的路或者河道互达，同时花费尽量小。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含两个整数n, m，分别表示C市中重要地点的个数和可以建设的道路条数。所有地点从1到n依次编号。<br />\n　　接下来m行，每行三个整数a, b, c，表示可以建设一条从地点a到地点b的道路，花费为c。若c为正，表示建设是花钱的，如果c为负，则表示建设了道路后还可以赚钱（比如建设收费道路）。<br />\n　　接下来一行，包含n个整数w_1, w_2, …, w_n。如果w_i为正数，则表示在地点i建设码头的花费，如果w_i为-1，则表示地点i无法建设码头。<br />\n　　输入保证至少存在一个方法使得任意两个地点能只通过新修的路或者河道互达。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行，包含一个整数，表示使得所有地点通过新修道路或者码头连接的最小花费。如果满足条件的情况下还能赚钱，那么你应该输出一个负数。</div><div class='pdsec'>样例输入</div><div class='pddata'>5 5<br />\n1 2 4<br />\n1 3 -1<br />\n2 3 3<br />\n2 4 5<br />\n4 5 10<br />\n-1 10 10 1 1</div><div class='pdsec'>样例输出</div><div class='pddata'>9</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　建设第2、3、4条道路，在地点4、5建设码头，总的花费为9。</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于20%的数据，1&lt;=n&lt;=10，1&lt;=m&lt;=20，0&lt;=c&lt;=20，w_i&lt;=20；<br />\n　　对于50%的数据，1&lt;=n&lt;=100，1&lt;=m&lt;=1000，-50&lt;=c&lt;=50，w_i&lt;=50；<br />\n　　对于70%的数据，1&lt;=n&lt;=1000；<br />\n　　对于100%的数据，1 &lt;= n &lt;= 10000，1 &lt;= m &lt;= 100000，-1000&lt;=c&lt;=1000，-1&lt;=w_i&lt;=1000，w_i≠0。</div>\n","gpid":"T117","lanqiaotitle":"城市建设","memorylimit":"256.0MB","tid":"PREV-25","timelimit":"1.0s","title":"历届试题 城市建设","src":""},{"checkpoint":"","updatetime":"2014-03-25","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　C村住着n户村民，由于交通闭塞，C村的村民只能通过信件与外界交流。为了方便村民们发信，C村打算在C村建设k个邮局，这样每户村民可以去离自己家最近的邮局发信。<br />\n<br />\n　　现在给出了m个备选的邮局，请从中选出k个来，使得村民到自己家最近的邮局的距离和最小。其中两点之间的距离定义为两点之间的直线距离。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含三个整数n, m, k，分别表示村民的户数、备选的邮局数和要建的邮局数。<br />\n　　接下来n行，每行两个整数x, y，依次表示每户村民家的坐标。<br />\n　　接下来m行，每行包含两个整数x, y，依次表示每个备选邮局的坐标。<br />\n　　在输入中，村民和村民、村民和邮局、邮局和邮局的坐标可能相同，但你应把它们看成不同的村民或邮局。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行，包含k个整数，从小到大依次表示你选择的备选邮局编号。（备选邮局按输入顺序由1到m编号）</div><div class='pdsec'>样例输入</div><div class='pddata'>5 4 2<br />\n0 0<br />\n2 0<br />\n3 1<br />\n3 3<br />\n1 1<br />\n0 1<br />\n1 0<br />\n2 1<br />\n3 2</div><div class='pdsec'>样例输出</div><div class='pddata'>2 4</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于30%的数据，1&lt;=n&lt;=10，1&lt;=m&lt;=10，1&lt;=k&lt;=5；<br />\n　　对于60%的数据，1&lt;=m&lt;=20；<br />\n　　对于100%的数据，1&lt;=n&lt;=50，1&lt;=m&lt;=25，1&lt;=k&lt;=10。</div>\n","gpid":"T116","lanqiaotitle":"邮局","memorylimit":"256.0MB","tid":"PREV-24","timelimit":"1.0s","title":"历届试题 邮局","src":""},{"checkpoint":"","updatetime":"2014-03-25","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　栋栋正在和同学们玩一个数字游戏。<br />\n<br />\n　　游戏的规则是这样的：栋栋和同学们一共n个人围坐在一圈。栋栋首先说出数字1。接下来，坐在栋栋左手边的同学要说下一个数字2。再下面的一个同学要从上一个同学说的数字往下数两个数说出来，也就是说4。下一个同学要往下数三个数，说7。依次类推。<br />\n<br />\n　　为了使数字不至于太大，栋栋和同学们约定，当在心中数到 k-1 时，下一个数字从0开始数。例如，当k=13时，栋栋和同学们报出的前几个数依次为：<br />\n　　1, 2, 4, 7, 11, 3, 9, 3, 11, 7。<br />\n<br />\n　　游戏进行了一会儿，栋栋想知道，到目前为止，他所有说出的数字的总和是多少。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含三个整数 n,k,T，其中 n 和 k 的意义如上面所述，T 表示到目前为止栋栋一共说出的数字个数。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一行，包含一个整数，表示栋栋说出所有数的和。</div><div class='pdsec'>样例输入</div><div class='pddata'>3 13 3</div><div class='pdsec'>样例输出</div><div class='pddata'>17</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　栋栋说出的数依次为1, 7, 9，和为17。</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　1 &lt; n,k,T &lt; 1,000,000；</div>\n","gpid":"T115","lanqiaotitle":"数字游戏","memorylimit":"256.0MB","tid":"PREV-23","timelimit":"1.0s","title":"历届试题 数字游戏","src":""},{"checkpoint":"","updatetime":"2014-03-25","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　C国由n个小岛组成，为了方便小岛之间联络，C国在小岛间建立了m座大桥，每座大桥连接两座小岛。两个小岛间可能存在多座桥连接。然而，由于海水冲刷，有一些大桥面临着不能使用的危险。<br />\n<br />\n　　如果两个小岛间的所有大桥都不能使用，则这两座小岛就不能直接到达了。然而，只要这两座小岛的居民能通过其他的桥或者其他的小岛互相到达，他们就会安然无事。但是，如果前一天两个小岛之间还有方法可以到达，后一天却不能到达了，居民们就会一起抗议。<br />\n<br />\n　　现在C国的国王已经知道了每座桥能使用的天数，超过这个天数就不能使用了。现在他想知道居民们会有多少天进行抗议。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含两个整数n, m，分别表示小岛的个数和桥的数量。<br />\n　　接下来m行，每行三个整数a, b, t，分别表示该座桥连接a号和b号两个小岛，能使用t天。小岛的编号从1开始递增。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个整数，表示居民们会抗议的天数。</div><div class='pdsec'>样例输入</div><div class='pddata'>4 4<br />\n1 2 2<br />\n1 3 2<br />\n2 3 1<br />\n3 4 3</div><div class='pdsec'>样例输出</div><div class='pddata'>2</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　第一天后2和3之间的桥不能使用，不影响。<br />\n　　第二天后1和2之间，以及1和3之间的桥不能使用，居民们会抗议。<br />\n　　第三天后3和4之间的桥不能使用，居民们会抗议。</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于30%的数据，1&lt;=n&lt;=20，1&lt;=m&lt;=100；<br />\n　　对于50%的数据，1&lt;=n&lt;=500，1&lt;=m&lt;=10000；<br />\n　　对于100%的数据，1&lt;=n&lt;=10000，1&lt;=m&lt;=100000，1&lt;=a, b&lt;=n， 1&lt;=t&lt;=100000。</div>\n","gpid":"T114","lanqiaotitle":"国王的烦恼","memorylimit":"256.0MB","tid":"PREV-22","timelimit":"1.0s","title":"历届试题 国王的烦恼","src":""},{"checkpoint":"","updatetime":"2014-03-25","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　观察数字：12321，123321 都有一个共同的特征，无论从左到右读还是从右向左读，都是相同的。这样的数字叫做：回文数字。<br />\n<br />\n　　本题要求你找到一些5位或6位的十进制数字。满足如下要求：<br />\n　　该数字的各个数位之和等于输入的整数。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　一个正整数 n (10&lt;n&lt;100), 表示要求满足的数位和。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　若干行，每行包含一个满足要求的5位或6位整数。<br />\n　　数字按从小到大的顺序排列。<br />\n　　如果没有满足条件的，输出：-1</div><div class='pdsec'>样例输入</div><div class='pddata'>44</div><div class='pdsec'>样例输出</div><div class='pddata'>99899<br />\n499994<br />\n589985<br />\n598895<br />\n679976<br />\n688886<br />\n697796<br />\n769967<br />\n778877<br />\n787787<br />\n796697<br />\n859958<br />\n868868<br />\n877778<br />\n886688<br />\n895598<br />\n949949<br />\n958859<br />\n967769<br />\n976679<br />\n985589<br />\n994499</div><div class='pdsec'>样例输入</div><div class='pddata'>60</div><div class='pdsec'>样例输出</div><div class='pddata'>-1</div>\n","gpid":"T113","lanqiaotitle":"回文数字","memorylimit":"256.0MB","tid":"PREV-21","timelimit":"1.0s","title":"历届试题 回文数字","src":""},{"checkpoint":"组合数学","updatetime":"2013-10-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　输入n, m, k，输出下面公式的值。<br />\n<img src=\"/RequireFile.do?fid=FJ9YqBGE\" width=\"317\" height=\"129\" /><br />\n　　其中C_n^m是组合数，表示在n个人的集合中选出m个人组成一个集合的方案数。组合数的计算公式如下。<br />\n<img src=\"/RequireFile.do?fid=TEm3EGfy\" width=\"1160\" height=\"112\" /></div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含一个整数n；第二行包含一个整数m，第三行包含一个整数k。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　计算上面公式的值，由于答案非常大，请输出这个值除以999101的余数。</div><div class='pdsec'>样例输入</div><div class='pddata'>3<br />\n1<br />\n3</div><div class='pdsec'>样例输出</div><div class='pddata'>162</div><div class='pdsec'>样例输入</div><div class='pddata'>20<br />\n10<br />\n10</div><div class='pdsec'>样例输出</div><div class='pddata'>359316</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于10%的数据，n≤10，k≤3；<br />\n　　对于20%的数据，n≤20，k≤3；<br />\n　　对于30%的数据，n≤1000，k≤5；<br />\n　　对于40%的数据，n≤10^7，k≤10；<br />\n　　对于60%的数据，n≤10^15，k ≤100；<br />\n　　对于70%的数据，n≤10^100，k≤200；<br />\n　　对于80%的数据，n≤10^500，k ≤500；<br />\n　　对于100%的数据，n在十进制下不超过1000位，即1≤n&lt;10^1000，1≤k≤1000，同时0≤m≤n，k≤n。</div><div class='pdsec'>提示</div><div class='pdcont'>　　999101是一个质数；<br />\n　　当n位数比较多时，绝大多数情况下答案都是0，但评测的时候会选取一些答案不是0的数据；</div>\n","gpid":"T43","lanqiaotitle":"公式求值","memorylimit":"256.0MB","tid":"PREV-20","timelimit":"1.0s","title":"历届试题 公式求值","src":""},{"checkpoint":"搜索","updatetime":"2013-10-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　如下面第一个图的九宫格中，放着 1~8 的数字卡片，还有一个格子空着。与空格子相邻的格子中的卡片可以移动到空格中。经过若干次移动，可以形成第二个图所示的局面。<br />\n<img src=\"/RequireFile.do?fid=qYebaGed\" width=\"236\" height=\"245\" /><img src=\"/RequireFile.do?fid=HQ3JFM72\" width=\"236\" height=\"245\" /><br />\n　　我们把第一个图的局面记为：12345678.<br />\n　　把第二个图的局面记为：123.46758<br />\n　　显然是按从上到下，从左到右的顺序记录数字，空格记为句点。<br />\n　　本题目的任务是已知九宫的初态和终态，求最少经过多少步的移动可以到达。如果无论多少步都无法到达，则输出-1。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入第一行包含九宫的初态，第二行包含九宫的终态。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出最少的步数，如果不存在方案，则输出-1。</div><div class='pdsec'>样例输入</div><div class='pddata'>12345678.<br />\n123.46758</div><div class='pdsec'>样例输出</div><div class='pddata'>3</div><div class='pdsec'>样例输入</div><div class='pddata'>13524678.<br />\n46758123.</div><div class='pdsec'>样例输出</div><div class='pddata'>22</div>\n","gpid":"T42","lanqiaotitle":"九宫重排","memorylimit":"256.0MB","tid":"PREV-19","timelimit":"1.0s","title":"历届试题 九宫重排","src":""},{"checkpoint":"计算几何","updatetime":"2013-10-21","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　栋栋每天骑自行车回家需要经过一条狭长的林荫道。道路由于年久失修，变得非常不平整。虽然栋栋每次都很颠簸，但他仍把骑车经过林荫道当成一种乐趣。<br />\n　　由于颠簸，栋栋骑车回家的路径是一条上下起伏的曲线，栋栋想知道，他回家的这条曲线的长度究竟是多长呢？更准确的，栋栋想知道从林荫道的起点到林荫道的终点，他的车前轮的轴（圆心）经过的路径的长度。<br />\n　　栋栋对路面进行了测量。他把道路简化成一条条长短不等的直线段，这些直线段首尾相连，且位于同一平面内。并在该平面内建立了一个直角坐标系，把所有线段的端点坐标都计算好。<br />\n　　假设栋栋的自行车在行进的过程中前轮一直是贴着路面前进的。<br />\n<br />\n<img src=\"/RequireFile.do?fid=tAMBefqe\" width=\"512\" height=\"256\" /><br />\n　　上图给出了一个简单的路面的例子，其中蓝色实线为路面，红色虚线为车轮轴经过的路径。在这个例子中，栋栋的前轮轴从A点出发，水平走到B点，然后绕着地面的F点到C点（绕出一个圆弧），再沿直线下坡到D点，最后水平走到E点，在这个图中地面的坐标依次为：(0, 0), (2, 0), (4, -1), (6, -1)，前轮半径为1.50，前轮轴前进的距离依次为：<br />\n　　AB=2.0000；弧长BC=0.6955；CD=1.8820；DE=1.6459。<br />\n　　总长度为6.2233。<br />\n<br />\n　　下图给出了一个较为复杂的路面的例子，在这个例子中，车轮在第一个下坡还没下完时（D点）就开始上坡了，之后在坡的顶点要从E绕一个较大的圆弧到F点。这个图中前轮的半径为1，每一段的长度依次为：<br />\n　　AB=3.0000；弧长BC=0.9828；CD=1.1913；DE=2.6848；弧长EF=2.6224；    FG=2.4415；GH=2.2792。<br />\n　　总长度为15.2021。<br />\n<img src=\"/RequireFile.do?fid=jQtyey68\" width=\"680\" height=\"400\" /><br />\n　　现在给出了车轮的半径和路面的描述，请求出车轮轴轨迹的总长度。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入的第一行包含一个整数n和一个实数r，用一个空格分隔，表示描述路面的坐标点数和车轮的半径。<br />\n　　接下来n行，每个包含两个实数，其中第i行的两个实数x[i], y[i]表示描述路面的第i个点的坐标。<br />\n　　路面定义为所有路面坐标点顺次连接起来的折线。给定的路面的一定满足以下性质：<br />\n<br />\n　　*第一个坐标点一定是(0, 0)；<br />\n　　*第一个点和第二个点的纵坐标相同；<br />\n　　*倒数第一个点和倒数第二个点的纵坐标相同；<br />\n　　*第一个点和第二个点的距离不少于车轮半径；<br />\n　　*倒数第一个点和倒数第二个点的的距离不少于车轮半径；<br />\n　　*后一个坐标点的横坐标大于前一个坐标点的横坐标，即对于所有的i，x[i+1]&gt;x[i]。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出一个实数，四舍五入保留两个小数，表示车轮轴经过的总长度。<br />\n　　你的结果必须和参考答案一模一样才能得分。数据保证答案精确值的小数点后第三位不是4或5。</div><div class='pdsec'>样例输入</div><div class='pddata'>4 1.50<br />\n0.00 0.00<br />\n2.00 0.00<br />\n4.00 -1.00<br />\n6.00 -1.00</div><div class='pdsec'>样例输出</div><div class='pddata'>6.22</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　这个样例对应第一个图。</div><div class='pdsec'>样例输入</div><div class='pddata'>6 1.00<br />\n0.00 0.00<br />\n3.00 0.00<br />\n5.00 -3.00<br />\n6.00 2.00<br />\n7.00 -1.00<br />\n10.00 -1.00</div><div class='pdsec'>样例输出</div><div class='pddata'>15.20</div><div class='pdsec'>样例说明</div><div class='pdcont'>　　这个样例对应第二个图</div><div class='pdsec'>数据规模和约定</div><div class='pdcont'>　　对于20%的数据，n=4；<br />\n　　对于40%的数据，n≤10；<br />\n　　对于100%的数据，4≤n≤100，0.5≤r≤20.0，x[i] ≤2000.0，-2000.0≤y[i] ≤2000.0。</div>\n","gpid":"T41","lanqiaotitle":"车轮轴迹","memorylimit":"256.0MB","tid":"PREV-18","timelimit":"1.0s","title":"历届试题 车轮轴迹","src":""},{"checkpoint":"博弈论","updatetime":"2013-10-20","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　闲暇时，福尔摩斯和华生玩一个游戏：<br />\n　　在N张卡片上写有N个整数。两人轮流拿走一张卡片。要求下一个人拿的数字一定是前一个人拿的数字的约数或倍数。例如，某次福尔摩斯拿走的卡片上写着数字“6”，则接下来华生可以拿的数字包括：<br />\n　　1，2，3, 6，12，18，24 ....<br />\n　　当轮到某一方拿卡片时，没有满足要求的卡片可选，则该方为输方。<br />\n　　请你利用计算机的优势计算一下，在已知所有卡片上的数字和可选哪些数字的条件下，怎样选择才能保证必胜！<br />\n　　当选多个数字都可以必胜时，输出其中最小的数字。如果无论如何都会输，则输出-1。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入数据为2行。第一行是若干空格分开的整数（每个整数介于1~100间），表示当前剩余的所有卡片。<br />\n　　第二行也是若干空格分开的整数，表示可以选的数字。当然，第二行的数字必须完全包含在第一行的数字中。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　程序则输出必胜的招法！！</div><div class='pdsec'>样例输入</div><div class='pddata'>2 3 6<br />\n3 6</div><div class='pdsec'>样例输出</div><div class='pddata'>3</div><div class='pdsec'>样例输入</div><div class='pddata'>1 2 2 3 3 4 5<br />\n3 4 5</div><div class='pdsec'>样例输出</div><div class='pddata'>4</div>\n","gpid":"T40","lanqiaotitle":"约数倍数选卡片","memorylimit":"256.0MB","tid":"PREV-17","timelimit":"1.0s","title":"历届试题 约数倍数选卡片","src":""},{"checkpoint":"计算几何","updatetime":"2013-10-20","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　X星球十分特殊，它的自转速度与公转速度相同，所以阳光总是以固定的角度照射。<br />\n　　最近，X星球为发展星际旅游业，把空间位置出租给Y国游客来晒太阳。每个租位是漂浮在空中的圆盘形彩云（圆盘与地面平行）。当然，这会遮挡住部分阳光，被遮挡的土地植物无法生长。<br />\n　　本题的任务是计算某个农场宜于作物生长的土地面积有多大。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入数据的第一行包含两个整数a, b，表示某农场的长和宽分别是a和b，此时，该农场的范围是由坐标(0, 0, 0), (a, 0, 0), (a, b, 0), (0, b, 0)围成的矩形区域。<br />\n　　第二行包含一个实数g，表示阳光照射的角度。简单起见，我们假设阳光光线是垂直于农场的宽的，此时正好和农场的长的夹角是g度，此时，空间中的一点(x, y, z)在地面的投影点应该是(x + z * ctg(g度), y, 0)，其中ctg(g度)表示g度对应的余切值。<br />\n　　第三行包含一个非负整数n，表示空中租位个数。<br />\n　　接下来 n 行，描述每个租位。其中第i行包含4个整数xi, yi, zi, ri，表示第i个租位彩云的圆心在(xi, yi, zi)位置，圆半径为ri。</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　要求输出一个实数，四舍五入保留两位有效数字，表示农场里能长庄稼的土地的面积。</div><div class='pdsec'>样例输入</div><div class='pddata'>10 10<br />\n90.0<br />\n1<br />\n5 5 10 5</div><div class='pdsec'>样例输出</div><div class='pddata'>21.46</div><div class='pdsec'>样例输入</div><div class='pddata'>8 8<br />\n90.0<br />\n1<br />\n4 4 10 5</div><div class='pdsec'>样例输出</div><div class='pddata'>1.81</div><div class='pdsec'>样例输入</div><div class='pddata'>20 10<br />\n45.0<br />\n2<br />\n5 0 5 5<br />\n8 6 14 6</div><div class='pdsec'>样例输出</div><div class='pddata'>130.15</div>\n","gpid":"T39","lanqiaotitle":"农场阳光","memorylimit":"256.0MB","tid":"PREV-16","timelimit":"1.0s","title":"历届试题 农场阳光","src":""},{"checkpoint":"动态规划","updatetime":"2013-10-20","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　X国的一段古城墙的顶端可以看成 2*N个格子组成的矩形（如下图所示），现需要把这些格子刷上保护漆。<br />\n<br />\n<img src=\"/RequireFile.do?fid=HLt96rLF\" width=\"439\" height=\"234\" /><br />\n　　你可以从任意一个格子刷起，刷完一格，可以移动到和它相邻的格子（对角相邻也算数），但不能移动到较远的格子（因为油漆未干不能踩！）<br />\n　　比如：a d b c e f 就是合格的刷漆顺序。<br />\n　　c e f d a b 是另一种合适的方案。<br />\n　　当已知 N 时，求总的方案数。当N较大时，结果会迅速增大，请把结果对 1000000007 (十亿零七) 取模。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入数据为一个正整数（不大于1000）</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出数据为一个正整数。</div><div class='pdsec'>样例输入</div><div class='pddata'>2</div><div class='pdsec'>样例输出</div><div class='pddata'>24</div><div class='pdsec'>样例输入</div><div class='pddata'>3</div><div class='pdsec'>样例输出</div><div class='pddata'>96</div><div class='pdsec'>样例输入</div><div class='pddata'>22</div><div class='pdsec'>样例输出</div><div class='pddata'>359635897</div>\n","gpid":"T38","lanqiaotitle":"格子刷油漆","memorylimit":"256.0MB","tid":"PREV-15","timelimit":"1.0s","title":"历届试题 格子刷油漆","src":""},{"checkpoint":"博弈论","updatetime":"2013-10-20","content":"<div class='pdsec'>问题描述</div><div class='pdcont'>　　古时丧葬活动中经常请高僧做法事。仪式结束后，有时会有“高僧斗法”的趣味节目，以舒缓压抑的气氛。<br />\n　　节目大略步骤为：先用粮食（一般是稻米）在地上“画”出若干级台阶（表示N级浮屠）。又有若干小和尚随机地“站”在某个台阶上。最高一级台阶必须站人，其它任意。(如图1所示)<br />\n　　两位参加游戏的法师分别指挥某个小和尚向上走任意多级的台阶，但会被站在高级台阶上的小和尚阻挡，不能越过。两个小和尚也不能站在同一台阶，也不能向低级台阶移动。<br />\n　　两法师轮流发出指令，最后所有小和尚必然会都挤在高段台阶，再也不能向上移动。轮到哪个法师指挥时无法继续移动，则游戏结束，该法师认输。<br />\n　　对于已知的台阶数和小和尚的分布位置，请你计算先发指令的法师该如何决策才能保证胜出。</div><div class='pdsec'>输入格式</div><div class='pdcont'>　　输入数据为一行用空格分开的N个整数，表示小和尚的位置。台阶序号从1算起，所以最后一个小和尚的位置即是台阶的总数。（N&lt;100, 台阶总数&lt;1000）</div><div class='pdsec'>输出格式</div><div class='pdcont'>　　输出为一行用空格分开的两个整数: A B, 表示把A位置的小和尚移动到B位置。若有多个解，输出A值较小的解，若无解则输出-1。</div><div class='pdsec'>样例输入</div><div class='pddata'>1 5 9</div><div class='pdsec'>样例输出</div><div class='pddata'>1 4</div><div class='pdsec'>样例输入</div><div class='pddata'>1 5 8 10</div><div class='pdsec'>样例输出</div><div class='pddata'>1 3</div>\n","gpid":"T37","lanqiaotitle":"高僧斗法","memorylimit":"256.0MB","tid":"PREV-14","timelimit":"1.0s","title":"历届试题 高僧斗法","src":""},{"checkpoint":"构图","updatetime":"2013-10-20","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n\n<p>X 国的一个网络使用若干条线路连接若干个节点。节点间的通信是双向的。某重要数据包，为了安全起见，必须恰好被转发两次到达目的地。该包可能在任意一个节点产生，我们需要知道该网络中一共有多少种不同的转发路径。</p>\n<p>源地址和目标地址可以相同，但中间节点必须不同。</p>\n<p>如下图所示的网络。</p>\n<p><img src=\"/RequireFile.do?fid=JBf444aT\" width=\"502\" height=\"376\" alt=\"\" /></p>\n<p>1 -&gt; 2 -&gt; 3 -&gt; 1  是允许的</p>\n<p>1 -&gt; 2 -&gt; 1 -&gt; 2 或者 1 -&gt; 2 -&gt; 3 -&gt; 2 都是非法的。</p>\n\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\n<p>输入数据的第一行为两个整数N M，分别表示节点个数和连接线路的条数(1&lt;=N&lt;=10000; 0&lt;=M&lt;=100000)。</p>\n<p>接下去有M行，每行为两个整数 u 和 v，表示节点u 和 v 联通(1&lt;=u,v&lt;=N , u!=v)。</p>\n<p>输入数据保证任意两点最多只有一条边连接，并且没有自己连自己的边，即不存在重边和自环。</p>\n\n</div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\n    输出一个整数，表示满足要求的路径条数。\n\n</div>\n<div class=\"sec_header\">\n样例输入1</div>\n<div class=\"sec_text\">\n3 3<br />\n1 2<br />\n2 3<br />\n1 3\n</div>\n<div class=\"sec_header\">\n样例输出1</div>\n<div class=\"sec_text\">\n6\n\t</div>\n<div class=\"sec_header\">\n样例输入2</div>\n<div class=\"sec_text\">\n4 4<br />\n1 2<br />\n2 3<br />\n3 1<br />\n1 4\n</div>\n<div class=\"sec_header\">\n样例输出2</div>\n<div class=\"sec_text\">\n10\n\t</div>","gpid":"T36","lanqiaotitle":"网络寻路","memorylimit":"256.0MB","tid":"PREV-13","timelimit":"1.0s","title":"历届试题 网络寻路","src":""},{"checkpoint":"割点","updatetime":"2013-10-20","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n\n<p>抗日战争时期，冀中平原的地道战曾发挥重要作用。</p>\n<p>地道的多个站点间有通道连接，形成了庞大的网络。但也有隐患，当敌人发现了某个站点后，其它站点间可能因此会失去联系。</p>\n<p>我们来定义一个危险系数DF(x,y)：</p>\n<p>对于两个站点x和y (x != y), 如果能找到一个站点z，当z被敌人破坏后，x和y不连通，那么我们称z为关于x,y的关键点。相应的，对于任意一对站点x和y，危险系数DF(x,y)就表示为这两点之间的关键点个数。</p>\n<p>本题的任务是：已知网络结构，求两站点之间的危险系数。</p>\n\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\n<p>输入数据第一行包含2个整数n(2 &lt;= n &lt;= 1000), m(0 &lt;= m &lt;= 2000),分别代表站点数，通道数；</p>\n<p>接下来m行，每行两个整数 u,v (1 &lt;= u, v &lt;= n; u != v)代表一条通道；</p>\n<p>最后1行，两个数u,v，代表询问两点之间的危险系数DF(u, v)。</p>\n\n</div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\n一个整数，如果询问的两点不连通则输出-1.\n\n</div>\n<div class=\"sec_header\">\n样例输入</div>\n<div class=\"sec_text\">\n7 6<br />\n1 3<br />\n2 3<br />\n3 4<br />\n3 5<br />\n4 5<br />\n5 6<br />\n1 6\n\n</div>\n<div class=\"sec_header\">\n样例输出</div>\n<div class=\"sec_text\">\n2\n\t</div>","gpid":"T35","lanqiaotitle":"危险系数","memorylimit":"256.0MB","tid":"PREV-12","timelimit":"1.0s","title":"历届试题 危险系数","src":""},{"checkpoint":"排序二叉树","updatetime":"2013-10-20","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n\n<p>二叉树可以用于排序。其原理很简单：对于一个排序二叉树添加新节点时，先与根节点比较，若小则交给左子树继续处理，否则交给右子树。</p>\n<p>当遇到空子树时，则把该节点放入那个位置。 </p>\n<p>比如，10 8 5 7 12 4 的输入顺序，应该建成二叉树如下图所示，其中.表示空白。</p> \n<div class=\"sec_text\">\n...|-12<br />\n10-|<br />\n...|-8-|<br />\n.......|...|-7<br />\n.......|-5-|<br />\n...........|-4\n</div>\n<p>本题目要求：根据已知的数字，建立排序二叉树，并在标准输出中横向打印该二叉树。 </p>\n\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\n<p>输入数据为一行空格分开的N个整数。 N&lt;100，每个数字不超过10000。</p>\n<p>输入数据中没有重复的数字。 </p>\n\n</div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\n<p>输出该排序二叉树的横向表示。为了便于评卷程序比对空格的数目，请把空格用句点代替：</p>\n\n</div>\n<div class=\"sec_header\">\n样例输入1</div>\n<div class=\"sec_text\">\n10 5 20\n</div>\n<div class=\"sec_header\">\n样例输出1</div>\n<div class=\"sec_text\">\n...|-20<br />\n10-|<br />\n...|-5\n\t</div>\n<div class=\"sec_header\">\n样例输入2</div>\n<div class=\"sec_text\">\n5 10 20 8 4 7\n</div>\n<div class=\"sec_header\">\n样例输出2</div>\n<div class=\"sec_text\">\n.......|-20<br />\n..|-10-|<br />\n..|....|-8-|<br />\n..|........|-7<br />\n5-|<br />\n..|-4\n</div>\n","gpid":"T34","lanqiaotitle":"横向打印二叉树","memorylimit":"256.0MB","tid":"PREV-11","timelimit":"1.0s","title":"历届试题 横向打印二叉树","src":""},{"checkpoint":"堆","updatetime":"2013-10-19","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n\n<p>    幸运数是波兰数学家乌拉姆命名的。它采用与生成素数类似的“筛法”生成</p>。\n<p>    首先从1开始写出自然数1,2,3,4,5,6,....</p>\n<p>    1 就是第一个幸运数。</p>\n<p>    我们从2这个数开始。把所有序号能被2整除的项删除，变为：</p>\n<p>    1 _ 3 _ 5 _ 7 _ 9 ....</p>\n<p>    把它们缩紧，重新记序，为：</p>\n <p>   1 3 5 7 9 .... 。这时，3为第2个幸运数，然后把所有能被3整除的序号位置的数删去。注意，是序号位置，不是那个数本身能否被3整除!! 删除的应该是5，11, 17, ...</p>\n<p>    此时7为第3个幸运数，然后再删去序号位置能被7整除的(19,39,...)</p> \n <p>   最后剩下的序列类似：</p>\n<p>    1, 3, 7, 9, 13, 15, 21, 25, 31, 33, 37, 43, 49, 51, 63, 67, 69, 73, 75, 79, ...</p>\n\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\n输入两个正整数m n, 用空格分开 (m &lt; n &lt; 1000*1000)\n\n</div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\n程序输出 位于m和n之间的幸运数的个数（不包含m和n）。\n\n</div>\n<div class=\"sec_header\">\n样例输入1</div>\n<div class=\"sec_text\">\n1 20\n</div>\n<div class=\"sec_header\">\n样例输出1</div>\n<div class=\"sec_text\">\n5\n\t</div>\n<div class=\"sec_header\">\n样例输入2</div>\n<div class=\"sec_text\">\n30 69\n</div>\n<div class=\"sec_header\">\n样例输出2</div>\n<div class=\"sec_text\">\n8\n</div>","gpid":"T33","lanqiaotitle":"幸运数","memorylimit":"256.0MB","tid":"PREV-10","timelimit":"1.0s","title":"历届试题 幸运数","src":""},{"checkpoint":"深度优先遍历","updatetime":"2013-10-19","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n\n<p>很久以前，T王国空前繁荣。为了更好地管理国家，王国修建了大量的快速路，用于连接首都和王国内的各大城市。</p>\n<p>为节省经费，T国的大臣们经过思考，制定了一套优秀的修建方案，使得任何一个大城市都能从首都直接或者通过其他大城市间接到达。同时，如果不重复经过大城市，从首都到达每个大城市的方案都是唯一的。</p>\n<p>J是T国重要大臣，他巡查于各大城市之间，体察民情。所以，从一个城市马不停蹄地到另一个城市成了J最常做的事情。他有一个钱袋，用于存放往来城市间的路费。</p>\n<p>聪明的J发现，如果不在某个城市停下来修整，在连续行进过程中，他所花的路费与他已走过的距离有关，在走第x千米到第x+1千米这一千米中（x是整数），他花费的路费是x+10这么多。也就是说走1千米花费11，走2千米要花费23。</p>\n<p>J大臣想知道：他从某一个城市出发，中间不休息，到达另一个城市，所有可能花费的路费中最多是多少呢？</p>\n\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\n<p>输入的第一行包含一个整数n，表示包括首都在内的T王国的城市数</p>\n<p>城市从1开始依次编号，1号城市为首都。</p>\n<p>接下来n-1行，描述T国的高速路（T国的高速路一定是n-1条）</p>\n<p>每行三个整数Pi, Qi, Di，表示城市Pi和城市Qi之间有一条高速路，长度为Di千米。</p>\n\n</div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\n<p>输出一个整数，表示大臣J最多花费的路费是多少。</p>\n\n</div>\n<div class=\"sec_header\">\n样例输入1</div>\n<div class=\"sec_text\">\n5<br/>\n1 2 2<br />\n1 3 1<br />\n2 4 5<br />\n2 5 4<br/>\n</div>\n<div class=\"sec_header\">\n样例输出1</div>\n<div class=\"sec_text\">\n135\n\t</div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\n<p>大臣J从城市4到城市5要花费135的路费。</p>\n\n</div>","gpid":"T32","lanqiaotitle":"大臣的旅费","memorylimit":"256.0MB","tid":"PREV-9","timelimit":"1.0s","title":"历届试题 大臣的旅费","src":""},{"checkpoint":"数论 动态规划","updatetime":"2013-10-19","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n\n<p>小明开了一家糖果店。他别出心裁：把水果糖包成4颗一包和7颗一包的两种。糖果不能拆包卖。</p>\n<p>小朋友来买糖的时候，他就用这两种包装来组合。当然有些糖果数目是无法组合出来的，比如要买 10 颗糖。</p>\n<p>你可以用计算机测试一下，在这种包装情况下，最大不能买到的数量是17。大于17的任何数字都可以用4和7组合出来。</p>\n<p>本题的要求就是在已知两个包装的数量时，求最大不能组合出的数字。</p>\n\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\n<p>两个正整数，表示每种包装中糖的颗数(都不多于1000)</p>\n\n</div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\n<p>一个正整数，表示最大不能买到的糖数</p>\n\n</div>\n<div class=\"sec_header\">\n样例输入1</div>\n<div class=\"sec_text\">\n4 7<br/>\n</div>\n<div class=\"sec_header\">\n样例输出1</div>\n<div class=\"sec_text\">\n17\n\t</div>\n<div class=\"sec_header\">\n样例输入2</div>\n<div class=\"sec_text\">\n3 5<br/>\n</div>\n<div class=\"sec_header\">\n样例输出2</div>\n<div class=\"sec_text\">\n7\n</div>","gpid":"T31","lanqiaotitle":"买不到的数目","memorylimit":"256.0MB","tid":"PREV-8","timelimit":"1.0s","title":"历届试题 买不到的数目","src":""},{"checkpoint":"并查集","updatetime":"2013-10-19","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n\n<p>小明这些天一直在思考这样一个奇怪而有趣的问题：</p>\n<p>在1~N的某个全排列中有多少个连号区间呢？这里所说的连号区间的定义是：</p>\n<p>如果区间[L, R] 里的所有元素（即此排列的第L个到第R个元素）递增排序后能得到一个长度为R-L+1的“连续”数列，则称这个区间连号区间。</p>\n<p>当N很小的时候，小明可以很快地算出答案，但是当N变大的时候，问题就不是那么简单了，现在小明需要你的帮助。</p>\n\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\n<p>第一行是一个正整数N (1 <= N <= 50000), 表示全排列的规模。</p>\n<p>第二行是N个不同的数字Pi(1 <= Pi <= N)， 表示这N个数字的某一全排列。</p>\n\n</div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\n<p>输出一个整数，表示不同连号区间的数目。</p>\n\n</div>\n<div class=\"sec_header\">\n样例输入1</div>\n<div class=\"sec_text\">\n4<br/>\n3 2 4 1<br />\n</div>\n<div class=\"sec_header\">\n样例输出1</div>\n<div class=\"sec_text\">\n7\n\t</div>\n<div class=\"sec_header\">\n样例输入2</div>\n<div class=\"sec_text\">\n5<br/>\n3 4 2 5 1<br />\n</div>\n<div class=\"sec_header\">\n样例输出2</div>\n<div class=\"sec_text\">\n9\n</div>","gpid":"T30","lanqiaotitle":"连号区间数","memorylimit":"256.0MB","tid":"PREV-7","timelimit":"1.0s","title":"历届试题 连号区间数","src":""},{"checkpoint":"贪心","updatetime":"2013-10-19","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n\n<p>小明正在玩一个“翻硬币”的游戏。</p>\n<p>桌上放着排成一排的若干硬币。我们用 * 表示正面，用 o 表示反面（是小写字母，不是零）。</p>\n<p>比如，可能情形是：**oo***oooo</p> \n<p>如果同时翻转左边的两个硬币，则变为：oooo***oooo</p>\n<p>现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币,那么对特定的局面，最少要翻动多少次呢？</p>\n<p>我们约定：把翻动相邻的两个硬币叫做一步操作，那么要求：\n\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\n<p>两行等长的字符串，分别表示初始状态和要达到的目标状态。每行的长度<1000</p>\n\n</div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\n<p>一个整数，表示最小操作步数。</p>\n\n</div>\n<div class=\"sec_header\">\n样例输入1</div>\n<div class=\"sec_text\">\n**********<br />\no****o****<br />\n</div>\n<div class=\"sec_header\">\n样例输出1</div>\n<div class=\"sec_text\">\n5\n\t</div>\n<div class=\"sec_header\">\n样例输入2</div>\n<div class=\"sec_text\">\n*o**o***o***<br />\n*o***o**o***<br />\n</div>\n<div class=\"sec_header\">\n样例输出2</div>\n<div class=\"sec_text\">\n1\n</div>","gpid":"T29","lanqiaotitle":"翻硬币","memorylimit":"256.0MB","tid":"PREV-6","timelimit":"1.0s","title":"历届试题 翻硬币","src":""},{"checkpoint":"排序","updatetime":"2013-10-19","content":"<div class=\"sec_header\">问题描述</div>\n<div class=\"sec_cont\">\n<p>某涉密单位下发了某种票据，并要在年终全部收回。</p>\n<p>每张票据有唯一的ID号。全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。</p>\n<p>因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。</p>\n<p>你的任务是通过编程，找出断号的ID和重号的ID。</p>\n<p>假设断号不可能发生在最大和最小号。</p>\n</div>\n<div class=\"sec_header\">输入格式</div>\n<div class=\"sec_cont\">\n<p>要求程序首先输入一个整数N(N&lt;100)表示后面数据行数。</p>\n<p>接着读入N行数据。</p>\n<p>每行数据长度不等，是用空格分开的若干个（不大于100个）正整数（不大于100000），请注意行内和行末可能有多余的空格，你的程序需要能处理这些空格。</p>\n<p>每个整数代表一个ID号。</p>\n</div>\n<div class=\"sec_header\">输出格式</div>\n<div class=\"sec_cont\">\n<p>要求程序输出1行，含两个整数m n，用空格分隔。</p>\n<p>其中，m表示断号ID，n表示重号ID</p>\n</div>\n<div class=\"sec_header\">样例输入1</div>\n<div class=\"sec_text\">2<br />\n5 6 8 11 9 <br />\n10 12 9</div>\n<div class=\"sec_header\">样例输出1</div>\n<div class=\"sec_text\">7 9</div>\n<div class=\"sec_header\">样例输入2</div>\n<div class=\"sec_text\">6<br />\n164 178 108 109 180 155 141 159 104 182 179 118 137 184 115 124 125 129 168 196<br />\n172 189 127 107 112 192 103 131 133 169 158 <br />\n128 102 110 148 139 157 140 195 197<br />\n185 152 135 106 123 173 122 136 174 191 145 116 151 143 175 120 161 134 162 190<br />\n149 138 142 146 199 126 165 156 153 193 144 166 170 121 171 132 101 194 187 188<br />\n113 130 176 154 177 120 117 150 114 183 186 181 100 163 160 167 147 198 111 119</div>\n<div class=\"sec_header\">样例输出2</div>\n<div class=\"sec_text\">105 120</div>","gpid":"T28","lanqiaotitle":"错误票据","memorylimit":"256.0MB","tid":"PREV-5","timelimit":"1.0s","title":"历届试题 错误票据","src":""},{"checkpoint":"搜索","updatetime":"2013-10-19","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n<p>如下图所示，3 x 3 的格子中填写了一些整数。</p>\n<div class=\"sec_text\">\n+--*--+--+<br />\n|10* 1|52|<br />\n+--****--+<br />\n|20|30* 1|<br />\n*******--+<br />\n| 1| 2| 3|<br />\n+--+--+--+\n</div>\n<p>我们沿着图中的星号线剪开，得到两个部分，每个部分的数字和都是60。</p>\n\n<p>本题的要求就是请你编程判定：对给定的m x n 的格子中的整数，是否可以分割为两个部分，使得这两个区域的数字和相等。</p>\n<p>如果存在多种解答，请输出包含左上角格子的那个区域包含的格子的最小数目。   </p>\n<p>如果无法分割，则输出 0。</p>\n\n\t</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\t<p>程序先读入两个整数 m n 用空格分割 (m,n&lt;10)。</p>\n\t<p>表示表格的宽度和高度。</p>\n\t<p>接下来是n行，每行m个正整数，用空格分开。每个整数不大于10000。</p>\n </div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n输出一个整数，表示在所有解中，包含左上角的分割区可能包含的最小的格子数目。\n</div>\n<div class=\"sec_header\">\n样例输入1</div>\n<div class=\"sec_text\">\n3 3<br />\n10 1 52<br />\n20 30 1<br />\n1 2 3\n</div>\n<div class=\"sec_header\">\n样例输出1</div>\n<div class=\"sec_text\">\n3\n\t</div>\n<div class=\"sec_header\">\n样例输入2</div>\n<div class=\"sec_text\">\n4 3<br />\n1 1 1 1<br />\n1 30 80 2<br />\n1 1 1 100\n</div>\n<div class=\"sec_header\">\n样例输出2</div>\n<div class=\"sec_text\">\n10\n</div>","gpid":"T27","lanqiaotitle":"剪格子","memorylimit":"256.0MB","tid":"PREV-4","timelimit":"1.0s","title":"历届试题 剪格子","src":""},{"checkpoint":"搜索","updatetime":"2013-10-19","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n<p>100 可以表示为带分数的形式：100 = 3 + 69258 / 714。</p>\n<p>还可以表示为：100 = 82 + 3546 / 197。</p>\n<p>注意特征：带分数中，数字1~9分别出现且只出现一次（不包含0）。</p>\n<p>类似这样的带分数，100 有 11 种表示法。</p>\n\t</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n<p>从标准输入读入一个正整数N (N&lt;1000*1000)</p>\n </div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n<p>程序输出该数字用数码1~9不重复不遗漏地组成带分数表示的全部种数。</p>\n<p>注意：不要求输出每个表示，只统计有多少表示法！</p>\n</div>\n<div class=\"sec_header\">\n样例输入1</div>\n<div class=\"sec_text\">\n100\n</div>\n<div class=\"sec_header\">\n样例输出1</div>\n<div class=\"sec_text\">\n11\n\t</div>\n<div class=\"sec_header\">\n样例输入2</div>\n<div class=\"sec_text\">\n105\n</div>\n<div class=\"sec_header\">\n样例输出2</div>\n<div class=\"sec_text\">\n6\n</div>","gpid":"T26","lanqiaotitle":"带分数","memorylimit":"256.0MB","tid":"PREV-3","timelimit":"1.0s","title":"历届试题 带分数","src":""},{"checkpoint":"文字图形","updatetime":"2013-10-19","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n<p>   小明为某机构设计了一个十字型的徽标（并非红十字会啊），如下所示：</p>\n<div class=\"sec_text\">\n..$$$$$$$$$$$$$..<br />\n..$...........$..<br />\n$$$.$$$$$$$$$.$$$<br />\n$...$.......$...$<br />\n$.$$$.$$$$$.$$$.$<br />\n$.$...$...$...$.$<br />\n$.$.$$$.$.$$$.$.$<br />\n$.$.$...$...$.$.$<br />\n$.$.$.$$$$$.$.$.$<br />\n$.$.$...$...$.$.$<br />\n$.$.$$$.$.$$$.$.$<br />\n$.$...$...$...$.$<br />\n$.$$$.$$$$$.$$$.$<br />\n$...$.......$...$<br />\n$$$.$$$$$$$$$.$$$<br />\n..$...........$..<br />\n..$$$$$$$$$$$$$..\n</div>\n<p>   对方同时也需要在电脑dos窗口中以字符的形式输出该标志，并能任意控制层数。</p>\n\t</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\t一个正整数 n (n&lt;30) 表示要求打印图形的层数。\n </div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\t对应包围层数的该标志。\n</div>\n<div class=\"sec_header\">\n样例输入1</div>\n<div class=\"sec_text\">\n1\n</div>\n<div class=\"sec_header\">\n样例输出1</div>\n<div class=\"sec_text\">\n..$$$$$..<br />\n..$...$..<br />\n$$$.$.$$$<br />\n$...$...$<br />\n$.$$$$$.$<br />\n$...$...$<br />\n$$$.$.$$$<br />\n..$...$..<br />\n..$$$$$..\n\t</div>\n<div class=\"sec_header\">\n样例输入2</div>\n<div class=\"sec_text\">\n3\n</div>\n<div class=\"sec_header\">\n样例输出2</div>\n<div class=\"sec_text\">\n..$$$$$$$$$$$$$..<br />\n..$...........$..<br />\n$$$.$$$$$$$$$.$$$<br />\n$...$.......$...$<br />\n$.$$$.$$$$$.$$$.$<br />\n$.$...$...$...$.$<br />\n$.$.$$$.$.$$$.$.$<br />\n$.$.$...$...$.$.$<br />\n$.$.$.$$$$$.$.$.$<br />\n$.$.$...$...$.$.$<br />\n$.$.$$$.$.$$$.$.$<br />\n$.$...$...$...$.$<br />\n$.$$$.$$$$$.$$$.$<br />\n$...$.......$...$<br />\n$$$.$$$$$$$$$.$$$<br />\n..$...........$..<br />\n..$$$$$$$$$$$$$..\n</div>\n<div class=\"sec_header\">\n提示</div>\n<div class=\"sec_cont\">\n\t请仔细观察样例，尤其要注意句点的数量和输出位置。\n</div>","gpid":"T25","lanqiaotitle":"打印十字图","memorylimit":"256.0MB","tid":"PREV-2","timelimit":"1.0s","title":"历届试题 打印十字图","src":""},{"checkpoint":"最小公倍数","updatetime":"2013-10-19","content":"<div class=\"sec_header\">\n问题描述</div>\n<div class=\"sec_cont\">\n<p>小张是软件项目经理，他带领3个开发组。工期紧，今天都在加班呢。为鼓舞士气，小张打算给每个组发一袋核桃（据传言能补脑）。他的要求是：</p>\n<p>1. 各组的核桃数量必须相同</p>\n<p>2. 各组内必须能平分核桃（当然是不能打碎的）</p>\n<p>3. 尽量提供满足1,2条件的最小数量（节约闹革命嘛）</p>\n</div>\n<div class=\"sec_header\">\n输入格式</div>\n<div class=\"sec_cont\">\n\t输入包含三个正整数a, b, c，表示每个组正在加班的人数，用空格分开（a,b,c&lt;30）\n </div>\n<div class=\"sec_header\">\n输出格式</div>\n<div class=\"sec_cont\">\n\t输出一个正整数，表示每袋核桃的数量。\n</div>\n<div class=\"sec_header\">\n样例输入1</div>\n<div class=\"sec_text\">\n2 4 5\n</div>\n<div class=\"sec_header\">\n样例输出1</div>\n<div class=\"sec_text\">\n20\n\t</div>\n<div class=\"sec_header\">\n样例输入2</div>\n<div class=\"sec_text\">\n3 1 1\n</div>\n<div class=\"sec_header\">\n样例输出2</div>\n<div class=\"sec_text\">\n3\n\t</div>","gpid":"T24","lanqiaotitle":"核桃的数量","memorylimit":"256.0MB","tid":"PREV-1","timelimit":"1.0s","title":"历届试题 核桃的数量","src":""}]}];